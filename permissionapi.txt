Android Developers
Essentials
 
Design & Plan
 
Develop
 
Google Play
 
Community
 
Search

中文 – 简体
Android Studio  Android Studio的
登录
NDK
Overview
 
Downloads
 下载
Samples
 样品
Guides
 
Reference
 
Filter

Home  
NDK
Develop  
Reference  参考
该内容对您有帮助吗？

Camera 

bookmark_border
 #include <NdkCameraCaptureSession.h>
#include <NdkCameraDevice.h>
#include <NdkCameraError.h>
#include <NdkCameraManager.h>
#include <NdkCameraMetadata.h>
#include <NdkCameraMetadataTags.h>
#include <NdkCameraWindowType.h>
#include <NdkCaptureRequest.h>
Summary 
Enumerations 
Anonymous Enum 115{
  CAPTURE_FAILURE_REASON_FLUSHED = 0,
  CAPTURE_FAILURE_REASON_ERROR
}	enum
Enum for describing error reason in ACameraCaptureFailure.
Anonymous Enum 116{
  CAPTURE_SEQUENCE_ID_NONE = -1
}	enum
Anonymous Enum 117{
  ERROR_CAMERA_IN_USE = 1,
  ERROR_MAX_CAMERAS_IN_USE = 2,
  ERROR_CAMERA_DISABLED = 3,
  ERROR_CAMERA_DEVICE = 4,
  ERROR_CAMERA_SERVICE = 5
}	enum
Enum for ACameraDevice_ErrorStateCallback error code.
Anonymous Enum 118{
  ACAMERA_TYPE_BYTE = 0,
  ACAMERA_TYPE_INT32 = 1,
  ACAMERA_TYPE_FLOAT = 2,
  ACAMERA_TYPE_INT64 = 3,
  ACAMERA_TYPE_DOUBLE = 4,
  ACAMERA_TYPE_RATIONAL = 5,
  ACAMERA_NUM_TYPES
}	enum
Possible data types of a metadata entry.
ACameraDevice_request_template{
  TEMPLATE_PREVIEW = 1,
  TEMPLATE_STILL_CAPTURE = 2,
  TEMPLATE_RECORD = 3,
  TEMPLATE_VIDEO_SNAPSHOT = 4,
  TEMPLATE_ZERO_SHUTTER_LAG = 5,
  TEMPLATE_MANUAL = 6
}	enum
Capture request pre-defined template types, used in ACameraDevice_createCaptureRequest and ACameraDevice_createCaptureRequest_withPhysicalIds.
acamera_metadata_enum_acamera_automotive_lens_facing{
  ACAMERA_AUTOMOTIVE_LENS_FACING_EXTERIOR_OTHER = 0,
  ACAMERA_AUTOMOTIVE_LENS_FACING_EXTERIOR_FRONT = 1,
  ACAMERA_AUTOMOTIVE_LENS_FACING_EXTERIOR_REAR = 2,
  ACAMERA_AUTOMOTIVE_LENS_FACING_EXTERIOR_LEFT = 3,
  ACAMERA_AUTOMOTIVE_LENS_FACING_EXTERIOR_RIGHT = 4,
  ACAMERA_AUTOMOTIVE_LENS_FACING_INTERIOR_OTHER = 5,
  ACAMERA_AUTOMOTIVE_LENS_FACING_INTERIOR_SEAT_ROW_1_LEFT = 6,
  ACAMERA_AUTOMOTIVE_LENS_FACING_INTERIOR_SEAT_ROW_1_CENTER = 7,
  ACAMERA_AUTOMOTIVE_LENS_FACING_INTERIOR_SEAT_ROW_1_RIGHT = 8,
  ACAMERA_AUTOMOTIVE_LENS_FACING_INTERIOR_SEAT_ROW_2_LEFT = 9,
  ACAMERA_AUTOMOTIVE_LENS_FACING_INTERIOR_SEAT_ROW_2_CENTER = 10,
  ACAMERA_AUTOMOTIVE_LENS_FACING_INTERIOR_SEAT_ROW_2_RIGHT = 11,
  ACAMERA_AUTOMOTIVE_LENS_FACING_INTERIOR_SEAT_ROW_3_LEFT = 12,
  ACAMERA_AUTOMOTIVE_LENS_FACING_INTERIOR_SEAT_ROW_3_CENTER = 13,
  ACAMERA_AUTOMOTIVE_LENS_FACING_INTERIOR_SEAT_ROW_3_RIGHT = 14
}	enum
acamera_metadata_enum_acamera_automotive_location{
  ACAMERA_AUTOMOTIVE_LOCATION_INTERIOR = 0,
  ACAMERA_AUTOMOTIVE_LOCATION_EXTERIOR_OTHER = 1,
  ACAMERA_AUTOMOTIVE_LOCATION_EXTERIOR_FRONT = 2,
  ACAMERA_AUTOMOTIVE_LOCATION_EXTERIOR_REAR = 3,
  ACAMERA_AUTOMOTIVE_LOCATION_EXTERIOR_LEFT = 4,
  ACAMERA_AUTOMOTIVE_LOCATION_EXTERIOR_RIGHT = 5,
  ACAMERA_AUTOMOTIVE_LOCATION_EXTRA_OTHER = 6,
  ACAMERA_AUTOMOTIVE_LOCATION_EXTRA_FRONT = 7,
  ACAMERA_AUTOMOTIVE_LOCATION_EXTRA_REAR = 8,
  ACAMERA_AUTOMOTIVE_LOCATION_EXTRA_LEFT = 9,
  ACAMERA_AUTOMOTIVE_LOCATION_EXTRA_RIGHT = 10
}	enum
acamera_metadata_enum_acamera_black_level_lock{
  ACAMERA_BLACK_LEVEL_LOCK_OFF = 0,
  ACAMERA_BLACK_LEVEL_LOCK_ON = 1
}	enum
acamera_metadata_enum_acamera_color_correction_aberration_mode{
  ACAMERA_COLOR_CORRECTION_ABERRATION_MODE_OFF = 0,
  ACAMERA_COLOR_CORRECTION_ABERRATION_MODE_FAST = 1,
  ACAMERA_COLOR_CORRECTION_ABERRATION_MODE_HIGH_QUALITY = 2
}	enum
acamera_metadata_enum_acamera_color_correction_mode{
  ACAMERA_COLOR_CORRECTION_MODE_TRANSFORM_MATRIX = 0,
  ACAMERA_COLOR_CORRECTION_MODE_FAST = 1,
  ACAMERA_COLOR_CORRECTION_MODE_HIGH_QUALITY = 2
}	enum
Enumeration definitions for the various entries that need them.
acamera_metadata_enum_acamera_control_ae_antibanding_mode{
  ACAMERA_CONTROL_AE_ANTIBANDING_MODE_OFF = 0,
  ACAMERA_CONTROL_AE_ANTIBANDING_MODE_50HZ = 1,
  ACAMERA_CONTROL_AE_ANTIBANDING_MODE_60HZ = 2,
  ACAMERA_CONTROL_AE_ANTIBANDING_MODE_AUTO = 3
}	enum
acamera_metadata_enum_acamera_control_ae_lock{
  ACAMERA_CONTROL_AE_LOCK_OFF = 0,
  ACAMERA_CONTROL_AE_LOCK_ON = 1
}	enum
acamera_metadata_enum_acamera_control_ae_lock_available{
  ACAMERA_CONTROL_AE_LOCK_AVAILABLE_FALSE = 0,
  ACAMERA_CONTROL_AE_LOCK_AVAILABLE_TRUE = 1
}	enum
acamera_metadata_enum_acamera_control_ae_mode{
  ACAMERA_CONTROL_AE_MODE_OFF = 0,
  ACAMERA_CONTROL_AE_MODE_ON = 1,
  ACAMERA_CONTROL_AE_MODE_ON_AUTO_FLASH = 2,
  ACAMERA_CONTROL_AE_MODE_ON_ALWAYS_FLASH = 3,
  ACAMERA_CONTROL_AE_MODE_ON_AUTO_FLASH_REDEYE = 4,
  ACAMERA_CONTROL_AE_MODE_ON_EXTERNAL_FLASH = 5
}	enum
acamera_metadata_enum_acamera_control_ae_precapture_trigger{
  ACAMERA_CONTROL_AE_PRECAPTURE_TRIGGER_IDLE = 0,
  ACAMERA_CONTROL_AE_PRECAPTURE_TRIGGER_START = 1,
  ACAMERA_CONTROL_AE_PRECAPTURE_TRIGGER_CANCEL = 2
}	enum
acamera_metadata_enum_acamera_control_ae_state{
  ACAMERA_CONTROL_AE_STATE_INACTIVE = 0,
  ACAMERA_CONTROL_AE_STATE_SEARCHING = 1,
  ACAMERA_CONTROL_AE_STATE_CONVERGED = 2,
  ACAMERA_CONTROL_AE_STATE_LOCKED = 3,
  ACAMERA_CONTROL_AE_STATE_FLASH_REQUIRED = 4,
  ACAMERA_CONTROL_AE_STATE_PRECAPTURE = 5
}	enum
acamera_metadata_enum_acamera_control_af_mode{
  ACAMERA_CONTROL_AF_MODE_OFF = 0,
  ACAMERA_CONTROL_AF_MODE_AUTO = 1,
  ACAMERA_CONTROL_AF_MODE_MACRO = 2,
  ACAMERA_CONTROL_AF_MODE_CONTINUOUS_VIDEO = 3,
  ACAMERA_CONTROL_AF_MODE_CONTINUOUS_PICTURE = 4,
  ACAMERA_CONTROL_AF_MODE_EDOF = 5
}	enum
acamera_metadata_enum_acamera_control_af_scene_change{
  ACAMERA_CONTROL_AF_SCENE_CHANGE_NOT_DETECTED = 0,
  ACAMERA_CONTROL_AF_SCENE_CHANGE_DETECTED = 1
}	enum
acamera_metadata_enum_acamera_control_af_state{
  ACAMERA_CONTROL_AF_STATE_INACTIVE = 0,
  ACAMERA_CONTROL_AF_STATE_PASSIVE_SCAN = 1,
  ACAMERA_CONTROL_AF_STATE_PASSIVE_FOCUSED = 2,
  ACAMERA_CONTROL_AF_STATE_ACTIVE_SCAN = 3,
  ACAMERA_CONTROL_AF_STATE_FOCUSED_LOCKED = 4,
  ACAMERA_CONTROL_AF_STATE_NOT_FOCUSED_LOCKED = 5,
  ACAMERA_CONTROL_AF_STATE_PASSIVE_UNFOCUSED = 6
}	enum
acamera_metadata_enum_acamera_control_af_trigger{
  ACAMERA_CONTROL_AF_TRIGGER_IDLE = 0,
  ACAMERA_CONTROL_AF_TRIGGER_START = 1,
  ACAMERA_CONTROL_AF_TRIGGER_CANCEL = 2
}	enum
acamera_metadata_enum_acamera_control_awb_lock{
  ACAMERA_CONTROL_AWB_LOCK_OFF = 0,
  ACAMERA_CONTROL_AWB_LOCK_ON = 1
}	enum
acamera_metadata_enum_acamera_control_awb_lock_available{
  ACAMERA_CONTROL_AWB_LOCK_AVAILABLE_FALSE = 0,
  ACAMERA_CONTROL_AWB_LOCK_AVAILABLE_TRUE = 1
}	enum
acamera_metadata_enum_acamera_control_awb_mode{
  ACAMERA_CONTROL_AWB_MODE_OFF = 0,
  ACAMERA_CONTROL_AWB_MODE_AUTO = 1,
  ACAMERA_CONTROL_AWB_MODE_INCANDESCENT = 2,
  ACAMERA_CONTROL_AWB_MODE_FLUORESCENT = 3,
  ACAMERA_CONTROL_AWB_MODE_WARM_FLUORESCENT = 4,
  ACAMERA_CONTROL_AWB_MODE_DAYLIGHT = 5,
  ACAMERA_CONTROL_AWB_MODE_CLOUDY_DAYLIGHT = 6,
  ACAMERA_CONTROL_AWB_MODE_TWILIGHT = 7,
  ACAMERA_CONTROL_AWB_MODE_SHADE = 8
}	enum
acamera_metadata_enum_acamera_control_awb_state{
  ACAMERA_CONTROL_AWB_STATE_INACTIVE = 0,
  ACAMERA_CONTROL_AWB_STATE_SEARCHING = 1,
  ACAMERA_CONTROL_AWB_STATE_CONVERGED = 2,
  ACAMERA_CONTROL_AWB_STATE_LOCKED = 3
}	enum
acamera_metadata_enum_acamera_control_capture_intent{
  ACAMERA_CONTROL_CAPTURE_INTENT_CUSTOM = 0,
  ACAMERA_CONTROL_CAPTURE_INTENT_PREVIEW = 1,
  ACAMERA_CONTROL_CAPTURE_INTENT_STILL_CAPTURE = 2,
  ACAMERA_CONTROL_CAPTURE_INTENT_VIDEO_RECORD = 3,
  ACAMERA_CONTROL_CAPTURE_INTENT_VIDEO_SNAPSHOT = 4,
  ACAMERA_CONTROL_CAPTURE_INTENT_ZERO_SHUTTER_LAG = 5,
  ACAMERA_CONTROL_CAPTURE_INTENT_MANUAL = 6,
  ACAMERA_CONTROL_CAPTURE_INTENT_MOTION_TRACKING = 7
}	enum
acamera_metadata_enum_acamera_control_effect_mode{
  ACAMERA_CONTROL_EFFECT_MODE_OFF = 0,
  ACAMERA_CONTROL_EFFECT_MODE_MONO = 1,
  ACAMERA_CONTROL_EFFECT_MODE_NEGATIVE = 2,
  ACAMERA_CONTROL_EFFECT_MODE_SOLARIZE = 3,
  ACAMERA_CONTROL_EFFECT_MODE_SEPIA = 4,
  ACAMERA_CONTROL_EFFECT_MODE_POSTERIZE = 5,
  ACAMERA_CONTROL_EFFECT_MODE_WHITEBOARD = 6,
  ACAMERA_CONTROL_EFFECT_MODE_BLACKBOARD = 7,
  ACAMERA_CONTROL_EFFECT_MODE_AQUA = 8
}	enum
acamera_metadata_enum_acamera_control_enable_zsl{
  ACAMERA_CONTROL_ENABLE_ZSL_FALSE = 0,
  ACAMERA_CONTROL_ENABLE_ZSL_TRUE = 1
}	enum
acamera_metadata_enum_acamera_control_extended_scene_mode{
  ACAMERA_CONTROL_EXTENDED_SCENE_MODE_DISABLED = 0,
  ACAMERA_CONTROL_EXTENDED_SCENE_MODE_BOKEH_STILL_CAPTURE = 1,
  ACAMERA_CONTROL_EXTENDED_SCENE_MODE_BOKEH_CONTINUOUS = 2
}	enum
acamera_metadata_enum_acamera_control_mode{
  ACAMERA_CONTROL_MODE_OFF = 0,
  ACAMERA_CONTROL_MODE_AUTO = 1,
  ACAMERA_CONTROL_MODE_USE_SCENE_MODE = 2,
  ACAMERA_CONTROL_MODE_OFF_KEEP_STATE = 3,
  ACAMERA_CONTROL_MODE_USE_EXTENDED_SCENE_MODE = 4
}	enum
acamera_metadata_enum_acamera_control_scene_mode{
  ACAMERA_CONTROL_SCENE_MODE_DISABLED = 0,
  ACAMERA_CONTROL_SCENE_MODE_FACE_PRIORITY = 1,
  ACAMERA_CONTROL_SCENE_MODE_ACTION = 2,
  ACAMERA_CONTROL_SCENE_MODE_PORTRAIT = 3,
  ACAMERA_CONTROL_SCENE_MODE_LANDSCAPE = 4,
  ACAMERA_CONTROL_SCENE_MODE_NIGHT = 5,
  ACAMERA_CONTROL_SCENE_MODE_NIGHT_PORTRAIT = 6,
  ACAMERA_CONTROL_SCENE_MODE_THEATRE = 7,
  ACAMERA_CONTROL_SCENE_MODE_BEACH = 8,
  ACAMERA_CONTROL_SCENE_MODE_SNOW = 9,
  ACAMERA_CONTROL_SCENE_MODE_SUNSET = 10,
  ACAMERA_CONTROL_SCENE_MODE_STEADYPHOTO = 11,
  ACAMERA_CONTROL_SCENE_MODE_FIREWORKS = 12,
  ACAMERA_CONTROL_SCENE_MODE_SPORTS = 13,
  ACAMERA_CONTROL_SCENE_MODE_PARTY = 14,
  ACAMERA_CONTROL_SCENE_MODE_CANDLELIGHT = 15,
  ACAMERA_CONTROL_SCENE_MODE_BARCODE = 16,
  ACAMERA_CONTROL_SCENE_MODE_HDR = 18
}	enum
acamera_metadata_enum_acamera_control_video_stabilization_mode{
  ACAMERA_CONTROL_VIDEO_STABILIZATION_MODE_OFF = 0,
  ACAMERA_CONTROL_VIDEO_STABILIZATION_MODE_ON = 1,
  ACAMERA_CONTROL_VIDEO_STABILIZATION_MODE_PREVIEW_STABILIZATION = 2
}	enum
acamera_metadata_enum_acamera_depth_available_depth_stream_configurations{
  ACAMERA_DEPTH_AVAILABLE_DEPTH_STREAM_CONFIGURATIONS_OUTPUT = 0,
  ACAMERA_DEPTH_AVAILABLE_DEPTH_STREAM_CONFIGURATIONS_INPUT = 1
}	enum
acamera_metadata_enum_acamera_depth_available_depth_stream_configurations_maximum_resolution{
  ACAMERA_DEPTH_AVAILABLE_DEPTH_STREAM_CONFIGURATIONS_MAXIMUM_RESOLUTION_OUTPUT = 0,
  ACAMERA_DEPTH_AVAILABLE_DEPTH_STREAM_CONFIGURATIONS_MAXIMUM_RESOLUTION_INPUT = 1
}	enum
acamera_metadata_enum_acamera_depth_available_dynamic_depth_stream_configurations{
  ACAMERA_DEPTH_AVAILABLE_DYNAMIC_DEPTH_STREAM_CONFIGURATIONS_OUTPUT = 0,
  ACAMERA_DEPTH_AVAILABLE_DYNAMIC_DEPTH_STREAM_CONFIGURATIONS_INPUT = 1
}	enum
acamera_metadata_enum_acamera_depth_available_dynamic_depth_stream_configurations_maximum_resolution{
  ACAMERA_DEPTH_AVAILABLE_DYNAMIC_DEPTH_STREAM_CONFIGURATIONS_MAXIMUM_RESOLUTION_OUTPUT = 0,
  ACAMERA_DEPTH_AVAILABLE_DYNAMIC_DEPTH_STREAM_CONFIGURATIONS_MAXIMUM_RESOLUTION_INPUT = 1
}	enum
acamera_metadata_enum_acamera_depth_depth_is_exclusive{
  ACAMERA_DEPTH_DEPTH_IS_EXCLUSIVE_FALSE = 0,
  ACAMERA_DEPTH_DEPTH_IS_EXCLUSIVE_TRUE = 1
}	enum
acamera_metadata_enum_acamera_distortion_correction_mode{
  ACAMERA_DISTORTION_CORRECTION_MODE_OFF = 0,
  ACAMERA_DISTORTION_CORRECTION_MODE_FAST = 1,
  ACAMERA_DISTORTION_CORRECTION_MODE_HIGH_QUALITY = 2
}	enum
acamera_metadata_enum_acamera_edge_mode{
  ACAMERA_EDGE_MODE_OFF = 0,
  ACAMERA_EDGE_MODE_FAST = 1,
  ACAMERA_EDGE_MODE_HIGH_QUALITY = 2,
  ACAMERA_EDGE_MODE_ZERO_SHUTTER_LAG = 3
}	enum
acamera_metadata_enum_acamera_flash_info_available{
  ACAMERA_FLASH_INFO_AVAILABLE_FALSE = 0,
  ACAMERA_FLASH_INFO_AVAILABLE_TRUE = 1
}	enum
acamera_metadata_enum_acamera_flash_mode{
  ACAMERA_FLASH_MODE_OFF = 0,
  ACAMERA_FLASH_MODE_SINGLE = 1,
  ACAMERA_FLASH_MODE_TORCH = 2
}	enum
acamera_metadata_enum_acamera_flash_state{
  ACAMERA_FLASH_STATE_UNAVAILABLE = 0,
  ACAMERA_FLASH_STATE_CHARGING = 1,
  ACAMERA_FLASH_STATE_READY = 2,
  ACAMERA_FLASH_STATE_FIRED = 3,
  ACAMERA_FLASH_STATE_PARTIAL = 4
}	enum
acamera_metadata_enum_acamera_heic_available_heic_stream_configurations{
  ACAMERA_HEIC_AVAILABLE_HEIC_STREAM_CONFIGURATIONS_OUTPUT = 0,
  ACAMERA_HEIC_AVAILABLE_HEIC_STREAM_CONFIGURATIONS_INPUT = 1
}	enum
acamera_metadata_enum_acamera_heic_available_heic_stream_configurations_maximum_resolution{
  ACAMERA_HEIC_AVAILABLE_HEIC_STREAM_CONFIGURATIONS_MAXIMUM_RESOLUTION_OUTPUT = 0,
  ACAMERA_HEIC_AVAILABLE_HEIC_STREAM_CONFIGURATIONS_MAXIMUM_RESOLUTION_INPUT = 1
}	enum
acamera_metadata_enum_acamera_hot_pixel_mode{
  ACAMERA_HOT_PIXEL_MODE_OFF = 0,
  ACAMERA_HOT_PIXEL_MODE_FAST = 1,
  ACAMERA_HOT_PIXEL_MODE_HIGH_QUALITY = 2
}	enum
acamera_metadata_enum_acamera_info_supported_hardware_level{
  ACAMERA_INFO_SUPPORTED_HARDWARE_LEVEL_LIMITED = 0,
  ACAMERA_INFO_SUPPORTED_HARDWARE_LEVEL_FULL = 1,
  ACAMERA_INFO_SUPPORTED_HARDWARE_LEVEL_LEGACY = 2,
  ACAMERA_INFO_SUPPORTED_HARDWARE_LEVEL_3 = 3,
  ACAMERA_INFO_SUPPORTED_HARDWARE_LEVEL_EXTERNAL = 4
}	enum
acamera_metadata_enum_acamera_lens_facing{
  ACAMERA_LENS_FACING_FRONT = 0,
  ACAMERA_LENS_FACING_BACK = 1,
  ACAMERA_LENS_FACING_EXTERNAL = 2
}	enum
acamera_metadata_enum_acamera_lens_info_focus_distance_calibration{
  ACAMERA_LENS_INFO_FOCUS_DISTANCE_CALIBRATION_UNCALIBRATED = 0,
  ACAMERA_LENS_INFO_FOCUS_DISTANCE_CALIBRATION_APPROXIMATE = 1,
  ACAMERA_LENS_INFO_FOCUS_DISTANCE_CALIBRATION_CALIBRATED = 2
}	enum
acamera_metadata_enum_acamera_lens_optical_stabilization_mode{
  ACAMERA_LENS_OPTICAL_STABILIZATION_MODE_OFF = 0,
  ACAMERA_LENS_OPTICAL_STABILIZATION_MODE_ON = 1
}	enum
acamera_metadata_enum_acamera_lens_pose_reference{
  ACAMERA_LENS_POSE_REFERENCE_PRIMARY_CAMERA = 0,
  ACAMERA_LENS_POSE_REFERENCE_GYROSCOPE = 1,
  ACAMERA_LENS_POSE_REFERENCE_UNDEFINED = 2,
  ACAMERA_LENS_POSE_REFERENCE_AUTOMOTIVE = 3
}	enum
acamera_metadata_enum_acamera_lens_state{
  ACAMERA_LENS_STATE_STATIONARY = 0,
  ACAMERA_LENS_STATE_MOVING = 1
}	enum
acamera_metadata_enum_acamera_logical_multi_camera_sensor_sync_type{
  ACAMERA_LOGICAL_MULTI_CAMERA_SENSOR_SYNC_TYPE_APPROXIMATE = 0,
  ACAMERA_LOGICAL_MULTI_CAMERA_SENSOR_SYNC_TYPE_CALIBRATED = 1
}	enum
acamera_metadata_enum_acamera_noise_reduction_mode{
  ACAMERA_NOISE_REDUCTION_MODE_OFF = 0,
  ACAMERA_NOISE_REDUCTION_MODE_FAST = 1,
  ACAMERA_NOISE_REDUCTION_MODE_HIGH_QUALITY = 2,
  ACAMERA_NOISE_REDUCTION_MODE_MINIMAL = 3,
  ACAMERA_NOISE_REDUCTION_MODE_ZERO_SHUTTER_LAG = 4
}	enum
acamera_metadata_enum_acamera_request_available_capabilities{
  ACAMERA_REQUEST_AVAILABLE_CAPABILITIES_BACKWARD_COMPATIBLE = 0,
  ACAMERA_REQUEST_AVAILABLE_CAPABILITIES_MANUAL_SENSOR = 1,
  ACAMERA_REQUEST_AVAILABLE_CAPABILITIES_MANUAL_POST_PROCESSING = 2,
  ACAMERA_REQUEST_AVAILABLE_CAPABILITIES_RAW = 3,
  ACAMERA_REQUEST_AVAILABLE_CAPABILITIES_READ_SENSOR_SETTINGS = 5,
  ACAMERA_REQUEST_AVAILABLE_CAPABILITIES_BURST_CAPTURE = 6,
  ACAMERA_REQUEST_AVAILABLE_CAPABILITIES_DEPTH_OUTPUT = 8,
  ACAMERA_REQUEST_AVAILABLE_CAPABILITIES_MOTION_TRACKING = 10,
  ACAMERA_REQUEST_AVAILABLE_CAPABILITIES_LOGICAL_MULTI_CAMERA = 11,
  ACAMERA_REQUEST_AVAILABLE_CAPABILITIES_MONOCHROME = 12,
  ACAMERA_REQUEST_AVAILABLE_CAPABILITIES_SECURE_IMAGE_DATA = 13,
  ACAMERA_REQUEST_AVAILABLE_CAPABILITIES_SYSTEM_CAMERA = 14,
  ACAMERA_REQUEST_AVAILABLE_CAPABILITIES_ULTRA_HIGH_RESOLUTION_SENSOR = 16,
  ACAMERA_REQUEST_AVAILABLE_CAPABILITIES_STREAM_USE_CASE = 19
}	enum
acamera_metadata_enum_acamera_request_available_dynamic_range_profiles_map{
  ACAMERA_REQUEST_AVAILABLE_DYNAMIC_RANGE_PROFILES_MAP_STANDARD = 0x1,
  ACAMERA_REQUEST_AVAILABLE_DYNAMIC_RANGE_PROFILES_MAP_HLG10 = 0x2,
  ACAMERA_REQUEST_AVAILABLE_DYNAMIC_RANGE_PROFILES_MAP_HDR10 = 0x4,
  ACAMERA_REQUEST_AVAILABLE_DYNAMIC_RANGE_PROFILES_MAP_HDR10_PLUS = 0x8,
  ACAMERA_REQUEST_AVAILABLE_DYNAMIC_RANGE_PROFILES_MAP_DOLBY_VISION_10B_HDR_REF = 0x10,
  ACAMERA_REQUEST_AVAILABLE_DYNAMIC_RANGE_PROFILES_MAP_DOLBY_VISION_10B_HDR_REF_PO = 0x20,
  ACAMERA_REQUEST_AVAILABLE_DYNAMIC_RANGE_PROFILES_MAP_DOLBY_VISION_10B_HDR_OEM = 0x40,
  ACAMERA_REQUEST_AVAILABLE_DYNAMIC_RANGE_PROFILES_MAP_DOLBY_VISION_10B_HDR_OEM_PO = 0x80,
  ACAMERA_REQUEST_AVAILABLE_DYNAMIC_RANGE_PROFILES_MAP_DOLBY_VISION_8B_HDR_REF = 0x100,
  ACAMERA_REQUEST_AVAILABLE_DYNAMIC_RANGE_PROFILES_MAP_DOLBY_VISION_8B_HDR_REF_PO = 0x200,
  ACAMERA_REQUEST_AVAILABLE_DYNAMIC_RANGE_PROFILES_MAP_DOLBY_VISION_8B_HDR_OEM = 0x400,
  ACAMERA_REQUEST_AVAILABLE_DYNAMIC_RANGE_PROFILES_MAP_DOLBY_VISION_8B_HDR_OEM_PO = 0x800,
  ACAMERA_REQUEST_AVAILABLE_DYNAMIC_RANGE_PROFILES_MAP_MAX = 0x1000
}	enum
acamera_metadata_enum_acamera_scaler_available_recommended_stream_configurations{
  ACAMERA_SCALER_AVAILABLE_RECOMMENDED_STREAM_CONFIGURATIONS_PREVIEW = 0x0,
  ACAMERA_SCALER_AVAILABLE_RECOMMENDED_STREAM_CONFIGURATIONS_RECORD = 0x1,
  ACAMERA_SCALER_AVAILABLE_RECOMMENDED_STREAM_CONFIGURATIONS_VIDEO_SNAPSHOT = 0x2,
  ACAMERA_SCALER_AVAILABLE_RECOMMENDED_STREAM_CONFIGURATIONS_SNAPSHOT = 0x3,
  ACAMERA_SCALER_AVAILABLE_RECOMMENDED_STREAM_CONFIGURATIONS_ZSL = 0x4,
  ACAMERA_SCALER_AVAILABLE_RECOMMENDED_STREAM_CONFIGURATIONS_RAW = 0x5,
  ACAMERA_SCALER_AVAILABLE_RECOMMENDED_STREAM_CONFIGURATIONS_LOW_LATENCY_SNAPSHOT = 0x6,
  ACAMERA_SCALER_AVAILABLE_RECOMMENDED_STREAM_CONFIGURATIONS_PUBLIC_END = 0x7,
  ACAMERA_SCALER_AVAILABLE_RECOMMENDED_STREAM_CONFIGURATIONS_10BIT_OUTPUT = 0x8,
  ACAMERA_SCALER_AVAILABLE_RECOMMENDED_STREAM_CONFIGURATIONS_PUBLIC_END_3_8 = 0x9,
  ACAMERA_SCALER_AVAILABLE_RECOMMENDED_STREAM_CONFIGURATIONS_VENDOR_START = 0x18
}	enum
acamera_metadata_enum_acamera_scaler_available_stream_configurations{
  ACAMERA_SCALER_AVAILABLE_STREAM_CONFIGURATIONS_OUTPUT = 0,
  ACAMERA_SCALER_AVAILABLE_STREAM_CONFIGURATIONS_INPUT = 1
}	enum
acamera_metadata_enum_acamera_scaler_available_stream_configurations_maximum_resolution{
  ACAMERA_SCALER_AVAILABLE_STREAM_CONFIGURATIONS_MAXIMUM_RESOLUTION_OUTPUT = 0,
  ACAMERA_SCALER_AVAILABLE_STREAM_CONFIGURATIONS_MAXIMUM_RESOLUTION_INPUT = 1
}	enum
acamera_metadata_enum_acamera_scaler_available_stream_use_cases{
  ACAMERA_SCALER_AVAILABLE_STREAM_USE_CASES_DEFAULT = 0x0,
  ACAMERA_SCALER_AVAILABLE_STREAM_USE_CASES_PREVIEW = 0x1,
  ACAMERA_SCALER_AVAILABLE_STREAM_USE_CASES_STILL_CAPTURE = 0x2,
  ACAMERA_SCALER_AVAILABLE_STREAM_USE_CASES_VIDEO_RECORD = 0x3,
  ACAMERA_SCALER_AVAILABLE_STREAM_USE_CASES_PREVIEW_VIDEO_STILL = 0x4,
  ACAMERA_SCALER_AVAILABLE_STREAM_USE_CASES_VIDEO_CALL = 0x5
}	enum
acamera_metadata_enum_acamera_scaler_cropping_type{
  ACAMERA_SCALER_CROPPING_TYPE_CENTER_ONLY = 0,
  ACAMERA_SCALER_CROPPING_TYPE_FREEFORM = 1
}	enum
acamera_metadata_enum_acamera_scaler_multi_resolution_stream_supported{
  ACAMERA_SCALER_MULTI_RESOLUTION_STREAM_SUPPORTED_FALSE = 0,
  ACAMERA_SCALER_MULTI_RESOLUTION_STREAM_SUPPORTED_TRUE = 1
}	enum
acamera_metadata_enum_acamera_scaler_physical_camera_multi_resolution_stream_configurations{
  ACAMERA_SCALER_PHYSICAL_CAMERA_MULTI_RESOLUTION_STREAM_CONFIGURATIONS_OUTPUT = 0,
  ACAMERA_SCALER_PHYSICAL_CAMERA_MULTI_RESOLUTION_STREAM_CONFIGURATIONS_INPUT = 1
}	enum
acamera_metadata_enum_acamera_scaler_rotate_and_crop{
  ACAMERA_SCALER_ROTATE_AND_CROP_NONE = 0,
  ACAMERA_SCALER_ROTATE_AND_CROP_90 = 1,
  ACAMERA_SCALER_ROTATE_AND_CROP_180 = 2,
  ACAMERA_SCALER_ROTATE_AND_CROP_270 = 3,
  ACAMERA_SCALER_ROTATE_AND_CROP_AUTO = 4
}	enum
acamera_metadata_enum_acamera_sensor_info_color_filter_arrangement{
  ACAMERA_SENSOR_INFO_COLOR_FILTER_ARRANGEMENT_RGGB = 0,
  ACAMERA_SENSOR_INFO_COLOR_FILTER_ARRANGEMENT_GRBG = 1,
  ACAMERA_SENSOR_INFO_COLOR_FILTER_ARRANGEMENT_GBRG = 2,
  ACAMERA_SENSOR_INFO_COLOR_FILTER_ARRANGEMENT_BGGR = 3,
  ACAMERA_SENSOR_INFO_COLOR_FILTER_ARRANGEMENT_RGB = 4,
  ACAMERA_SENSOR_INFO_COLOR_FILTER_ARRANGEMENT_MONO = 5,
  ACAMERA_SENSOR_INFO_COLOR_FILTER_ARRANGEMENT_NIR = 6
}	enum
acamera_metadata_enum_acamera_sensor_info_lens_shading_applied{
  ACAMERA_SENSOR_INFO_LENS_SHADING_APPLIED_FALSE = 0,
  ACAMERA_SENSOR_INFO_LENS_SHADING_APPLIED_TRUE = 1
}	enum
acamera_metadata_enum_acamera_sensor_info_timestamp_source{
  ACAMERA_SENSOR_INFO_TIMESTAMP_SOURCE_UNKNOWN = 0,
  ACAMERA_SENSOR_INFO_TIMESTAMP_SOURCE_REALTIME = 1
}	enum
acamera_metadata_enum_acamera_sensor_pixel_mode{
  ACAMERA_SENSOR_PIXEL_MODE_DEFAULT = 0,
  ACAMERA_SENSOR_PIXEL_MODE_MAXIMUM_RESOLUTION = 1
}	enum
acamera_metadata_enum_acamera_sensor_raw_binning_factor_used{
  ACAMERA_SENSOR_RAW_BINNING_FACTOR_USED_TRUE = 0,
  ACAMERA_SENSOR_RAW_BINNING_FACTOR_USED_FALSE = 1
}	enum
acamera_metadata_enum_acamera_sensor_reference_illuminant1{
  ACAMERA_SENSOR_REFERENCE_ILLUMINANT1_DAYLIGHT = 1,
  ACAMERA_SENSOR_REFERENCE_ILLUMINANT1_FLUORESCENT = 2,
  ACAMERA_SENSOR_REFERENCE_ILLUMINANT1_TUNGSTEN = 3,
  ACAMERA_SENSOR_REFERENCE_ILLUMINANT1_FLASH = 4,
  ACAMERA_SENSOR_REFERENCE_ILLUMINANT1_FINE_WEATHER = 9,
  ACAMERA_SENSOR_REFERENCE_ILLUMINANT1_CLOUDY_WEATHER = 10,
  ACAMERA_SENSOR_REFERENCE_ILLUMINANT1_SHADE = 11,
  ACAMERA_SENSOR_REFERENCE_ILLUMINANT1_DAYLIGHT_FLUORESCENT = 12,
  ACAMERA_SENSOR_REFERENCE_ILLUMINANT1_DAY_WHITE_FLUORESCENT = 13,
  ACAMERA_SENSOR_REFERENCE_ILLUMINANT1_COOL_WHITE_FLUORESCENT = 14,
  ACAMERA_SENSOR_REFERENCE_ILLUMINANT1_WHITE_FLUORESCENT = 15,
  ACAMERA_SENSOR_REFERENCE_ILLUMINANT1_STANDARD_A = 17,
  ACAMERA_SENSOR_REFERENCE_ILLUMINANT1_STANDARD_B = 18,
  ACAMERA_SENSOR_REFERENCE_ILLUMINANT1_STANDARD_C = 19,
  ACAMERA_SENSOR_REFERENCE_ILLUMINANT1_D55 = 20,
  ACAMERA_SENSOR_REFERENCE_ILLUMINANT1_D65 = 21,
  ACAMERA_SENSOR_REFERENCE_ILLUMINANT1_D75 = 22,
  ACAMERA_SENSOR_REFERENCE_ILLUMINANT1_D50 = 23,
  ACAMERA_SENSOR_REFERENCE_ILLUMINANT1_ISO_STUDIO_TUNGSTEN = 24
}	enum
acamera_metadata_enum_acamera_sensor_test_pattern_mode{
  ACAMERA_SENSOR_TEST_PATTERN_MODE_OFF = 0,
  ACAMERA_SENSOR_TEST_PATTERN_MODE_SOLID_COLOR = 1,
  ACAMERA_SENSOR_TEST_PATTERN_MODE_COLOR_BARS = 2,
  ACAMERA_SENSOR_TEST_PATTERN_MODE_COLOR_BARS_FADE_TO_GRAY = 3,
  ACAMERA_SENSOR_TEST_PATTERN_MODE_PN9 = 4,
  ACAMERA_SENSOR_TEST_PATTERN_MODE_CUSTOM1 = 256
}	enum
acamera_metadata_enum_acamera_shading_mode{
  ACAMERA_SHADING_MODE_OFF = 0,
  ACAMERA_SHADING_MODE_FAST = 1,
  ACAMERA_SHADING_MODE_HIGH_QUALITY = 2
}	enum
acamera_metadata_enum_acamera_statistics_face_detect_mode{
  ACAMERA_STATISTICS_FACE_DETECT_MODE_OFF = 0,
  ACAMERA_STATISTICS_FACE_DETECT_MODE_SIMPLE = 1,
  ACAMERA_STATISTICS_FACE_DETECT_MODE_FULL = 2
}	enum
acamera_metadata_enum_acamera_statistics_hot_pixel_map_mode{
  ACAMERA_STATISTICS_HOT_PIXEL_MAP_MODE_OFF = 0,
  ACAMERA_STATISTICS_HOT_PIXEL_MAP_MODE_ON = 1
}	enum
acamera_metadata_enum_acamera_statistics_lens_shading_map_mode{
  ACAMERA_STATISTICS_LENS_SHADING_MAP_MODE_OFF = 0,
  ACAMERA_STATISTICS_LENS_SHADING_MAP_MODE_ON = 1
}	enum
acamera_metadata_enum_acamera_statistics_ois_data_mode{
  ACAMERA_STATISTICS_OIS_DATA_MODE_OFF = 0,
  ACAMERA_STATISTICS_OIS_DATA_MODE_ON = 1
}	enum
acamera_metadata_enum_acamera_statistics_scene_flicker{
  ACAMERA_STATISTICS_SCENE_FLICKER_NONE = 0,
  ACAMERA_STATISTICS_SCENE_FLICKER_50HZ = 1,
  ACAMERA_STATISTICS_SCENE_FLICKER_60HZ = 2
}	enum
acamera_metadata_enum_acamera_sync_frame_number{
  ACAMERA_SYNC_FRAME_NUMBER_CONVERGING = -1,
  ACAMERA_SYNC_FRAME_NUMBER_UNKNOWN = -2
}	enum
acamera_metadata_enum_acamera_sync_max_latency{
  ACAMERA_SYNC_MAX_LATENCY_PER_FRAME_CONTROL = 0,
  ACAMERA_SYNC_MAX_LATENCY_UNKNOWN = -1
}	enum
acamera_metadata_enum_acamera_tonemap_mode{
  ACAMERA_TONEMAP_MODE_CONTRAST_CURVE = 0,
  ACAMERA_TONEMAP_MODE_FAST = 1,
  ACAMERA_TONEMAP_MODE_HIGH_QUALITY = 2,
  ACAMERA_TONEMAP_MODE_GAMMA_VALUE = 3,
  ACAMERA_TONEMAP_MODE_PRESET_CURVE = 4
}	enum
acamera_metadata_enum_acamera_tonemap_preset_curve{
  ACAMERA_TONEMAP_PRESET_CURVE_SRGB = 0,
  ACAMERA_TONEMAP_PRESET_CURVE_REC709 = 1
}	enum
acamera_metadata_section{
  ACAMERA_COLOR_CORRECTION,
  ACAMERA_CONTROL,
  ACAMERA_DEMOSAIC,
  ACAMERA_EDGE,
  ACAMERA_FLASH,
  ACAMERA_FLASH_INFO,
  ACAMERA_HOT_PIXEL,
  ACAMERA_JPEG,
  ACAMERA_LENS,
  ACAMERA_LENS_INFO,
  ACAMERA_NOISE_REDUCTION,
  ACAMERA_QUIRKS,
  ACAMERA_REQUEST,
  ACAMERA_SCALER,
  ACAMERA_SENSOR,
  ACAMERA_SENSOR_INFO,
  ACAMERA_SHADING,
  ACAMERA_STATISTICS,
  ACAMERA_STATISTICS_INFO,
  ACAMERA_TONEMAP,
  ACAMERA_LED,
  ACAMERA_INFO,
  ACAMERA_BLACK_LEVEL,
  ACAMERA_SYNC,
  ACAMERA_REPROCESS,
  ACAMERA_DEPTH,
  ACAMERA_LOGICAL_MULTI_CAMERA,
  ACAMERA_DISTORTION_CORRECTION,
  ACAMERA_HEIC,
  ACAMERA_HEIC_INFO,
  ACAMERA_AUTOMOTIVE,
  ACAMERA_AUTOMOTIVE_LENS,
  ACAMERA_SECTION_COUNT,
  ACAMERA_VENDOR = 0x8000
}	enum
acamera_metadata_section_start{
  ACAMERA_COLOR_CORRECTION_START = ACAMERA_COLOR_CORRECTION << 16,
  ACAMERA_CONTROL_START = ACAMERA_CONTROL << 16,
  ACAMERA_DEMOSAIC_START = ACAMERA_DEMOSAIC << 16,
  ACAMERA_EDGE_START = ACAMERA_EDGE << 16,
  ACAMERA_FLASH_START = ACAMERA_FLASH << 16,
  ACAMERA_FLASH_INFO_START = ACAMERA_FLASH_INFO << 16,
  ACAMERA_HOT_PIXEL_START = ACAMERA_HOT_PIXEL << 16,
  ACAMERA_JPEG_START = ACAMERA_JPEG << 16,
  ACAMERA_LENS_START = ACAMERA_LENS << 16,
  ACAMERA_LENS_INFO_START = ACAMERA_LENS_INFO << 16,
  ACAMERA_NOISE_REDUCTION_START = ACAMERA_NOISE_REDUCTION << 16,
  ACAMERA_QUIRKS_START = ACAMERA_QUIRKS << 16,
  ACAMERA_REQUEST_START = ACAMERA_REQUEST << 16,
  ACAMERA_SCALER_START = ACAMERA_SCALER << 16,
  ACAMERA_SENSOR_START = ACAMERA_SENSOR << 16,
  ACAMERA_SENSOR_INFO_START = ACAMERA_SENSOR_INFO << 16,
  ACAMERA_SHADING_START = ACAMERA_SHADING << 16,
  ACAMERA_STATISTICS_START = ACAMERA_STATISTICS << 16,
  ACAMERA_STATISTICS_INFO_START = ACAMERA_STATISTICS_INFO << 16,
  ACAMERA_TONEMAP_START = ACAMERA_TONEMAP << 16,
  ACAMERA_LED_START = ACAMERA_LED << 16,
  ACAMERA_INFO_START = ACAMERA_INFO << 16,
  ACAMERA_BLACK_LEVEL_START = ACAMERA_BLACK_LEVEL << 16,
  ACAMERA_SYNC_START = ACAMERA_SYNC << 16,
  ACAMERA_REPROCESS_START = ACAMERA_REPROCESS << 16,
  ACAMERA_DEPTH_START = ACAMERA_DEPTH << 16,
  ACAMERA_LOGICAL_MULTI_CAMERA_START = ACAMERA_LOGICAL_MULTI_CAMERA << 16,
  ACAMERA_DISTORTION_CORRECTION_START = ACAMERA_DISTORTION_CORRECTION << 16,
  ACAMERA_HEIC_START = ACAMERA_HEIC << 16,
  ACAMERA_HEIC_INFO_START = ACAMERA_HEIC_INFO << 16,
  ACAMERA_AUTOMOTIVE_START = ACAMERA_AUTOMOTIVE << 16,
  ACAMERA_AUTOMOTIVE_LENS_START = ACAMERA_AUTOMOTIVE_LENS << 16,
  ACAMERA_VENDOR_START = ACAMERA_VENDOR << 16
}	enum
Hierarchy positions in enum space.
acamera_metadata_tag{
  ACAMERA_COLOR_CORRECTION_MODE = ACAMERA_COLOR_CORRECTION_START,
  ACAMERA_COLOR_CORRECTION_TRANSFORM = ACAMERA_COLOR_CORRECTION_START + 1,
  ACAMERA_COLOR_CORRECTION_GAINS = ACAMERA_COLOR_CORRECTION_START + 2,
  ACAMERA_COLOR_CORRECTION_ABERRATION_MODE = ACAMERA_COLOR_CORRECTION_START + 3,
  ACAMERA_COLOR_CORRECTION_AVAILABLE_ABERRATION_MODES = ACAMERA_COLOR_CORRECTION_START + 4,
  ACAMERA_COLOR_CORRECTION_END,
  ACAMERA_CONTROL_AE_ANTIBANDING_MODE = ACAMERA_CONTROL_START,
  ACAMERA_CONTROL_AE_EXPOSURE_COMPENSATION = ACAMERA_CONTROL_START + 1,
  ACAMERA_CONTROL_AE_LOCK = ACAMERA_CONTROL_START + 2,
  ACAMERA_CONTROL_AE_MODE = ACAMERA_CONTROL_START + 3,
  ACAMERA_CONTROL_AE_REGIONS = ACAMERA_CONTROL_START + 4,
  ACAMERA_CONTROL_AE_TARGET_FPS_RANGE = ACAMERA_CONTROL_START + 5,
  ACAMERA_CONTROL_AE_PRECAPTURE_TRIGGER = ACAMERA_CONTROL_START + 6,
  ACAMERA_CONTROL_AF_MODE = ACAMERA_CONTROL_START + 7,
  ACAMERA_CONTROL_AF_REGIONS = ACAMERA_CONTROL_START + 8,
  ACAMERA_CONTROL_AF_TRIGGER = ACAMERA_CONTROL_START + 9,
  ACAMERA_CONTROL_AWB_LOCK = ACAMERA_CONTROL_START + 10,
  ACAMERA_CONTROL_AWB_MODE = ACAMERA_CONTROL_START + 11,
  ACAMERA_CONTROL_AWB_REGIONS = ACAMERA_CONTROL_START + 12,
  ACAMERA_CONTROL_CAPTURE_INTENT = ACAMERA_CONTROL_START + 13,
  ACAMERA_CONTROL_EFFECT_MODE = ACAMERA_CONTROL_START + 14,
  ACAMERA_CONTROL_MODE = ACAMERA_CONTROL_START + 15,
  ACAMERA_CONTROL_SCENE_MODE = ACAMERA_CONTROL_START + 16,
  ACAMERA_CONTROL_VIDEO_STABILIZATION_MODE = ACAMERA_CONTROL_START + 17,
  ACAMERA_CONTROL_AE_AVAILABLE_ANTIBANDING_MODES = ACAMERA_CONTROL_START + 18,
  ACAMERA_CONTROL_AE_AVAILABLE_MODES = ACAMERA_CONTROL_START + 19,
  ACAMERA_CONTROL_AE_AVAILABLE_TARGET_FPS_RANGES = ACAMERA_CONTROL_START + 20,
  ACAMERA_CONTROL_AE_COMPENSATION_RANGE = ACAMERA_CONTROL_START + 21,
  ACAMERA_CONTROL_AE_COMPENSATION_STEP = ACAMERA_CONTROL_START + 22,
  ACAMERA_CONTROL_AF_AVAILABLE_MODES = ACAMERA_CONTROL_START + 23,
  ACAMERA_CONTROL_AVAILABLE_EFFECTS = ACAMERA_CONTROL_START + 24,
  ACAMERA_CONTROL_AVAILABLE_SCENE_MODES = ACAMERA_CONTROL_START + 25,
  ACAMERA_CONTROL_AVAILABLE_VIDEO_STABILIZATION_MODES = ACAMERA_CONTROL_START + 26,
  ACAMERA_CONTROL_AWB_AVAILABLE_MODES = ACAMERA_CONTROL_START + 27,
  ACAMERA_CONTROL_MAX_REGIONS = ACAMERA_CONTROL_START + 28,
  ACAMERA_CONTROL_AE_STATE = ACAMERA_CONTROL_START + 31,
  ACAMERA_CONTROL_AF_STATE = ACAMERA_CONTROL_START + 32,
  ACAMERA_CONTROL_AWB_STATE = ACAMERA_CONTROL_START + 34,
  ACAMERA_CONTROL_AE_LOCK_AVAILABLE = ACAMERA_CONTROL_START + 36,
  ACAMERA_CONTROL_AWB_LOCK_AVAILABLE = ACAMERA_CONTROL_START + 37,
  ACAMERA_CONTROL_AVAILABLE_MODES = ACAMERA_CONTROL_START + 38,
  ACAMERA_CONTROL_POST_RAW_SENSITIVITY_BOOST_RANGE = ACAMERA_CONTROL_START + 39,
  ACAMERA_CONTROL_POST_RAW_SENSITIVITY_BOOST = ACAMERA_CONTROL_START + 40,
  ACAMERA_CONTROL_ENABLE_ZSL = ACAMERA_CONTROL_START + 41,
  ACAMERA_CONTROL_AF_SCENE_CHANGE = ACAMERA_CONTROL_START + 42,
  ACAMERA_CONTROL_AVAILABLE_EXTENDED_SCENE_MODE_MAX_SIZES = ACAMERA_CONTROL_START + 43,
  ACAMERA_CONTROL_AVAILABLE_EXTENDED_SCENE_MODE_ZOOM_RATIO_RANGES = ACAMERA_CONTROL_START + 44,
  ACAMERA_CONTROL_EXTENDED_SCENE_MODE = ACAMERA_CONTROL_START + 45,
  ACAMERA_CONTROL_ZOOM_RATIO_RANGE = ACAMERA_CONTROL_START + 46,
  ACAMERA_CONTROL_ZOOM_RATIO = ACAMERA_CONTROL_START + 47,
  ACAMERA_CONTROL_END,
  ACAMERA_EDGE_MODE = ACAMERA_EDGE_START,
  ACAMERA_EDGE_AVAILABLE_EDGE_MODES = ACAMERA_EDGE_START + 2,
  ACAMERA_EDGE_END,
  ACAMERA_FLASH_MODE = ACAMERA_FLASH_START + 2,
  ACAMERA_FLASH_STATE = ACAMERA_FLASH_START + 5,
  ACAMERA_FLASH_END,
  ACAMERA_FLASH_INFO_AVAILABLE = ACAMERA_FLASH_INFO_START,
  ACAMERA_FLASH_INFO_STRENGTH_MAXIMUM_LEVEL = ACAMERA_FLASH_INFO_START + 2,
  ACAMERA_FLASH_INFO_STRENGTH_DEFAULT_LEVEL = ACAMERA_FLASH_INFO_START + 3,
  ACAMERA_FLASH_INFO_END,
  ACAMERA_HOT_PIXEL_MODE = ACAMERA_HOT_PIXEL_START,
  ACAMERA_HOT_PIXEL_AVAILABLE_HOT_PIXEL_MODES = ACAMERA_HOT_PIXEL_START + 1,
  ACAMERA_HOT_PIXEL_END,
  ACAMERA_JPEG_GPS_COORDINATES = ACAMERA_JPEG_START,
  ACAMERA_JPEG_GPS_PROCESSING_METHOD = ACAMERA_JPEG_START + 1,
  ACAMERA_JPEG_GPS_TIMESTAMP = ACAMERA_JPEG_START + 2,
  ACAMERA_JPEG_ORIENTATION = ACAMERA_JPEG_START + 3,
  ACAMERA_JPEG_QUALITY = ACAMERA_JPEG_START + 4,
  ACAMERA_JPEG_THUMBNAIL_QUALITY = ACAMERA_JPEG_START + 5,
  ACAMERA_JPEG_THUMBNAIL_SIZE = ACAMERA_JPEG_START + 6,
  ACAMERA_JPEG_AVAILABLE_THUMBNAIL_SIZES = ACAMERA_JPEG_START + 7,
  ACAMERA_JPEG_END,
  ACAMERA_LENS_APERTURE = ACAMERA_LENS_START,
  ACAMERA_LENS_FILTER_DENSITY = ACAMERA_LENS_START + 1,
  ACAMERA_LENS_FOCAL_LENGTH = ACAMERA_LENS_START + 2,
  ACAMERA_LENS_FOCUS_DISTANCE = ACAMERA_LENS_START + 3,
  ACAMERA_LENS_OPTICAL_STABILIZATION_MODE = ACAMERA_LENS_START + 4,
  ACAMERA_LENS_FACING = ACAMERA_LENS_START + 5,
  ACAMERA_LENS_POSE_ROTATION = ACAMERA_LENS_START + 6,
  ACAMERA_LENS_POSE_TRANSLATION = ACAMERA_LENS_START + 7,
  ACAMERA_LENS_FOCUS_RANGE = ACAMERA_LENS_START + 8,
  ACAMERA_LENS_STATE = ACAMERA_LENS_START + 9,
  ACAMERA_LENS_INTRINSIC_CALIBRATION = ACAMERA_LENS_START + 10,
  ACAMERA_LENS_RADIAL_DISTORTION = ACAMERA_LENS_START + 11,
  ACAMERA_LENS_POSE_REFERENCE = ACAMERA_LENS_START + 12,
  ACAMERA_LENS_DISTORTION = ACAMERA_LENS_START + 13,
  ACAMERA_LENS_DISTORTION_MAXIMUM_RESOLUTION = ACAMERA_LENS_START + 14,
  ACAMERA_LENS_INTRINSIC_CALIBRATION_MAXIMUM_RESOLUTION = ACAMERA_LENS_START + 15,
  ACAMERA_LENS_END,
  ACAMERA_LENS_INFO_AVAILABLE_APERTURES = ACAMERA_LENS_INFO_START,
  ACAMERA_LENS_INFO_AVAILABLE_FILTER_DENSITIES = ACAMERA_LENS_INFO_START + 1,
  ACAMERA_LENS_INFO_AVAILABLE_FOCAL_LENGTHS = ACAMERA_LENS_INFO_START + 2,
  ACAMERA_LENS_INFO_AVAILABLE_OPTICAL_STABILIZATION = ACAMERA_LENS_INFO_START + 3,
  ACAMERA_LENS_INFO_HYPERFOCAL_DISTANCE = ACAMERA_LENS_INFO_START + 4,
  ACAMERA_LENS_INFO_MINIMUM_FOCUS_DISTANCE = ACAMERA_LENS_INFO_START + 5,
  ACAMERA_LENS_INFO_SHADING_MAP_SIZE = ACAMERA_LENS_INFO_START + 6,
  ACAMERA_LENS_INFO_FOCUS_DISTANCE_CALIBRATION = ACAMERA_LENS_INFO_START + 7,
  ACAMERA_LENS_INFO_END,
  ACAMERA_NOISE_REDUCTION_MODE = ACAMERA_NOISE_REDUCTION_START,
  ACAMERA_NOISE_REDUCTION_AVAILABLE_NOISE_REDUCTION_MODES = ACAMERA_NOISE_REDUCTION_START + 2,
  ACAMERA_NOISE_REDUCTION_END,
  ACAMERA_REQUEST_MAX_NUM_OUTPUT_STREAMS = ACAMERA_REQUEST_START + 6,
  ACAMERA_REQUEST_PIPELINE_DEPTH = ACAMERA_REQUEST_START + 9,
  ACAMERA_REQUEST_PIPELINE_MAX_DEPTH = ACAMERA_REQUEST_START + 10,
  ACAMERA_REQUEST_PARTIAL_RESULT_COUNT = ACAMERA_REQUEST_START + 11,
  ACAMERA_REQUEST_AVAILABLE_CAPABILITIES = ACAMERA_REQUEST_START + 12,
  ACAMERA_REQUEST_AVAILABLE_REQUEST_KEYS = ACAMERA_REQUEST_START + 13,
  ACAMERA_REQUEST_AVAILABLE_RESULT_KEYS = ACAMERA_REQUEST_START + 14,
  ACAMERA_REQUEST_AVAILABLE_CHARACTERISTICS_KEYS = ACAMERA_REQUEST_START + 15,
  ACAMERA_REQUEST_AVAILABLE_SESSION_KEYS = ACAMERA_REQUEST_START + 16,
  ACAMERA_REQUEST_AVAILABLE_PHYSICAL_CAMERA_REQUEST_KEYS = ACAMERA_REQUEST_START + 17,
  ACAMERA_REQUEST_AVAILABLE_DYNAMIC_RANGE_PROFILES_MAP = ACAMERA_REQUEST_START + 19,
  ACAMERA_REQUEST_END,
  ACAMERA_SCALER_CROP_REGION = ACAMERA_SCALER_START,
  ACAMERA_SCALER_AVAILABLE_MAX_DIGITAL_ZOOM = ACAMERA_SCALER_START + 4,
  ACAMERA_SCALER_AVAILABLE_STREAM_CONFIGURATIONS = ACAMERA_SCALER_START + 10,
  ACAMERA_SCALER_AVAILABLE_MIN_FRAME_DURATIONS = ACAMERA_SCALER_START + 11,
  ACAMERA_SCALER_AVAILABLE_STALL_DURATIONS = ACAMERA_SCALER_START + 12,
  ACAMERA_SCALER_CROPPING_TYPE = ACAMERA_SCALER_START + 13,
  ACAMERA_SCALER_AVAILABLE_RECOMMENDED_STREAM_CONFIGURATIONS = ACAMERA_SCALER_START + 14,
  ACAMERA_SCALER_AVAILABLE_RECOMMENDED_INPUT_OUTPUT_FORMATS_MAP = ACAMERA_SCALER_START + 15,
  ACAMERA_SCALER_AVAILABLE_ROTATE_AND_CROP_MODES = ACAMERA_SCALER_START + 16,
  ACAMERA_SCALER_ROTATE_AND_CROP = ACAMERA_SCALER_START + 17,
  ACAMERA_SCALER_DEFAULT_SECURE_IMAGE_SIZE = ACAMERA_SCALER_START + 18,
  ACAMERA_SCALER_PHYSICAL_CAMERA_MULTI_RESOLUTION_STREAM_CONFIGURATIONS = ACAMERA_SCALER_START + 19,
  ACAMERA_SCALER_AVAILABLE_STREAM_CONFIGURATIONS_MAXIMUM_RESOLUTION = ACAMERA_SCALER_START + 20,
  ACAMERA_SCALER_AVAILABLE_MIN_FRAME_DURATIONS_MAXIMUM_RESOLUTION = ACAMERA_SCALER_START + 21,
  ACAMERA_SCALER_AVAILABLE_STALL_DURATIONS_MAXIMUM_RESOLUTION = ACAMERA_SCALER_START + 22,
  ACAMERA_SCALER_MULTI_RESOLUTION_STREAM_SUPPORTED = ACAMERA_SCALER_START + 24,
  ACAMERA_SCALER_AVAILABLE_STREAM_USE_CASES = ACAMERA_SCALER_START + 25,
  ACAMERA_SCALER_END,
  ACAMERA_SENSOR_EXPOSURE_TIME = ACAMERA_SENSOR_START,
  ACAMERA_SENSOR_FRAME_DURATION = ACAMERA_SENSOR_START + 1,
  ACAMERA_SENSOR_SENSITIVITY = ACAMERA_SENSOR_START + 2,
  ACAMERA_SENSOR_REFERENCE_ILLUMINANT1 = ACAMERA_SENSOR_START + 3,
  ACAMERA_SENSOR_REFERENCE_ILLUMINANT2 = ACAMERA_SENSOR_START + 4,
  ACAMERA_SENSOR_CALIBRATION_TRANSFORM1 = ACAMERA_SENSOR_START + 5,
  ACAMERA_SENSOR_CALIBRATION_TRANSFORM2 = ACAMERA_SENSOR_START + 6,
  ACAMERA_SENSOR_COLOR_TRANSFORM1 = ACAMERA_SENSOR_START + 7,
  ACAMERA_SENSOR_COLOR_TRANSFORM2 = ACAMERA_SENSOR_START + 8,
  ACAMERA_SENSOR_FORWARD_MATRIX1 = ACAMERA_SENSOR_START + 9,
  ACAMERA_SENSOR_FORWARD_MATRIX2 = ACAMERA_SENSOR_START + 10,
  ACAMERA_SENSOR_BLACK_LEVEL_PATTERN = ACAMERA_SENSOR_START + 12,
  ACAMERA_SENSOR_MAX_ANALOG_SENSITIVITY = ACAMERA_SENSOR_START + 13,
  ACAMERA_SENSOR_ORIENTATION = ACAMERA_SENSOR_START + 14,
  ACAMERA_SENSOR_TIMESTAMP = ACAMERA_SENSOR_START + 16,
  ACAMERA_SENSOR_NEUTRAL_COLOR_POINT = ACAMERA_SENSOR_START + 18,
  ACAMERA_SENSOR_NOISE_PROFILE = ACAMERA_SENSOR_START + 19,
  ACAMERA_SENSOR_GREEN_SPLIT = ACAMERA_SENSOR_START + 22,
  ACAMERA_SENSOR_TEST_PATTERN_DATA = ACAMERA_SENSOR_START + 23,
  ACAMERA_SENSOR_TEST_PATTERN_MODE = ACAMERA_SENSOR_START + 24,
  ACAMERA_SENSOR_AVAILABLE_TEST_PATTERN_MODES = ACAMERA_SENSOR_START + 25,
  ACAMERA_SENSOR_ROLLING_SHUTTER_SKEW = ACAMERA_SENSOR_START + 26,
  ACAMERA_SENSOR_OPTICAL_BLACK_REGIONS = ACAMERA_SENSOR_START + 27,
  ACAMERA_SENSOR_DYNAMIC_BLACK_LEVEL = ACAMERA_SENSOR_START + 28,
  ACAMERA_SENSOR_DYNAMIC_WHITE_LEVEL = ACAMERA_SENSOR_START + 29,
  ACAMERA_SENSOR_PIXEL_MODE = ACAMERA_SENSOR_START + 32,
  ACAMERA_SENSOR_RAW_BINNING_FACTOR_USED = ACAMERA_SENSOR_START + 33,
  ACAMERA_SENSOR_END,
  ACAMERA_SENSOR_INFO_ACTIVE_ARRAY_SIZE = ACAMERA_SENSOR_INFO_START,
  ACAMERA_SENSOR_INFO_SENSITIVITY_RANGE = ACAMERA_SENSOR_INFO_START + 1,
  ACAMERA_SENSOR_INFO_COLOR_FILTER_ARRANGEMENT = ACAMERA_SENSOR_INFO_START + 2,
  ACAMERA_SENSOR_INFO_EXPOSURE_TIME_RANGE = ACAMERA_SENSOR_INFO_START + 3,
  ACAMERA_SENSOR_INFO_MAX_FRAME_DURATION = ACAMERA_SENSOR_INFO_START + 4,
  ACAMERA_SENSOR_INFO_PHYSICAL_SIZE = ACAMERA_SENSOR_INFO_START + 5,
  ACAMERA_SENSOR_INFO_PIXEL_ARRAY_SIZE = ACAMERA_SENSOR_INFO_START + 6,
  ACAMERA_SENSOR_INFO_WHITE_LEVEL = ACAMERA_SENSOR_INFO_START + 7,
  ACAMERA_SENSOR_INFO_TIMESTAMP_SOURCE = ACAMERA_SENSOR_INFO_START + 8,
  ACAMERA_SENSOR_INFO_LENS_SHADING_APPLIED = ACAMERA_SENSOR_INFO_START + 9,
  ACAMERA_SENSOR_INFO_PRE_CORRECTION_ACTIVE_ARRAY_SIZE = ACAMERA_SENSOR_INFO_START + 10,
  ACAMERA_SENSOR_INFO_ACTIVE_ARRAY_SIZE_MAXIMUM_RESOLUTION = ACAMERA_SENSOR_INFO_START + 11,
  ACAMERA_SENSOR_INFO_PIXEL_ARRAY_SIZE_MAXIMUM_RESOLUTION = ACAMERA_SENSOR_INFO_START + 12,
  ACAMERA_SENSOR_INFO_PRE_CORRECTION_ACTIVE_ARRAY_SIZE_MAXIMUM_RESOLUTION = ACAMERA_SENSOR_INFO_START + 13,
  ACAMERA_SENSOR_INFO_BINNING_FACTOR = ACAMERA_SENSOR_INFO_START + 14,
  ACAMERA_SENSOR_INFO_END,
  ACAMERA_SHADING_MODE = ACAMERA_SHADING_START,
  ACAMERA_SHADING_AVAILABLE_MODES = ACAMERA_SHADING_START + 2,
  ACAMERA_SHADING_END,
  ACAMERA_STATISTICS_FACE_DETECT_MODE = ACAMERA_STATISTICS_START,
  ACAMERA_STATISTICS_HOT_PIXEL_MAP_MODE = ACAMERA_STATISTICS_START + 3,
  ACAMERA_STATISTICS_FACE_IDS = ACAMERA_STATISTICS_START + 4,
  ACAMERA_STATISTICS_FACE_LANDMARKS = ACAMERA_STATISTICS_START + 5,
  ACAMERA_STATISTICS_FACE_RECTANGLES = ACAMERA_STATISTICS_START + 6,
  ACAMERA_STATISTICS_FACE_SCORES = ACAMERA_STATISTICS_START + 7,
  ACAMERA_STATISTICS_LENS_SHADING_MAP = ACAMERA_STATISTICS_START + 11,
  ACAMERA_STATISTICS_SCENE_FLICKER = ACAMERA_STATISTICS_START + 14,
  ACAMERA_STATISTICS_HOT_PIXEL_MAP = ACAMERA_STATISTICS_START + 15,
  ACAMERA_STATISTICS_LENS_SHADING_MAP_MODE = ACAMERA_STATISTICS_START + 16,
  ACAMERA_STATISTICS_OIS_DATA_MODE = ACAMERA_STATISTICS_START + 17,
  ACAMERA_STATISTICS_OIS_TIMESTAMPS = ACAMERA_STATISTICS_START + 18,
  ACAMERA_STATISTICS_OIS_X_SHIFTS = ACAMERA_STATISTICS_START + 19,
  ACAMERA_STATISTICS_OIS_Y_SHIFTS = ACAMERA_STATISTICS_START + 20,
  ACAMERA_STATISTICS_END,
  ACAMERA_STATISTICS_INFO_AVAILABLE_FACE_DETECT_MODES = ACAMERA_STATISTICS_INFO_START,
  ACAMERA_STATISTICS_INFO_MAX_FACE_COUNT = ACAMERA_STATISTICS_INFO_START + 2,
  ACAMERA_STATISTICS_INFO_AVAILABLE_HOT_PIXEL_MAP_MODES = ACAMERA_STATISTICS_INFO_START + 6,
  ACAMERA_STATISTICS_INFO_AVAILABLE_LENS_SHADING_MAP_MODES = ACAMERA_STATISTICS_INFO_START + 7,
  ACAMERA_STATISTICS_INFO_AVAILABLE_OIS_DATA_MODES = ACAMERA_STATISTICS_INFO_START + 8,
  ACAMERA_STATISTICS_INFO_END,
  ACAMERA_TONEMAP_CURVE_BLUE = ACAMERA_TONEMAP_START,
  ACAMERA_TONEMAP_CURVE_GREEN = ACAMERA_TONEMAP_START + 1,
  ACAMERA_TONEMAP_CURVE_RED = ACAMERA_TONEMAP_START + 2,
  ACAMERA_TONEMAP_MODE = ACAMERA_TONEMAP_START + 3,
  ACAMERA_TONEMAP_MAX_CURVE_POINTS = ACAMERA_TONEMAP_START + 4,
  ACAMERA_TONEMAP_AVAILABLE_TONE_MAP_MODES = ACAMERA_TONEMAP_START + 5,
  ACAMERA_TONEMAP_GAMMA = ACAMERA_TONEMAP_START + 6,
  ACAMERA_TONEMAP_PRESET_CURVE = ACAMERA_TONEMAP_START + 7,
  ACAMERA_TONEMAP_END,
  ACAMERA_INFO_SUPPORTED_HARDWARE_LEVEL = ACAMERA_INFO_START,
  ACAMERA_INFO_VERSION = ACAMERA_INFO_START + 1,
  ACAMERA_INFO_DEVICE_STATE_ORIENTATIONS = ACAMERA_INFO_START + 3,
  ACAMERA_INFO_END,
  ACAMERA_BLACK_LEVEL_LOCK = ACAMERA_BLACK_LEVEL_START,
  ACAMERA_BLACK_LEVEL_END,
  ACAMERA_SYNC_FRAME_NUMBER = ACAMERA_SYNC_START,
  ACAMERA_SYNC_MAX_LATENCY = ACAMERA_SYNC_START + 1,
  ACAMERA_SYNC_END,
  ACAMERA_DEPTH_AVAILABLE_DEPTH_STREAM_CONFIGURATIONS = ACAMERA_DEPTH_START + 1,
  ACAMERA_DEPTH_AVAILABLE_DEPTH_MIN_FRAME_DURATIONS = ACAMERA_DEPTH_START + 2,
  ACAMERA_DEPTH_AVAILABLE_DEPTH_STALL_DURATIONS = ACAMERA_DEPTH_START + 3,
  ACAMERA_DEPTH_DEPTH_IS_EXCLUSIVE = ACAMERA_DEPTH_START + 4,
  ACAMERA_DEPTH_AVAILABLE_RECOMMENDED_DEPTH_STREAM_CONFIGURATIONS = ACAMERA_DEPTH_START + 5,
  ACAMERA_DEPTH_AVAILABLE_DYNAMIC_DEPTH_STREAM_CONFIGURATIONS = ACAMERA_DEPTH_START + 6,
  ACAMERA_DEPTH_AVAILABLE_DYNAMIC_DEPTH_MIN_FRAME_DURATIONS = ACAMERA_DEPTH_START + 7,
  ACAMERA_DEPTH_AVAILABLE_DYNAMIC_DEPTH_STALL_DURATIONS = ACAMERA_DEPTH_START + 8,
  ACAMERA_DEPTH_AVAILABLE_DEPTH_STREAM_CONFIGURATIONS_MAXIMUM_RESOLUTION = ACAMERA_DEPTH_START + 9,
  ACAMERA_DEPTH_AVAILABLE_DEPTH_MIN_FRAME_DURATIONS_MAXIMUM_RESOLUTION = ACAMERA_DEPTH_START + 10,
  ACAMERA_DEPTH_AVAILABLE_DEPTH_STALL_DURATIONS_MAXIMUM_RESOLUTION = ACAMERA_DEPTH_START + 11,
  ACAMERA_DEPTH_AVAILABLE_DYNAMIC_DEPTH_STREAM_CONFIGURATIONS_MAXIMUM_RESOLUTION = ACAMERA_DEPTH_START + 12,
  ACAMERA_DEPTH_AVAILABLE_DYNAMIC_DEPTH_MIN_FRAME_DURATIONS_MAXIMUM_RESOLUTION = ACAMERA_DEPTH_START + 13,
  ACAMERA_DEPTH_AVAILABLE_DYNAMIC_DEPTH_STALL_DURATIONS_MAXIMUM_RESOLUTION = ACAMERA_DEPTH_START + 14,
  ACAMERA_DEPTH_END,
  ACAMERA_LOGICAL_MULTI_CAMERA_PHYSICAL_IDS = ACAMERA_LOGICAL_MULTI_CAMERA_START,
  ACAMERA_LOGICAL_MULTI_CAMERA_SENSOR_SYNC_TYPE = ACAMERA_LOGICAL_MULTI_CAMERA_START + 1,
  ACAMERA_LOGICAL_MULTI_CAMERA_ACTIVE_PHYSICAL_ID = ACAMERA_LOGICAL_MULTI_CAMERA_START + 2,
  ACAMERA_LOGICAL_MULTI_CAMERA_END,
  ACAMERA_DISTORTION_CORRECTION_MODE = ACAMERA_DISTORTION_CORRECTION_START,
  ACAMERA_DISTORTION_CORRECTION_AVAILABLE_MODES = ACAMERA_DISTORTION_CORRECTION_START + 1,
  ACAMERA_DISTORTION_CORRECTION_END,
  ACAMERA_HEIC_AVAILABLE_HEIC_STREAM_CONFIGURATIONS = ACAMERA_HEIC_START,
  ACAMERA_HEIC_AVAILABLE_HEIC_MIN_FRAME_DURATIONS = ACAMERA_HEIC_START + 1,
  ACAMERA_HEIC_AVAILABLE_HEIC_STALL_DURATIONS = ACAMERA_HEIC_START + 2,
  ACAMERA_HEIC_AVAILABLE_HEIC_STREAM_CONFIGURATIONS_MAXIMUM_RESOLUTION = ACAMERA_HEIC_START + 3,
  ACAMERA_HEIC_AVAILABLE_HEIC_MIN_FRAME_DURATIONS_MAXIMUM_RESOLUTION = ACAMERA_HEIC_START + 4,
  ACAMERA_HEIC_AVAILABLE_HEIC_STALL_DURATIONS_MAXIMUM_RESOLUTION = ACAMERA_HEIC_START + 5,
  ACAMERA_HEIC_END,
  ACAMERA_AUTOMOTIVE_LOCATION = ACAMERA_AUTOMOTIVE_START,
  ACAMERA_AUTOMOTIVE_END,
  ACAMERA_AUTOMOTIVE_LENS_FACING = ACAMERA_AUTOMOTIVE_LENS_START,
  ACAMERA_AUTOMOTIVE_LENS_END
}	enum
Main enum for camera metadata tags.
camera_status_t{
  ACAMERA_OK = 0,
  ACAMERA_ERROR_BASE = -10000,
  ACAMERA_ERROR_UNKNOWN = ACAMERA_ERROR_BASE,
  ACAMERA_ERROR_INVALID_PARAMETER = ACAMERA_ERROR_BASE - 1,
  ACAMERA_ERROR_CAMERA_DISCONNECTED = ACAMERA_ERROR_BASE - 2,
  ACAMERA_ERROR_NOT_ENOUGH_MEMORY = ACAMERA_ERROR_BASE - 3,
  ACAMERA_ERROR_METADATA_NOT_FOUND = ACAMERA_ERROR_BASE - 4,
  ACAMERA_ERROR_CAMERA_DEVICE = ACAMERA_ERROR_BASE - 5,
  ACAMERA_ERROR_CAMERA_SERVICE = ACAMERA_ERROR_BASE - 6,
  ACAMERA_ERROR_SESSION_CLOSED = ACAMERA_ERROR_BASE - 7,
  ACAMERA_ERROR_INVALID_OPERATION = ACAMERA_ERROR_BASE - 8,
  ACAMERA_ERROR_STREAM_CONFIGURE_FAIL = ACAMERA_ERROR_BASE - 9,
  ACAMERA_ERROR_CAMERA_IN_USE = ACAMERA_ERROR_BASE - 10,
  ACAMERA_ERROR_MAX_CAMERA_IN_USE = ACAMERA_ERROR_BASE - 11,
  ACAMERA_ERROR_CAMERA_DISABLED = ACAMERA_ERROR_BASE - 12,
  ACAMERA_ERROR_PERMISSION_DENIED = ACAMERA_ERROR_BASE - 13,
  ACAMERA_ERROR_UNSUPPORTED_OPERATION = ACAMERA_ERROR_BASE - 14
}	enum
Camera status enum types.
Typedefs
ACameraCaptureFailure	typedef
struct ACameraCaptureFailure
Struct to describe a capture failure.
ACameraCaptureSession	typedef
struct ACameraCaptureSession
ACameraCaptureSession is an opaque type that manages frame captures of a camera device.
ACameraCaptureSession_captureCallback_bufferLost)(void *context, ACameraCaptureSession *session, ACaptureRequest *request, ACameraWindowType *window, int64_t frameNumber)	typedef
void(*
The definition of camera buffer lost callback.
ACameraCaptureSession_captureCallback_failed)(void *context, ACameraCaptureSession *session, ACaptureRequest *request, ACameraCaptureFailure *failure)	typedef
void(*
The definition of camera capture failure callback.
ACameraCaptureSession_captureCallback_result)(void *context, ACameraCaptureSession *session, ACaptureRequest *request, const ACameraMetadata *result)	typedef
void(*
The definition of camera capture progress/result callback.
ACameraCaptureSession_captureCallback_sequenceAbort)(void *context, ACameraCaptureSession *session, int sequenceId)	typedef
void(*
The definition of camera sequence aborted callback.
ACameraCaptureSession_captureCallback_sequenceEnd)(void *context, ACameraCaptureSession *session, int sequenceId, int64_t frameNumber)	typedef
void(*
The definition of camera sequence end callback.
ACameraCaptureSession_captureCallback_start)(void *context, ACameraCaptureSession *session, const ACaptureRequest *request, int64_t timestamp)	typedef
void(*
The definition of camera capture start callback.
ACameraCaptureSession_captureCallback_startV2)(void *context, ACameraCaptureSession *session, const ACaptureRequest *request, int64_t timestamp, int64_t frameNumber)	typedef
void(*
The definition of camera capture start callback.
ACameraCaptureSession_captureCallbacks	typedef
struct ACameraCaptureSession_captureCallbacks
ACaptureCaptureSession_captureCallbacks structure used in ACameraCaptureSession_capture and ACameraCaptureSession_setRepeatingRequest.
ACameraCaptureSession_captureCallbacksV2	typedef
struct ACameraCaptureSession_captureCallbacksV2
This has the same functionality as ACameraCaptureSession_captureCallbacks, with the exception that captureCallback_startV2 callback is used, instead of captureCallback_start, to support retrieving the frame number.
ACameraCaptureSession_logicalCamera_captureCallback_failed)(void *context, ACameraCaptureSession *session, ACaptureRequest *request, ALogicalCameraCaptureFailure *failure)	typedef
void(*
The definition of logical camera capture failure callback.
ACameraCaptureSession_logicalCamera_captureCallback_result)(void *context, ACameraCaptureSession *session, ACaptureRequest *request, const ACameraMetadata *result, size_t physicalResultCount, const char **physicalCameraIds, const ACameraMetadata **physicalResults)	typedef
void(*
The definition of final capture result callback with logical multi-camera support.
ACameraCaptureSession_logicalCamera_captureCallbacks	typedef
struct ACameraCaptureSession_logicalCamera_captureCallbacks
This has the same functionality as ACameraCaptureSession_captureCallbacks, with the exception that an onLogicalCameraCaptureCompleted callback is used, instead of onCaptureCompleted, to support logical multi-camera.
ACameraCaptureSession_logicalCamera_captureCallbacksV2	typedef
struct ACameraCaptureSession_logicalCamera_captureCallbacksV2
This has the same functionality as ACameraCaptureSession_logicalCamera_captureCallbacks, with the exception that an captureCallback_startV2 callback is used, instead of captureCallback_start, to support retrieving frame number.
ACameraCaptureSession_stateCallback)(void *context, ACameraCaptureSession *session)	typedef
void(*
The definition of camera capture session state callback.
ACameraCaptureSession_stateCallbacks	typedef
struct ACameraCaptureSession_stateCallbacks
Capture session state callbacks used in ACameraDevice_createCaptureSession and ACameraDevice_createCaptureSessionWithSessionParameters.
ACameraDevice	typedef
struct ACameraDevice
ACameraDevice is opaque type that provides access to a camera device.
ACameraDevice	typedef
struct ACameraDevice
ACameraDevice is opaque type that provides access to a camera device.
ACameraDevice_ErrorStateCallback)(void *context, ACameraDevice *device, int error)	typedef
void(*
Camera device error state callbacks to be used in ACameraDevice_StateCallbacks.
ACameraDevice_StateCallback)(void *context, ACameraDevice *device)	typedef
void(*
Camera device state callbacks to be used in ACameraDevice_StateCallbacks.
ACameraDevice_StateCallbacks	typedef
struct ACameraDevice_StateCallbacks
Applications' callbacks for camera device state changes, register with ACameraManager_openCamera.
ACameraDevice_stateCallbacks	typedef
ACameraDevice_StateCallbacks
For backward compatiblity.
ACameraIdList	typedef
struct ACameraIdList
Struct to hold list of camera device Ids.
ACameraManager	typedef
struct ACameraManager
ACameraManager is opaque type that provides access to camera service.
ACameraManager_AccessPrioritiesChangedCallback)(void *context)	typedef
void(*
Definition of camera access permission change callback.
ACameraManager_AvailabilityCallback)(void *context, const char *cameraId)	typedef
void(*
Definition of camera availability callbacks.
ACameraManager_AvailabilityCallbacks	typedef
struct ACameraManager_AvailabilityListener
A listener for camera devices becoming available or unavailable to open.
ACameraManager_ExtendedAvailabilityCallbacks	typedef
struct ACameraManager_ExtendedAvailabilityListener
A listener for camera devices becoming available/unavailable to open or when the camera access permissions change.
ACameraManager_PhysicalCameraAvailabilityCallback)(void *context, const char *cameraId, const char *physicalCameraId)	typedef
void(*
Definition of physical camera availability callbacks.
ACameraMetadata	typedef
struct ACameraMetadata
ACameraMetadata is opaque type that provides access to read-only camera metadata like camera characteristics (via ACameraManager_getCameraCharacteristics) or capture results (via ACameraCaptureSession_captureCallback_result).
ACameraMetadata_const_entry	typedef
struct ACameraMetadata_const_entry
A single read-only camera metadata entry.
ACameraMetadata_entry	typedef
struct ACameraMetadata_entry
A single camera metadata entry.
ACameraMetadata_rational	typedef
struct ACameraMetadata_rational
Definition of rational data type in ACameraMetadata.
ACameraOutputTarget	typedef
struct ACameraOutputTarget
Container for a single output target.
ACameraOutputTargets	typedef
struct ACameraOutputTargets
Container for output targets.
ACameraWindowType	typedef
ANativeWindow
This file defines the window type used by NDK and the VNDK variants of the camera2 NDK.
ACaptureRequest	typedef
struct ACaptureRequest
ACaptureRequest is an opaque type that contains settings and output targets needed to capture a single image from camera device.
ACaptureSessionOutput	typedef
struct ACaptureSessionOutput
Opaque object for capture session output, use ACaptureSessionOutput_create or ACaptureSessionSharedOutput_create to create an instance.
ACaptureSessionOutputContainer	typedef
struct ACaptureSessionOutputContainer
Opaque object for CaptureSessionOutput container, use ACaptureSessionOutputContainer_create to create an instance.
ALogicalCameraCaptureFailure	typedef
struct ALogicalCameraCaptureFailure
Struct to describe a logical camera capture failure.
acamera_metadata_enum_android_automotive_lens_facing_t	typedef
enum acamera_metadata_enum_acamera_automotive_lens_facing
acamera_metadata_enum_android_automotive_location_t	typedef
enum acamera_metadata_enum_acamera_automotive_location
acamera_metadata_enum_android_black_level_lock_t	typedef
enum acamera_metadata_enum_acamera_black_level_lock
acamera_metadata_enum_android_color_correction_aberration_mode_t	typedef
enum acamera_metadata_enum_acamera_color_correction_aberration_mode
acamera_metadata_enum_android_color_correction_mode_t	typedef
enum acamera_metadata_enum_acamera_color_correction_mode
Enumeration definitions for the various entries that need them.
acamera_metadata_enum_android_control_ae_antibanding_mode_t	typedef
enum acamera_metadata_enum_acamera_control_ae_antibanding_mode
acamera_metadata_enum_android_control_ae_lock_available_t	typedef
enum acamera_metadata_enum_acamera_control_ae_lock_available
acamera_metadata_enum_android_control_ae_lock_t	typedef
enum acamera_metadata_enum_acamera_control_ae_lock
acamera_metadata_enum_android_control_ae_mode_t	typedef
enum acamera_metadata_enum_acamera_control_ae_mode
acamera_metadata_enum_android_control_ae_precapture_trigger_t	typedef
enum acamera_metadata_enum_acamera_control_ae_precapture_trigger
acamera_metadata_enum_android_control_ae_state_t	typedef
enum acamera_metadata_enum_acamera_control_ae_state
acamera_metadata_enum_android_control_af_mode_t	typedef
enum acamera_metadata_enum_acamera_control_af_mode
acamera_metadata_enum_android_control_af_scene_change_t	typedef
enum acamera_metadata_enum_acamera_control_af_scene_change
acamera_metadata_enum_android_control_af_state_t	typedef
enum acamera_metadata_enum_acamera_control_af_state
acamera_metadata_enum_android_control_af_trigger_t	typedef
enum acamera_metadata_enum_acamera_control_af_trigger
acamera_metadata_enum_android_control_awb_lock_available_t	typedef
enum acamera_metadata_enum_acamera_control_awb_lock_available
acamera_metadata_enum_android_control_awb_lock_t	typedef
enum acamera_metadata_enum_acamera_control_awb_lock
acamera_metadata_enum_android_control_awb_mode_t	typedef
enum acamera_metadata_enum_acamera_control_awb_mode
acamera_metadata_enum_android_control_awb_state_t	typedef
enum acamera_metadata_enum_acamera_control_awb_state
acamera_metadata_enum_android_control_capture_intent_t	typedef
enum acamera_metadata_enum_acamera_control_capture_intent
acamera_metadata_enum_android_control_effect_mode_t	typedef
enum acamera_metadata_enum_acamera_control_effect_mode
acamera_metadata_enum_android_control_enable_zsl_t	typedef
enum acamera_metadata_enum_acamera_control_enable_zsl
acamera_metadata_enum_android_control_extended_scene_mode_t	typedef
enum acamera_metadata_enum_acamera_control_extended_scene_mode
acamera_metadata_enum_android_control_mode_t	typedef
enum acamera_metadata_enum_acamera_control_mode
acamera_metadata_enum_android_control_scene_mode_t	typedef
enum acamera_metadata_enum_acamera_control_scene_mode
acamera_metadata_enum_android_control_video_stabilization_mode_t	typedef
enum acamera_metadata_enum_acamera_control_video_stabilization_mode
acamera_metadata_enum_android_depth_available_depth_stream_configurations_maximum_resolution_t	typedef
enum acamera_metadata_enum_acamera_depth_available_depth_stream_configurations_maximum_resolution
acamera_metadata_enum_android_depth_available_depth_stream_configurations_t	typedef
enum acamera_metadata_enum_acamera_depth_available_depth_stream_configurations
acamera_metadata_enum_android_depth_available_dynamic_depth_stream_configurations_maximum_resolution_t	typedef
enum acamera_metadata_enum_acamera_depth_available_dynamic_depth_stream_configurations_maximum_resolution
acamera_metadata_enum_android_depth_available_dynamic_depth_stream_configurations_t	typedef
enum acamera_metadata_enum_acamera_depth_available_dynamic_depth_stream_configurations
acamera_metadata_enum_android_depth_depth_is_exclusive_t	typedef
enum acamera_metadata_enum_acamera_depth_depth_is_exclusive
acamera_metadata_enum_android_distortion_correction_mode_t	typedef
enum acamera_metadata_enum_acamera_distortion_correction_mode
acamera_metadata_enum_android_edge_mode_t	typedef
enum acamera_metadata_enum_acamera_edge_mode
acamera_metadata_enum_android_flash_info_available_t	typedef
enum acamera_metadata_enum_acamera_flash_info_available
acamera_metadata_enum_android_flash_mode_t	typedef
enum acamera_metadata_enum_acamera_flash_mode
acamera_metadata_enum_android_flash_state_t	typedef
enum acamera_metadata_enum_acamera_flash_state
acamera_metadata_enum_android_heic_available_heic_stream_configurations_maximum_resolution_t	typedef
enum acamera_metadata_enum_acamera_heic_available_heic_stream_configurations_maximum_resolution
acamera_metadata_enum_android_heic_available_heic_stream_configurations_t	typedef
enum acamera_metadata_enum_acamera_heic_available_heic_stream_configurations
acamera_metadata_enum_android_hot_pixel_mode_t	typedef
enum acamera_metadata_enum_acamera_hot_pixel_mode
acamera_metadata_enum_android_info_supported_hardware_level_t	typedef
enum acamera_metadata_enum_acamera_info_supported_hardware_level
acamera_metadata_enum_android_lens_facing_t	typedef
enum acamera_metadata_enum_acamera_lens_facing
acamera_metadata_enum_android_lens_info_focus_distance_calibration_t	typedef
enum acamera_metadata_enum_acamera_lens_info_focus_distance_calibration
acamera_metadata_enum_android_lens_optical_stabilization_mode_t	typedef
enum acamera_metadata_enum_acamera_lens_optical_stabilization_mode
acamera_metadata_enum_android_lens_pose_reference_t	typedef
enum acamera_metadata_enum_acamera_lens_pose_reference
acamera_metadata_enum_android_lens_state_t	typedef
enum acamera_metadata_enum_acamera_lens_state
acamera_metadata_enum_android_logical_multi_camera_sensor_sync_type_t	typedef
enum acamera_metadata_enum_acamera_logical_multi_camera_sensor_sync_type
acamera_metadata_enum_android_noise_reduction_mode_t	typedef
enum acamera_metadata_enum_acamera_noise_reduction_mode
acamera_metadata_enum_android_request_available_capabilities_t	typedef
enum acamera_metadata_enum_acamera_request_available_capabilities
acamera_metadata_enum_android_request_available_dynamic_range_profiles_map_t	typedef
enum acamera_metadata_enum_acamera_request_available_dynamic_range_profiles_map
acamera_metadata_enum_android_scaler_available_recommended_stream_configurations_t	typedef
enum acamera_metadata_enum_acamera_scaler_available_recommended_stream_configurations
acamera_metadata_enum_android_scaler_available_stream_configurations_maximum_resolution_t	typedef
enum acamera_metadata_enum_acamera_scaler_available_stream_configurations_maximum_resolution
acamera_metadata_enum_android_scaler_available_stream_configurations_t	typedef
enum acamera_metadata_enum_acamera_scaler_available_stream_configurations
acamera_metadata_enum_android_scaler_available_stream_use_cases_t	typedef
enum acamera_metadata_enum_acamera_scaler_available_stream_use_cases
acamera_metadata_enum_android_scaler_cropping_type_t	typedef
enum acamera_metadata_enum_acamera_scaler_cropping_type
acamera_metadata_enum_android_scaler_multi_resolution_stream_supported_t	typedef
enum acamera_metadata_enum_acamera_scaler_multi_resolution_stream_supported
acamera_metadata_enum_android_scaler_physical_camera_multi_resolution_stream_configurations_t	typedef
enum acamera_metadata_enum_acamera_scaler_physical_camera_multi_resolution_stream_configurations
acamera_metadata_enum_android_scaler_rotate_and_crop_t	typedef
enum acamera_metadata_enum_acamera_scaler_rotate_and_crop
acamera_metadata_enum_android_sensor_info_color_filter_arrangement_t	typedef
enum acamera_metadata_enum_acamera_sensor_info_color_filter_arrangement
acamera_metadata_enum_android_sensor_info_lens_shading_applied_t	typedef
enum acamera_metadata_enum_acamera_sensor_info_lens_shading_applied
acamera_metadata_enum_android_sensor_info_timestamp_source_t	typedef
enum acamera_metadata_enum_acamera_sensor_info_timestamp_source
acamera_metadata_enum_android_sensor_pixel_mode_t	typedef
enum acamera_metadata_enum_acamera_sensor_pixel_mode
acamera_metadata_enum_android_sensor_raw_binning_factor_used_t	typedef
enum acamera_metadata_enum_acamera_sensor_raw_binning_factor_used
acamera_metadata_enum_android_sensor_reference_illuminant1_t	typedef
enum acamera_metadata_enum_acamera_sensor_reference_illuminant1
acamera_metadata_enum_android_sensor_test_pattern_mode_t	typedef
enum acamera_metadata_enum_acamera_sensor_test_pattern_mode
acamera_metadata_enum_android_shading_mode_t	typedef
enum acamera_metadata_enum_acamera_shading_mode
acamera_metadata_enum_android_statistics_face_detect_mode_t	typedef
enum acamera_metadata_enum_acamera_statistics_face_detect_mode
acamera_metadata_enum_android_statistics_hot_pixel_map_mode_t	typedef
enum acamera_metadata_enum_acamera_statistics_hot_pixel_map_mode
acamera_metadata_enum_android_statistics_lens_shading_map_mode_t	typedef
enum acamera_metadata_enum_acamera_statistics_lens_shading_map_mode
acamera_metadata_enum_android_statistics_ois_data_mode_t	typedef
enum acamera_metadata_enum_acamera_statistics_ois_data_mode
acamera_metadata_enum_android_statistics_scene_flicker_t	typedef
enum acamera_metadata_enum_acamera_statistics_scene_flicker
acamera_metadata_enum_android_sync_frame_number_t	typedef
enum acamera_metadata_enum_acamera_sync_frame_number
acamera_metadata_enum_android_sync_max_latency_t	typedef
enum acamera_metadata_enum_acamera_sync_max_latency
acamera_metadata_enum_android_tonemap_mode_t	typedef
enum acamera_metadata_enum_acamera_tonemap_mode
acamera_metadata_enum_android_tonemap_preset_curve_t	typedef
enum acamera_metadata_enum_acamera_tonemap_preset_curve
acamera_metadata_section_start_t	typedef
enum acamera_metadata_section_start
Hierarchy positions in enum space.
acamera_metadata_section_t	typedef
enum acamera_metadata_section
acamera_metadata_tag_t	typedef
enum acamera_metadata_tag
Main enum for camera metadata tags.
Functions
ACameraCaptureSession_abortCaptures(ACameraCaptureSession *session)	
camera_status_t
Discard all captures currently pending and in-progress as fast as possible.
ACameraCaptureSession_capture(ACameraCaptureSession *session, ACameraCaptureSession_captureCallbacks *callbacks, int numRequests, ACaptureRequest **requests, int *captureSequenceId)	
camera_status_t
Submit an array of requests to be captured in sequence as a burst in the minimum of time possible.
ACameraCaptureSession_captureV2(ACameraCaptureSession *session, ACameraCaptureSession_captureCallbacksV2 *callbacks, int numRequests, ACaptureRequest **requests, int *captureSequenceId)	
camera_status_t
This has the same functionality as ACameraCaptureSession_capture, with added support for v2 of camera callbacks, where the onCaptureStarted callback adds frame number in its parameter list.
ACameraCaptureSession_close(ACameraCaptureSession *session)	
void
Close this capture session.
ACameraCaptureSession_getDevice(ACameraCaptureSession *session, ACameraDevice **device)	
camera_status_t
Get the ACameraDevice pointer associated with this capture session in the device argument if the method succeeds.
ACameraCaptureSession_logicalCamera_capture(ACameraCaptureSession *session, ACameraCaptureSession_logicalCamera_captureCallbacks *callbacks, int numRequests, ACaptureRequest **requests, int *captureSequenceId)	
camera_status_t
This has the same functionality as ACameraCaptureSession_capture, with added support for logical multi-camera where the capture callbacks supports result metadata for physical cameras.
ACameraCaptureSession_logicalCamera_captureV2(ACameraCaptureSession *session, ACameraCaptureSession_logicalCamera_captureCallbacksV2 *callbacks, int numRequests, ACaptureRequest **requests, int *captureSequenceId)	
camera_status_t
This has the same functionality as ACameraCaptureSession_logical_capture, with added support for v2 of logical multi-camera callbacks where the onCaptureStarted callback adds frame number in its parameter list.
ACameraCaptureSession_logicalCamera_setRepeatingRequest(ACameraCaptureSession *session, ACameraCaptureSession_logicalCamera_captureCallbacks *callbacks, int numRequests, ACaptureRequest **requests, int *captureSequenceId)	
camera_status_t
This has the same functionality as ACameraCaptureSession_setRepeatingRequest, with added support for logical multi-camera where the capture callbacks supports result metadata for physical cameras.
ACameraCaptureSession_logicalCamera_setRepeatingRequestV2(ACameraCaptureSession *session, ACameraCaptureSession_logicalCamera_captureCallbacksV2 *callbacks, int numRequests, ACaptureRequest **requests, int *captureSequenceId)	
camera_status_t
This has the same functionality as ACameraCaptureSession_logical_setRepeatingRequest, with added support for v2 of logical multi-camera callbacks where the onCaptureStarted callback adds frame number in its parameter list.
ACameraCaptureSession_setRepeatingRequest(ACameraCaptureSession *session, ACameraCaptureSession_captureCallbacks *callbacks, int numRequests, ACaptureRequest **requests, int *captureSequenceId)	
camera_status_t
Request endlessly repeating capture of a sequence of images by this capture session.
ACameraCaptureSession_setRepeatingRequestV2(ACameraCaptureSession *session, ACameraCaptureSession_captureCallbacksV2 *callbacks, int numRequests, ACaptureRequest **requests, int *captureSequenceId)	
camera_status_t
This has the same functionality as ACameraCaptureSession_logical_setRepeatingRequest, with added support for v2 of logical multi-camera callbacks where the onCaptureStarted callback adds frame number in its parameter list.
ACameraCaptureSession_stopRepeating(ACameraCaptureSession *session)	
camera_status_t
Cancel any ongoing repeating capture set by ACameraCaptureSession_setRepeatingRequest.
ACameraCaptureSession_updateSharedOutput(ACameraCaptureSession *session, ACaptureSessionOutput *output)	
camera_status_t
Update shared ACaptureSessionOutput.
ACameraDevice_close(ACameraDevice *device)	
camera_status_t
Close the connection and free this ACameraDevice synchronously.
ACameraDevice_createCaptureRequest(const ACameraDevice *device, ACameraDevice_request_template templateId, ACaptureRequest **request)	
camera_status_t
Create a ACaptureRequest for capturing images, initialized with template for a target use case.
ACameraDevice_createCaptureRequest_withPhysicalIds(const ACameraDevice *device, ACameraDevice_request_template templateId, const ACameraIdList *physicalIdList, ACaptureRequest **request)	
camera_status_t
Create a logical multi-camera ACaptureRequest for capturing images, initialized with template for a target use case, with the ability to specify physical camera settings.
ACameraDevice_createCaptureSession(ACameraDevice *device, const ACaptureSessionOutputContainer *outputs, const ACameraCaptureSession_stateCallbacks *callbacks, ACameraCaptureSession **session)	
camera_status_t
Create a new camera capture session by providing the target output set of ANativeWindow to the camera device.
ACameraDevice_createCaptureSessionWithSessionParameters(ACameraDevice *device, const ACaptureSessionOutputContainer *outputs, const ACaptureRequest *sessionParameters, const ACameraCaptureSession_stateCallbacks *callbacks, ACameraCaptureSession **session)	
camera_status_t
Create a new camera capture session similar to ACameraDevice_createCaptureSession.
ACameraDevice_getId(const ACameraDevice *device)	
const char *
Return the camera id associated with this camera device.
ACameraDevice_isSessionConfigurationSupported(const ACameraDevice *device, const ACaptureSessionOutputContainer *sessionOutputContainer)	
camera_status_t
Check whether a particular ACaptureSessionOutputContainer is supported by the camera device.
ACameraManager_create()	
ACameraManager *
Create ACameraManager instance.
ACameraManager_delete(ACameraManager *manager)	
void
ACameraManager_deleteCameraIdList(ACameraIdList *cameraIdList)	
void
Delete a list of camera devices allocated via ACameraManager_getCameraIdList.
ACameraManager_getCameraCharacteristics(ACameraManager *manager, const char *cameraId, ACameraMetadata **characteristics)	
camera_status_t
Query the capabilities of a camera device.
ACameraManager_getCameraIdList(ACameraManager *manager, ACameraIdList **cameraIdList)	
camera_status_t
Create a list of currently connected camera devices, including cameras that may be in use by other camera API clients.
ACameraManager_openCamera(ACameraManager *manager, const char *cameraId, ACameraDevice_StateCallbacks *callback, ACameraDevice **device)	
camera_status_t
Open a connection to a camera with the given ID.
ACameraManager_registerAvailabilityCallback(ACameraManager *manager, const ACameraManager_AvailabilityCallbacks *callback)	
camera_status_t
Register camera availability callbacks.
ACameraManager_registerExtendedAvailabilityCallback(ACameraManager *manager, const ACameraManager_ExtendedAvailabilityCallbacks *callback)	
camera_status_t
Register camera extended availability callbacks.
ACameraManager_unregisterAvailabilityCallback(ACameraManager *manager, const ACameraManager_AvailabilityCallbacks *callback)	
camera_status_t
Unregister camera availability callbacks.
ACameraManager_unregisterExtendedAvailabilityCallback(ACameraManager *manager, const ACameraManager_ExtendedAvailabilityCallbacks *callback)	
camera_status_t
Unregister camera extended availability callbacks.
ACameraMetadata_copy(const ACameraMetadata *src)	
ACameraMetadata *
Create a copy of input ACameraMetadata.
ACameraMetadata_free(ACameraMetadata *metadata)	
void
Free a ACameraMetadata structure.
ACameraMetadata_fromCameraMetadata(JNIEnv *env, jobject cameraMetadata)	
ACameraMetadata *
Return a ACameraMetadata that references the same data as android.hardware.camera2.CameraMetadata from Java API.
ACameraMetadata_getAllTags(const ACameraMetadata *metadata, int32_t *numEntries, const uint32_t **tags)	
camera_status_t
List all the entry tags in input ACameraMetadata.
ACameraMetadata_getConstEntry(const ACameraMetadata *metadata, uint32_t tag, ACameraMetadata_const_entry *entry)	
camera_status_t
Get a metadata entry from an input ACameraMetadata.
ACameraMetadata_isLogicalMultiCamera(const ACameraMetadata *staticMetadata, size_t *numPhysicalCameras, const char *const **physicalCameraIds)	
bool
Helper function to check if a camera is logical multi-camera.
ACameraOutputTarget_create(ACameraWindowType *window, ACameraOutputTarget **output)	
camera_status_t
Create a ACameraOutputTarget object.
ACameraOutputTarget_free(ACameraOutputTarget *output)	
void
Free a ACameraOutputTarget object.
ACaptureRequest_addTarget(ACaptureRequest *request, const ACameraOutputTarget *output)	
camera_status_t
Add an ACameraOutputTarget object to ACaptureRequest.
ACaptureRequest_copy(const ACaptureRequest *src)	
ACaptureRequest *
Create a copy of input ACaptureRequest.
ACaptureRequest_free(ACaptureRequest *request)	
void
Free a ACaptureRequest structure.
ACaptureRequest_getAllTags(const ACaptureRequest *request, int32_t *numTags, const uint32_t **tags)	
camera_status_t
ACaptureRequest_getConstEntry(const ACaptureRequest *request, uint32_t tag, ACameraMetadata_const_entry *entry)	
camera_status_t
Get a metadata entry from input ACaptureRequest.
ACaptureRequest_getConstEntry_physicalCamera(const ACaptureRequest *request, const char *physicalId, uint32_t tag, ACameraMetadata_const_entry *entry)	
camera_status_t
Get a metadata entry from input ACaptureRequest for a physical camera backing a logical multi-camera device.
ACaptureRequest_getUserContext(const ACaptureRequest *request, void **context)	
camera_status_t
Get the user context pointer of the ACaptureRequest.
ACaptureRequest_removeTarget(ACaptureRequest *request, const ACameraOutputTarget *output)	
camera_status_t
Remove an ACameraOutputTarget object from ACaptureRequest.
ACaptureRequest_setEntry_double(ACaptureRequest *request, uint32_t tag, uint32_t count, const double *data)	
camera_status_t
Set/change a camera capture control entry with double data type.
ACaptureRequest_setEntry_float(ACaptureRequest *request, uint32_t tag, uint32_t count, const float *data)	
camera_status_t
Set/change a camera capture control entry with float data type.
ACaptureRequest_setEntry_i32(ACaptureRequest *request, uint32_t tag, uint32_t count, const int32_t *data)	
camera_status_t
Set/change a camera capture control entry with signed 32 bits data type.
ACaptureRequest_setEntry_i64(ACaptureRequest *request, uint32_t tag, uint32_t count, const int64_t *data)	
camera_status_t
Set/change a camera capture control entry with signed 64 bits data type.
ACaptureRequest_setEntry_physicalCamera_double(ACaptureRequest *request, const char *physicalId, uint32_t tag, uint32_t count, const double *data)	
camera_status_t
Set/change a camera capture control entry with double data type for a physical camera of a logical multi-camera device.
ACaptureRequest_setEntry_physicalCamera_float(ACaptureRequest *request, const char *physicalId, uint32_t tag, uint32_t count, const float *data)	
camera_status_t
Set/change a camera capture control entry with float data type for a physical camera of a logical multi-camera device.
ACaptureRequest_setEntry_physicalCamera_i32(ACaptureRequest *request, const char *physicalId, uint32_t tag, uint32_t count, const int32_t *data)	
camera_status_t
Set/change a camera capture control entry with signed 32 bits data type for a physical camera of a logical multi-camera device.
ACaptureRequest_setEntry_physicalCamera_i64(ACaptureRequest *request, const char *physicalId, uint32_t tag, uint32_t count, const int64_t *data)	
camera_status_t
Set/change a camera capture control entry with signed 64 bits data type for a physical camera of a logical multi-camera device.
ACaptureRequest_setEntry_physicalCamera_rational(ACaptureRequest *request, const char *physicalId, uint32_t tag, uint32_t count, const ACameraMetadata_rational *data)	
camera_status_t
Set/change a camera capture control entry with rational data type for a physical camera of a logical multi-camera device.
ACaptureRequest_setEntry_physicalCamera_u8(ACaptureRequest *request, const char *physicalId, uint32_t tag, uint32_t count, const uint8_t *data)	
camera_status_t
Set/change a camera capture control entry with unsigned 8 bits data type for a physical camera backing a logical multi-camera device.
ACaptureRequest_setEntry_rational(ACaptureRequest *request, uint32_t tag, uint32_t count, const ACameraMetadata_rational *data)	
camera_status_t
Set/change a camera capture control entry with rational data type.
ACaptureRequest_setEntry_u8(ACaptureRequest *request, uint32_t tag, uint32_t count, const uint8_t *data)	
camera_status_t
Set/change a camera capture control entry with unsigned 8 bits data type.
ACaptureRequest_setUserContext(ACaptureRequest *request, void *context)	
camera_status_t
Associate an arbitrary user context pointer to the ACaptureRequest.
ACaptureSessionOutputContainer_add(ACaptureSessionOutputContainer *container, const ACaptureSessionOutput *output)	
camera_status_t
Add an ACaptureSessionOutput object to ACaptureSessionOutputContainer.
ACaptureSessionOutputContainer_create(ACaptureSessionOutputContainer **container)	
camera_status_t
Create a capture session output container.
ACaptureSessionOutputContainer_free(ACaptureSessionOutputContainer *container)	
void
Free a capture session output container.
ACaptureSessionOutputContainer_remove(ACaptureSessionOutputContainer *container, const ACaptureSessionOutput *output)	
camera_status_t
Remove an ACaptureSessionOutput object from ACaptureSessionOutputContainer.
ACaptureSessionOutput_create(ACameraWindowType *anw, ACaptureSessionOutput **output)	
camera_status_t
Create a ACaptureSessionOutput object.
ACaptureSessionOutput_free(ACaptureSessionOutput *output)	
void
Free a ACaptureSessionOutput object.
ACaptureSessionPhysicalOutput_create(ACameraWindowType *anw, const char *physicalId, ACaptureSessionOutput **output)	
camera_status_t
Create a ACaptureSessionOutput object used for streaming from a physical camera as part of a logical camera device.
ACaptureSessionSharedOutput_add(ACaptureSessionOutput *output, ACameraWindowType *anw)	
camera_status_t
Add a native window to shared ACaptureSessionOutput.
ACaptureSessionSharedOutput_create(ACameraWindowType *anw, ACaptureSessionOutput **output)	
camera_status_t
Create a shared ACaptureSessionOutput object.
ACaptureSessionSharedOutput_remove(ACaptureSessionOutput *output, ACameraWindowType *anw)	
camera_status_t
Remove a native window from shared ACaptureSessionOutput.
Structs
ACameraCaptureFailure	
Struct to describe a capture failure.

ACameraCaptureSession_captureCallbacks	
ACaptureCaptureSession_captureCallbacks structure used in ACameraCaptureSession_capture and ACameraCaptureSession_setRepeatingRequest.

ACameraCaptureSession_captureCallbacksV2	
This has the same functionality as ACameraCaptureSession_captureCallbacks, with the exception that captureCallback_startV2 callback is used, instead of captureCallback_start, to support retrieving the frame number.

ACameraCaptureSession_logicalCamera_captureCallbacks	
This has the same functionality as ACameraCaptureSession_captureCallbacks, with the exception that an onLogicalCameraCaptureCompleted callback is used, instead of onCaptureCompleted, to support logical multi-camera.

ACameraCaptureSession_logicalCamera_captureCallbacksV2	
This has the same functionality as ACameraCaptureSession_logicalCamera_captureCallbacks, with the exception that an captureCallback_startV2 callback is used, instead of captureCallback_start, to support retrieving frame number.

ACameraCaptureSession_stateCallbacks	
Capture session state callbacks used in ACameraDevice_createCaptureSession and ACameraDevice_createCaptureSessionWithSessionParameters.

ACameraDevice_StateCallbacks	
Applications' callbacks for camera device state changes, register with ACameraManager_openCamera.

ACameraIdList	
Struct to hold list of camera device Ids.

ACameraManager_AvailabilityListener	
A listener for camera devices becoming available or unavailable to open.

ACameraManager_ExtendedAvailabilityListener	
A listener for camera devices becoming available/unavailable to open or when the camera access permissions change.

ACameraMetadata_const_entry	
A single read-only camera metadata entry.

ACameraMetadata_entry	
A single camera metadata entry.

ACameraMetadata_rational	
Definition of rational data type in ACameraMetadata.

ALogicalCameraCaptureFailure	
Struct to describe a logical camera capture failure.

Enumerations
Anonymous Enum 115
 Anonymous Enum 115
Enum for describing error reason in ACameraCaptureFailure.

Properties
CAPTURE_FAILURE_REASON_ERROR	
The capture session has dropped this frame due to an error in the framework.

CAPTURE_FAILURE_REASON_FLUSHED	
The capture session has dropped this frame due to an ACameraCaptureSession_abortCaptures call.

Anonymous Enum 116
 Anonymous Enum 116
Properties
CAPTURE_SEQUENCE_ID_NONE	
Anonymous Enum 117
 Anonymous Enum 117
Enum for ACameraDevice_ErrorStateCallback error code.

Properties
ERROR_CAMERA_DEVICE	
The camera device has encountered a fatal error.

The camera device needs to be re-opened to be used again.

ERROR_CAMERA_DISABLED	
The camera is disabled due to a device policy, and cannot be opened.

ERROR_CAMERA_IN_USE	
The camera device is in use already.

ERROR_CAMERA_SERVICE	
The camera service has encountered a fatal error.

The Android device may need to be shut down and restarted to restore camera function, or there may be a persistent hardware problem. An attempt at recovery may be possible by closing the CameraDevice and the CameraManager, and trying to acquire all resources again from scratch.

ERROR_MAX_CAMERAS_IN_USE	
The system-wide limit for number of open cameras or camera resources has been reached, and more camera devices cannot be opened until previous instances are closed.

Anonymous Enum 118
 Anonymous Enum 118
Possible data types of a metadata entry.

Keep in sync with system/media/include/system/camera_metadata.h

Properties
ACAMERA_NUM_TYPES	
Number of type fields.

ACAMERA_TYPE_BYTE	
Unsigned 8-bit integer (uint8_t)

ACAMERA_TYPE_DOUBLE	
64-bit float (double)

ACAMERA_TYPE_FLOAT	
32-bit float (float)

ACAMERA_TYPE_INT32	
Signed 32-bit integer (int32_t)

ACAMERA_TYPE_INT64	
Signed 64-bit integer (int64_t)

ACAMERA_TYPE_RATIONAL	
A 64-bit fraction (ACameraMetadata_rational)

ACameraDevice_request_template
 ACameraDevice_request_template
Capture request pre-defined template types, used in ACameraDevice_createCaptureRequest and ACameraDevice_createCaptureRequest_withPhysicalIds.

Properties
TEMPLATE_MANUAL	
A basic template for direct application control of capture parameters.

All automatic control is disabled (auto-exposure, auto-white balance, auto-focus), and post-processing parameters are set to preview quality. The manual capture parameters (exposure, sensitivity, and so on) are set to reasonable defaults, but should be overriden by the application depending on the intended use case. This template is guaranteed to be supported on camera devices that support the ACAMERA_REQUEST_AVAILABLE_CAPABILITIES_MANUAL_SENSOR capability.

See also: ACameraDevice_createCaptureRequest

TEMPLATE_PREVIEW	
Create a request suitable for a camera preview window.

Specifically, this means that high frame rate is given priority over the highest-quality post-processing. These requests would normally be used with the ACameraCaptureSession_setRepeatingRequest method. This template is guaranteed to be supported on all camera devices.

See also: ACameraDevice_createCaptureRequest

TEMPLATE_RECORD	
Create a request suitable for video recording.

Specifically, this means that a stable frame rate is used, and post-processing is set for recording quality. These requests would commonly be used with the ACameraCaptureSession_setRepeatingRequest method. This template is guaranteed to be supported on all camera devices.

See also: ACameraDevice_createCaptureRequest

TEMPLATE_STILL_CAPTURE	
Create a request suitable for still image capture.

Specifically, this means prioritizing image quality over frame rate. These requests would commonly be used with the ACameraCaptureSession_capture method. This template is guaranteed to be supported on all camera devices.

See also: ACameraDevice_createCaptureRequest

TEMPLATE_VIDEO_SNAPSHOT	
Create a request suitable for still image capture while recording video.

Specifically, this means maximizing image quality without disrupting the ongoing recording. These requests would commonly be used with the ACameraCaptureSession_capture method while a request based on TEMPLATE_RECORD is is in use with ACameraCaptureSession_setRepeatingRequest. This template is guaranteed to be supported on all camera devices.

See also: ACameraDevice_createCaptureRequest

TEMPLATE_ZERO_SHUTTER_LAG	
Create a request suitable for zero shutter lag still capture.

This means means maximizing image quality without compromising preview frame rate. AE/AWB/AF should be on auto mode.

See also: ACameraDevice_createCaptureRequest

acamera_metadata_enum_acamera_automotive_lens_facing
 acamera_metadata_enum_acamera_automotive_lens_facing
Properties
ACAMERA_AUTOMOTIVE_LENS_FACING_EXTERIOR_FRONT	
The camera device faces the front of the vehicle body frame.

ACAMERA_AUTOMOTIVE_LENS_FACING_EXTERIOR_LEFT	
The camera device faces the left side of the vehicle body frame.

ACAMERA_AUTOMOTIVE_LENS_FACING_EXTERIOR_OTHER	
The camera device faces the outside of the vehicle body frame but not exactly one of the exterior sides defined by this enum. Applications should determine the exact facing direction from ACAMERA_LENS_POSE_ROTATION and ACAMERA_LENS_POSE_TRANSLATION.

See also: ACAMERA_LENS_POSE_ROTATION See also: ACAMERA_LENS_POSE_TRANSLATION

ACAMERA_AUTOMOTIVE_LENS_FACING_EXTERIOR_REAR	
The camera device faces the rear of the vehicle body frame.

ACAMERA_AUTOMOTIVE_LENS_FACING_EXTERIOR_RIGHT	
The camera device faces the right side of the vehicle body frame.

ACAMERA_AUTOMOTIVE_LENS_FACING_INTERIOR_OTHER	
The camera device faces the inside of the vehicle body frame but not exactly one of seats described by this enum. Applications should determine the exact facing direction from ACAMERA_LENS_POSE_ROTATION and ACAMERA_LENS_POSE_TRANSLATION.

See also: ACAMERA_LENS_POSE_ROTATION See also: ACAMERA_LENS_POSE_TRANSLATION

ACAMERA_AUTOMOTIVE_LENS_FACING_INTERIOR_SEAT_ROW_1_CENTER	
The camera device faces the center seat of the first row.

ACAMERA_AUTOMOTIVE_LENS_FACING_INTERIOR_SEAT_ROW_1_LEFT	
The camera device faces the left side seat of the first row.

ACAMERA_AUTOMOTIVE_LENS_FACING_INTERIOR_SEAT_ROW_1_RIGHT	
The camera device faces the right seat of the first row.

ACAMERA_AUTOMOTIVE_LENS_FACING_INTERIOR_SEAT_ROW_2_CENTER	
The camera device faces the center seat of the second row.

ACAMERA_AUTOMOTIVE_LENS_FACING_INTERIOR_SEAT_ROW_2_LEFT	
The camera device faces the left side seat of the second row.

ACAMERA_AUTOMOTIVE_LENS_FACING_INTERIOR_SEAT_ROW_2_RIGHT	
The camera device faces the right side seat of the second row.

ACAMERA_AUTOMOTIVE_LENS_FACING_INTERIOR_SEAT_ROW_3_CENTER	
The camera device faces the center seat of the third row.

ACAMERA_AUTOMOTIVE_LENS_FACING_INTERIOR_SEAT_ROW_3_LEFT	
The camera device faces the left side seat of the third row.

ACAMERA_AUTOMOTIVE_LENS_FACING_INTERIOR_SEAT_ROW_3_RIGHT	
The camera device faces the right seat of the third row.

acamera_metadata_enum_acamera_automotive_location
 acamera_metadata_enum_acamera_automotive_location
Properties
ACAMERA_AUTOMOTIVE_LOCATION_EXTERIOR_FRONT	
The camera device exists outside of the vehicle body frame and on its front side.

ACAMERA_AUTOMOTIVE_LOCATION_EXTERIOR_LEFT	
The camera device exists outside and on left side of the vehicle body frame.

ACAMERA_AUTOMOTIVE_LOCATION_EXTERIOR_OTHER	
The camera exists outside of the vehicle body frame but not exactly on one of the exterior locations this enum defines. The applications should determine the exact location from ACAMERA_LENS_POSE_TRANSLATION.

See also: ACAMERA_LENS_POSE_TRANSLATION

ACAMERA_AUTOMOTIVE_LOCATION_EXTERIOR_REAR	
The camera device exists outside of the vehicle body frame and on its rear side.

ACAMERA_AUTOMOTIVE_LOCATION_EXTERIOR_RIGHT	
The camera device exists outside and on right side of the vehicle body frame.

ACAMERA_AUTOMOTIVE_LOCATION_EXTRA_FRONT	
The camera device exists outside of the extra vehicle's body frame and on its front side.

ACAMERA_AUTOMOTIVE_LOCATION_EXTRA_LEFT	
The camera device exists outside and on left side of the extra vehicle body.

ACAMERA_AUTOMOTIVE_LOCATION_EXTRA_OTHER	
The camera device exists on an extra vehicle, such as the trailer, but not exactly on one of front, rear, left, or right side. Applications should determine the exact location from ACAMERA_LENS_POSE_TRANSLATION.

See also: ACAMERA_LENS_POSE_TRANSLATION

ACAMERA_AUTOMOTIVE_LOCATION_EXTRA_REAR	
The camera device exists outside of the extra vehicle's body frame and on its rear side.

ACAMERA_AUTOMOTIVE_LOCATION_EXTRA_RIGHT	
The camera device exists outside and on right side of the extra vehicle body.

ACAMERA_AUTOMOTIVE_LOCATION_INTERIOR	
The camera device exists inside of the vehicle cabin.

acamera_metadata_enum_acamera_black_level_lock
 acamera_metadata_enum_acamera_black_level_lock
Properties
ACAMERA_BLACK_LEVEL_LOCK_OFF	
ACAMERA_BLACK_LEVEL_LOCK_ON	
acamera_metadata_enum_acamera_color_correction_aberration_mode
 acamera_metadata_enum_acamera_color_correction_aberration_mode
Properties
ACAMERA_COLOR_CORRECTION_ABERRATION_MODE_FAST	
Aberration correction will not slow down capture rate relative to sensor raw output.

ACAMERA_COLOR_CORRECTION_ABERRATION_MODE_HIGH_QUALITY	
Aberration correction operates at improved quality but the capture rate might be reduced (relative to sensor raw output rate)

ACAMERA_COLOR_CORRECTION_ABERRATION_MODE_OFF	
No aberration correction is applied.

acamera_metadata_enum_acamera_color_correction_mode
 acamera_metadata_enum_acamera_color_correction_mode
Enumeration definitions for the various entries that need them.

Properties
ACAMERA_COLOR_CORRECTION_MODE_FAST	
Color correction processing must not slow down capture rate relative to sensor raw output.

Advanced white balance adjustments above and beyond the specified white balance pipeline may be applied.

If AWB is enabled with ACAMERA_CONTROL_AWB_MODE != OFF, then the camera device uses the last frame's AWB values (or defaults if AWB has never been run).

See also: ACAMERA_CONTROL_AWB_MODE

ACAMERA_COLOR_CORRECTION_MODE_HIGH_QUALITY	
Color correction processing operates at improved quality but the capture rate might be reduced (relative to sensor raw output rate)

Advanced white balance adjustments above and beyond the specified white balance pipeline may be applied.

If AWB is enabled with ACAMERA_CONTROL_AWB_MODE != OFF, then the camera device uses the last frame's AWB values (or defaults if AWB has never been run).

See also: ACAMERA_CONTROL_AWB_MODE

ACAMERA_COLOR_CORRECTION_MODE_TRANSFORM_MATRIX	
Use the ACAMERA_COLOR_CORRECTION_TRANSFORM matrix and ACAMERA_COLOR_CORRECTION_GAINS to do color conversion.

All advanced white balance adjustments (not specified by our white balance pipeline) must be disabled.

If AWB is enabled with ACAMERA_CONTROL_AWB_MODE != OFF, then TRANSFORM_MATRIX is ignored. The camera device will override this value to either FAST or HIGH_QUALITY.

See also: ACAMERA_COLOR_CORRECTION_GAINS See also: ACAMERA_COLOR_CORRECTION_TRANSFORM See also: ACAMERA_CONTROL_AWB_MODE

acamera_metadata_enum_acamera_control_ae_antibanding_mode
 acamera_metadata_enum_acamera_control_ae_antibanding_mode
Properties
ACAMERA_CONTROL_AE_ANTIBANDING_MODE_50HZ	
The camera device will adjust exposure duration to avoid banding problems with 50Hz illumination sources.

ACAMERA_CONTROL_AE_ANTIBANDING_MODE_60HZ	
The camera device will adjust exposure duration to avoid banding problems with 60Hz illumination sources.

ACAMERA_CONTROL_AE_ANTIBANDING_MODE_AUTO	
The camera device will automatically adapt its antibanding routine to the current illumination condition. This is the default mode if AUTO is available on given camera device.

ACAMERA_CONTROL_AE_ANTIBANDING_MODE_OFF	
The camera device will not adjust exposure duration to avoid banding problems.

acamera_metadata_enum_acamera_control_ae_lock
 acamera_metadata_enum_acamera_control_ae_lock
Properties
ACAMERA_CONTROL_AE_LOCK_OFF	
Auto-exposure lock is disabled; the AE algorithm is free to update its parameters.

ACAMERA_CONTROL_AE_LOCK_ON	
Auto-exposure lock is enabled; the AE algorithm must not update the exposure and sensitivity parameters while the lock is active.

ACAMERA_CONTROL_AE_EXPOSURE_COMPENSATION setting changes will still take effect while auto-exposure is locked.

Some rare LEGACY devices may not support this, in which case the value will always be overridden to OFF.

See also: ACAMERA_CONTROL_AE_EXPOSURE_COMPENSATION

acamera_metadata_enum_acamera_control_ae_lock_available
 acamera_metadata_enum_acamera_control_ae_lock_available
Properties
ACAMERA_CONTROL_AE_LOCK_AVAILABLE_FALSE	
ACAMERA_CONTROL_AE_LOCK_AVAILABLE_TRUE	
acamera_metadata_enum_acamera_control_ae_mode
 acamera_metadata_enum_acamera_control_ae_mode
Properties
ACAMERA_CONTROL_AE_MODE_OFF	
The camera device's autoexposure routine is disabled.

The application-selected ACAMERA_SENSOR_EXPOSURE_TIME, ACAMERA_SENSOR_SENSITIVITY and ACAMERA_SENSOR_FRAME_DURATION are used by the camera device, along with ACAMERA_FLASH_* fields, if there's a flash unit for this camera device.

Note that auto-white balance (AWB) and auto-focus (AF) behavior is device dependent when AE is in OFF mode. To have consistent behavior across different devices, it is recommended to either set AWB and AF to OFF mode or lock AWB and AF before setting AE to OFF. See ACAMERA_CONTROL_AWB_MODE, ACAMERA_CONTROL_AF_MODE, ACAMERA_CONTROL_AWB_LOCK, and ACAMERA_CONTROL_AF_TRIGGER for more details.

LEGACY devices do not support the OFF mode and will override attempts to use this value to ON.

See also: ACAMERA_CONTROL_AF_MODE See also: ACAMERA_CONTROL_AF_TRIGGER See also: ACAMERA_CONTROL_AWB_LOCK See also: ACAMERA_CONTROL_AWB_MODE See also: ACAMERA_SENSOR_EXPOSURE_TIME See also: ACAMERA_SENSOR_FRAME_DURATION See also: ACAMERA_SENSOR_SENSITIVITY

ACAMERA_CONTROL_AE_MODE_ON	
The camera device's autoexposure routine is active, with no flash control.

The application's values for ACAMERA_SENSOR_EXPOSURE_TIME, ACAMERA_SENSOR_SENSITIVITY, and ACAMERA_SENSOR_FRAME_DURATION are ignored. The application has control over the various ACAMERA_FLASH_* fields.

See also: ACAMERA_SENSOR_EXPOSURE_TIME See also: ACAMERA_SENSOR_FRAME_DURATION See also: ACAMERA_SENSOR_SENSITIVITY

ACAMERA_CONTROL_AE_MODE_ON_ALWAYS_FLASH	
Like ON, except that the camera device also controls the camera's flash unit, always firing it for still captures.

The flash may be fired during a precapture sequence (triggered by ACAMERA_CONTROL_AE_PRECAPTURE_TRIGGER) and will always be fired for captures for which the ACAMERA_CONTROL_CAPTURE_INTENT field is set to STILL_CAPTURE

See also: ACAMERA_CONTROL_AE_PRECAPTURE_TRIGGER See also: ACAMERA_CONTROL_CAPTURE_INTENT

ACAMERA_CONTROL_AE_MODE_ON_AUTO_FLASH	
Like ON, except that the camera device also controls the camera's flash unit, firing it in low-light conditions.

The flash may be fired during a precapture sequence (triggered by ACAMERA_CONTROL_AE_PRECAPTURE_TRIGGER) and may be fired for captures for which the ACAMERA_CONTROL_CAPTURE_INTENT field is set to STILL_CAPTURE

See also: ACAMERA_CONTROL_AE_PRECAPTURE_TRIGGER See also: ACAMERA_CONTROL_CAPTURE_INTENT

ACAMERA_CONTROL_AE_MODE_ON_AUTO_FLASH_REDEYE	
Like ON_AUTO_FLASH, but with automatic red eye reduction.

If deemed necessary by the camera device, a red eye reduction flash will fire during the precapture sequence.

ACAMERA_CONTROL_AE_MODE_ON_EXTERNAL_FLASH	
An external flash has been turned on.

It informs the camera device that an external flash has been turned on, and that metering (and continuous focus if active) should be quickly recaculated to account for the external flash. Otherwise, this mode acts like ON.

When the external flash is turned off, AE mode should be changed to one of the other available AE modes.

If the camera device supports AE external flash mode, ACAMERA_CONTROL_AE_STATE must be FLASH_REQUIRED after the camera device finishes AE scan and it's too dark without flash.

See also: ACAMERA_CONTROL_AE_STATE

acamera_metadata_enum_acamera_control_ae_precapture_trigger
 acamera_metadata_enum_acamera_control_ae_precapture_trigger
Properties
ACAMERA_CONTROL_AE_PRECAPTURE_TRIGGER_CANCEL	
The camera device will cancel any currently active or completed precapture metering sequence, the auto-exposure routine will return to its initial state.

ACAMERA_CONTROL_AE_PRECAPTURE_TRIGGER_IDLE	
The trigger is idle.

ACAMERA_CONTROL_AE_PRECAPTURE_TRIGGER_START	
The precapture metering sequence will be started by the camera device.

The exact effect of the precapture trigger depends on the current AE mode and state.

acamera_metadata_enum_acamera_control_ae_state
 acamera_metadata_enum_acamera_control_ae_state
Properties
ACAMERA_CONTROL_AE_STATE_CONVERGED	
AE has a good set of control values for the current scene.

ACAMERA_CONTROL_AE_STATE_FLASH_REQUIRED	
AE has a good set of control values, but flash needs to be fired for good quality still capture.

ACAMERA_CONTROL_AE_STATE_INACTIVE	
AE is off or recently reset.

When a camera device is opened, it starts in this state. This is a transient state, the camera device may skip reporting this state in capture result.

ACAMERA_CONTROL_AE_STATE_LOCKED	
AE has been locked.

ACAMERA_CONTROL_AE_STATE_PRECAPTURE	
AE has been asked to do a precapture sequence and is currently executing it.

Precapture can be triggered through setting ACAMERA_CONTROL_AE_PRECAPTURE_TRIGGER to START. Currently active and completed (if it causes camera device internal AE lock) precapture metering sequence can be canceled through setting ACAMERA_CONTROL_AE_PRECAPTURE_TRIGGER to CANCEL.

Once PRECAPTURE completes, AE will transition to CONVERGED or FLASH_REQUIRED as appropriate. This is a transient state, the camera device may skip reporting this state in capture result.

See also: ACAMERA_CONTROL_AE_PRECAPTURE_TRIGGER

ACAMERA_CONTROL_AE_STATE_SEARCHING	
AE doesn't yet have a good set of control values for the current scene.

This is a transient state, the camera device may skip reporting this state in capture result.

acamera_metadata_enum_acamera_control_af_mode
 acamera_metadata_enum_acamera_control_af_mode
Properties
ACAMERA_CONTROL_AF_MODE_AUTO	
Basic automatic focus mode.

In this mode, the lens does not move unless the autofocus trigger action is called. When that trigger is activated, AF will transition to ACTIVE_SCAN, then to the outcome of the scan (FOCUSED or NOT_FOCUSED).

Always supported if lens is not fixed focus.

Use ACAMERA_LENS_INFO_MINIMUM_FOCUS_DISTANCE to determine if lens is fixed-focus.

Triggering AF_CANCEL resets the lens position to default, and sets the AF state to INACTIVE.

See also: ACAMERA_LENS_INFO_MINIMUM_FOCUS_DISTANCE

ACAMERA_CONTROL_AF_MODE_CONTINUOUS_PICTURE	
In this mode, the AF algorithm modifies the lens position continually to attempt to provide a constantly-in-focus image stream.

The focusing behavior should be suitable for still image capture; typically this means focusing as fast as possible. When the AF trigger is not involved, the AF algorithm should start in INACTIVE state, and then transition into PASSIVE_SCAN and PASSIVE_FOCUSED states as appropriate as it attempts to maintain focus. When the AF trigger is activated, the algorithm should finish its PASSIVE_SCAN if active, and then transition into AF_FOCUSED or AF_NOT_FOCUSED as appropriate, and lock the lens position until a cancel AF trigger is received.

When the AF cancel trigger is activated, the algorithm should transition back to INACTIVE and then act as if it has just been started.

ACAMERA_CONTROL_AF_MODE_CONTINUOUS_VIDEO	
In this mode, the AF algorithm modifies the lens position continually to attempt to provide a constantly-in-focus image stream.

The focusing behavior should be suitable for good quality video recording; typically this means slower focus movement and no overshoots. When the AF trigger is not involved, the AF algorithm should start in INACTIVE state, and then transition into PASSIVE_SCAN and PASSIVE_FOCUSED states as appropriate. When the AF trigger is activated, the algorithm should immediately transition into AF_FOCUSED or AF_NOT_FOCUSED as appropriate, and lock the lens position until a cancel AF trigger is received.

Once cancel is received, the algorithm should transition back to INACTIVE and resume passive scan. Note that this behavior is not identical to CONTINUOUS_PICTURE, since an ongoing PASSIVE_SCAN must immediately be canceled.

ACAMERA_CONTROL_AF_MODE_EDOF	
Extended depth of field (digital focus) mode.

The camera device will produce images with an extended depth of field automatically; no special focusing operations need to be done before taking a picture.

AF triggers are ignored, and the AF state will always be INACTIVE.

ACAMERA_CONTROL_AF_MODE_MACRO	
Close-up focusing mode.

In this mode, the lens does not move unless the autofocus trigger action is called. When that trigger is activated, AF will transition to ACTIVE_SCAN, then to the outcome of the scan (FOCUSED or NOT_FOCUSED). This mode is optimized for focusing on objects very close to the camera.

When that trigger is activated, AF will transition to ACTIVE_SCAN, then to the outcome of the scan (FOCUSED or NOT_FOCUSED). Triggering cancel AF resets the lens position to default, and sets the AF state to INACTIVE.

ACAMERA_CONTROL_AF_MODE_OFF	
The auto-focus routine does not control the lens; ACAMERA_LENS_FOCUS_DISTANCE is controlled by the application.

See also: ACAMERA_LENS_FOCUS_DISTANCE

acamera_metadata_enum_acamera_control_af_scene_change
 acamera_metadata_enum_acamera_control_af_scene_change
Properties
ACAMERA_CONTROL_AF_SCENE_CHANGE_DETECTED	
Scene change is detected within the AF region(s).

ACAMERA_CONTROL_AF_SCENE_CHANGE_NOT_DETECTED	
Scene change is not detected within the AF region(s).

acamera_metadata_enum_acamera_control_af_state
 acamera_metadata_enum_acamera_control_af_state
Properties
ACAMERA_CONTROL_AF_STATE_ACTIVE_SCAN	
AF is performing an AF scan because it was triggered by AF trigger.

Only used by AUTO or MACRO AF modes. This is a transient state, the camera device may skip reporting this state in capture result.

ACAMERA_CONTROL_AF_STATE_FOCUSED_LOCKED	
AF believes it is focused correctly and has locked focus.

This state is reached only after an explicit START AF trigger has been sent (ACAMERA_CONTROL_AF_TRIGGER), when good focus has been obtained.

The lens will remain stationary until the AF mode (ACAMERA_CONTROL_AF_MODE) is changed or a new AF trigger is sent to the camera device (ACAMERA_CONTROL_AF_TRIGGER).

See also: ACAMERA_CONTROL_AF_MODE See also: ACAMERA_CONTROL_AF_TRIGGER

ACAMERA_CONTROL_AF_STATE_INACTIVE	
AF is off or has not yet tried to scan/been asked to scan.

When a camera device is opened, it starts in this state. This is a transient state, the camera device may skip reporting this state in capture result.

ACAMERA_CONTROL_AF_STATE_NOT_FOCUSED_LOCKED	
AF has failed to focus successfully and has locked focus.

This state is reached only after an explicit START AF trigger has been sent (ACAMERA_CONTROL_AF_TRIGGER), when good focus cannot be obtained.

The lens will remain stationary until the AF mode (ACAMERA_CONTROL_AF_MODE) is changed or a new AF trigger is sent to the camera device (ACAMERA_CONTROL_AF_TRIGGER).

See also: ACAMERA_CONTROL_AF_MODE See also: ACAMERA_CONTROL_AF_TRIGGER

ACAMERA_CONTROL_AF_STATE_PASSIVE_FOCUSED	
AF currently believes it is in focus, but may restart scanning at any time.

Only used by CONTINUOUS_* AF modes. This is a transient state, the camera device may skip reporting this state in capture result.

ACAMERA_CONTROL_AF_STATE_PASSIVE_SCAN	
AF is currently performing an AF scan initiated the camera device in a continuous autofocus mode.

Only used by CONTINUOUS_* AF modes. This is a transient state, the camera device may skip reporting this state in capture result.

ACAMERA_CONTROL_AF_STATE_PASSIVE_UNFOCUSED	
AF finished a passive scan without finding focus, and may restart scanning at any time.

Only used by CONTINUOUS_* AF modes. This is a transient state, the camera device may skip reporting this state in capture result.

LEGACY camera devices do not support this state. When a passive scan has finished, it will always go to PASSIVE_FOCUSED.

acamera_metadata_enum_acamera_control_af_trigger
 acamera_metadata_enum_acamera_control_af_trigger
Properties
ACAMERA_CONTROL_AF_TRIGGER_CANCEL	
Autofocus will return to its initial state, and cancel any currently active trigger.

ACAMERA_CONTROL_AF_TRIGGER_IDLE	
The trigger is idle.

ACAMERA_CONTROL_AF_TRIGGER_START	
Autofocus will trigger now.

acamera_metadata_enum_acamera_control_awb_lock
 acamera_metadata_enum_acamera_control_awb_lock
Properties
ACAMERA_CONTROL_AWB_LOCK_OFF	
Auto-white balance lock is disabled; the AWB algorithm is free to update its parameters if in AUTO mode.

ACAMERA_CONTROL_AWB_LOCK_ON	
Auto-white balance lock is enabled; the AWB algorithm will not update its parameters while the lock is active.

acamera_metadata_enum_acamera_control_awb_lock_available
 acamera_metadata_enum_acamera_control_awb_lock_available
Properties
ACAMERA_CONTROL_AWB_LOCK_AVAILABLE_FALSE	
ACAMERA_CONTROL_AWB_LOCK_AVAILABLE_TRUE	
acamera_metadata_enum_acamera_control_awb_mode
 acamera_metadata_enum_acamera_control_awb_mode
Properties
ACAMERA_CONTROL_AWB_MODE_AUTO	
The camera device's auto-white balance routine is active.

The application's values for ACAMERA_COLOR_CORRECTION_TRANSFORM and ACAMERA_COLOR_CORRECTION_GAINS are ignored. For devices that support the MANUAL_POST_PROCESSING capability, the values used by the camera device for the transform and gains will be available in the capture result for this request.

See also: ACAMERA_COLOR_CORRECTION_GAINS See also: ACAMERA_COLOR_CORRECTION_TRANSFORM

ACAMERA_CONTROL_AWB_MODE_CLOUDY_DAYLIGHT	
The camera device's auto-white balance routine is disabled; the camera device uses cloudy daylight light as the assumed scene illumination for white balance.

The application's values for ACAMERA_COLOR_CORRECTION_TRANSFORM and ACAMERA_COLOR_CORRECTION_GAINS are ignored. For devices that support the MANUAL_POST_PROCESSING capability, the values used by the camera device for the transform and gains will be available in the capture result for this request.

See also: ACAMERA_COLOR_CORRECTION_GAINS See also: ACAMERA_COLOR_CORRECTION_TRANSFORM

ACAMERA_CONTROL_AWB_MODE_DAYLIGHT	
The camera device's auto-white balance routine is disabled; the camera device uses daylight light as the assumed scene illumination for white balance.

While the exact white balance transforms are up to the camera device, they will approximately match the CIE standard illuminant D65.

The application's values for ACAMERA_COLOR_CORRECTION_TRANSFORM and ACAMERA_COLOR_CORRECTION_GAINS are ignored. For devices that support the MANUAL_POST_PROCESSING capability, the values used by the camera device for the transform and gains will be available in the capture result for this request.

See also: ACAMERA_COLOR_CORRECTION_GAINS See also: ACAMERA_COLOR_CORRECTION_TRANSFORM

ACAMERA_CONTROL_AWB_MODE_FLUORESCENT	
The camera device's auto-white balance routine is disabled; the camera device uses fluorescent light as the assumed scene illumination for white balance.

While the exact white balance transforms are up to the camera device, they will approximately match the CIE standard illuminant F2.

The application's values for ACAMERA_COLOR_CORRECTION_TRANSFORM and ACAMERA_COLOR_CORRECTION_GAINS are ignored. For devices that support the MANUAL_POST_PROCESSING capability, the values used by the camera device for the transform and gains will be available in the capture result for this request.

See also: ACAMERA_COLOR_CORRECTION_GAINS See also: ACAMERA_COLOR_CORRECTION_TRANSFORM

ACAMERA_CONTROL_AWB_MODE_INCANDESCENT	
The camera device's auto-white balance routine is disabled; the camera device uses incandescent light as the assumed scene illumination for white balance.

While the exact white balance transforms are up to the camera device, they will approximately match the CIE standard illuminant A.

The application's values for ACAMERA_COLOR_CORRECTION_TRANSFORM and ACAMERA_COLOR_CORRECTION_GAINS are ignored. For devices that support the MANUAL_POST_PROCESSING capability, the values used by the camera device for the transform and gains will be available in the capture result for this request.

See also: ACAMERA_COLOR_CORRECTION_GAINS See also: ACAMERA_COLOR_CORRECTION_TRANSFORM

ACAMERA_CONTROL_AWB_MODE_OFF	
The camera device's auto-white balance routine is disabled.

The application-selected color transform matrix (ACAMERA_COLOR_CORRECTION_TRANSFORM) and gains (ACAMERA_COLOR_CORRECTION_GAINS) are used by the camera device for manual white balance control.

See also: ACAMERA_COLOR_CORRECTION_GAINS See also: ACAMERA_COLOR_CORRECTION_TRANSFORM

ACAMERA_CONTROL_AWB_MODE_SHADE	
The camera device's auto-white balance routine is disabled; the camera device uses shade light as the assumed scene illumination for white balance.

The application's values for ACAMERA_COLOR_CORRECTION_TRANSFORM and ACAMERA_COLOR_CORRECTION_GAINS are ignored. For devices that support the MANUAL_POST_PROCESSING capability, the values used by the camera device for the transform and gains will be available in the capture result for this request.

See also: ACAMERA_COLOR_CORRECTION_GAINS See also: ACAMERA_COLOR_CORRECTION_TRANSFORM

ACAMERA_CONTROL_AWB_MODE_TWILIGHT	
The camera device's auto-white balance routine is disabled; the camera device uses twilight light as the assumed scene illumination for white balance.

The application's values for ACAMERA_COLOR_CORRECTION_TRANSFORM and ACAMERA_COLOR_CORRECTION_GAINS are ignored. For devices that support the MANUAL_POST_PROCESSING capability, the values used by the camera device for the transform and gains will be available in the capture result for this request.

See also: ACAMERA_COLOR_CORRECTION_GAINS See also: ACAMERA_COLOR_CORRECTION_TRANSFORM

ACAMERA_CONTROL_AWB_MODE_WARM_FLUORESCENT	
The camera device's auto-white balance routine is disabled; the camera device uses warm fluorescent light as the assumed scene illumination for white balance.

While the exact white balance transforms are up to the camera device, they will approximately match the CIE standard illuminant F4.

The application's values for ACAMERA_COLOR_CORRECTION_TRANSFORM and ACAMERA_COLOR_CORRECTION_GAINS are ignored. For devices that support the MANUAL_POST_PROCESSING capability, the values used by the camera device for the transform and gains will be available in the capture result for this request.

See also: ACAMERA_COLOR_CORRECTION_GAINS See also: ACAMERA_COLOR_CORRECTION_TRANSFORM

acamera_metadata_enum_acamera_control_awb_state
 acamera_metadata_enum_acamera_control_awb_state
Properties
ACAMERA_CONTROL_AWB_STATE_CONVERGED	
AWB has a good set of control values for the current scene.

ACAMERA_CONTROL_AWB_STATE_INACTIVE	
AWB is not in auto mode, or has not yet started metering.

When a camera device is opened, it starts in this state. This is a transient state, the camera device may skip reporting this state in capture result.

ACAMERA_CONTROL_AWB_STATE_LOCKED	
AWB has been locked.

ACAMERA_CONTROL_AWB_STATE_SEARCHING	
AWB doesn't yet have a good set of control values for the current scene.

This is a transient state, the camera device may skip reporting this state in capture result.

acamera_metadata_enum_acamera_control_capture_intent
 acamera_metadata_enum_acamera_control_capture_intent
Properties
ACAMERA_CONTROL_CAPTURE_INTENT_CUSTOM	
The goal of this request doesn't fall into the other categories. The camera device will default to preview-like behavior.

ACAMERA_CONTROL_CAPTURE_INTENT_MANUAL	
This request is for manual capture use case where the applications want to directly control the capture parameters.

For example, the application may wish to manually control ACAMERA_SENSOR_EXPOSURE_TIME, ACAMERA_SENSOR_SENSITIVITY, etc.

See also: ACAMERA_SENSOR_EXPOSURE_TIME See also: ACAMERA_SENSOR_SENSITIVITY

ACAMERA_CONTROL_CAPTURE_INTENT_MOTION_TRACKING	
This request is for a motion tracking use case, where the application will use camera and inertial sensor data to locate and track objects in the world.

The camera device auto-exposure routine will limit the exposure time of the camera to no more than 20 milliseconds, to minimize motion blur.

ACAMERA_CONTROL_CAPTURE_INTENT_PREVIEW	
This request is for a preview-like use case.

The precapture trigger may be used to start off a metering w/flash sequence.

ACAMERA_CONTROL_CAPTURE_INTENT_STILL_CAPTURE	
This request is for a still capture-type use case.

If the flash unit is under automatic control, it may fire as needed.

ACAMERA_CONTROL_CAPTURE_INTENT_VIDEO_RECORD	
This request is for a video recording use case.

ACAMERA_CONTROL_CAPTURE_INTENT_VIDEO_SNAPSHOT	
This request is for a video snapshot (still image while recording video) use case.

The camera device should take the highest-quality image possible (given the other settings) without disrupting the frame rate of video recording.

ACAMERA_CONTROL_CAPTURE_INTENT_ZERO_SHUTTER_LAG	
This request is for a ZSL usecase; the application will stream full-resolution images and reprocess one or several later for a final capture.

acamera_metadata_enum_acamera_control_effect_mode
 acamera_metadata_enum_acamera_control_effect_mode
Properties
ACAMERA_CONTROL_EFFECT_MODE_AQUA	
An "aqua" effect where a blue hue is added to the image.

ACAMERA_CONTROL_EFFECT_MODE_BLACKBOARD	
A "blackboard" effect where the image is typically displayed as regions of black, with white or grey details.

ACAMERA_CONTROL_EFFECT_MODE_MONO	
A "monocolor" effect where the image is mapped into a single color.

This will typically be grayscale.

ACAMERA_CONTROL_EFFECT_MODE_NEGATIVE	
A "photo-negative" effect where the image's colors are inverted.

ACAMERA_CONTROL_EFFECT_MODE_OFF	
No color effect will be applied.

ACAMERA_CONTROL_EFFECT_MODE_POSTERIZE	
A "posterization" effect where the image uses discrete regions of tone rather than a continuous gradient of tones.

ACAMERA_CONTROL_EFFECT_MODE_SEPIA	
A "sepia" effect where the image is mapped into warm gray, red, and brown tones.

ACAMERA_CONTROL_EFFECT_MODE_SOLARIZE	
A "solarisation" effect (Sabattier effect) where the image is wholly or partially reversed in tone.

ACAMERA_CONTROL_EFFECT_MODE_WHITEBOARD	
A "whiteboard" effect where the image is typically displayed as regions of white, with black or grey details.

acamera_metadata_enum_acamera_control_enable_zsl
 acamera_metadata_enum_acamera_control_enable_zsl
Properties
ACAMERA_CONTROL_ENABLE_ZSL_FALSE	
Requests with ACAMERA_CONTROL_CAPTURE_INTENT == STILL_CAPTURE must be captured after previous requests.

See also: ACAMERA_CONTROL_CAPTURE_INTENT

ACAMERA_CONTROL_ENABLE_ZSL_TRUE	
Requests with ACAMERA_CONTROL_CAPTURE_INTENT == STILL_CAPTURE may or may not be captured before previous requests.

See also: ACAMERA_CONTROL_CAPTURE_INTENT

acamera_metadata_enum_acamera_control_extended_scene_mode
 acamera_metadata_enum_acamera_control_extended_scene_mode
Properties
ACAMERA_CONTROL_EXTENDED_SCENE_MODE_BOKEH_CONTINUOUS	
Bokeh effect must not slow down capture rate relative to sensor raw output, and the effect is applied to all processed streams no larger than the maximum streaming dimension. This mode should be used if performance and power are a priority, such as video recording.

ACAMERA_CONTROL_EXTENDED_SCENE_MODE_BOKEH_STILL_CAPTURE	
High quality bokeh mode is enabled for all non-raw streams (including YUV, JPEG, and IMPLEMENTATION_DEFINED) when capture intent is STILL_CAPTURE. Due to the extra image processing, this mode may introduce additional stall to non-raw streams. This mode should be used in high quality still capture use case.

ACAMERA_CONTROL_EXTENDED_SCENE_MODE_DISABLED	
Extended scene mode is disabled.

acamera_metadata_enum_acamera_control_mode
 acamera_metadata_enum_acamera_control_mode
Properties
ACAMERA_CONTROL_MODE_AUTO	
Use settings for each individual 3A routine.

Manual control of capture parameters is disabled. All controls in ACAMERA_CONTROL_* besides sceneMode take effect.

ACAMERA_CONTROL_MODE_OFF	
Full application control of pipeline.

All control by the device's metering and focusing (3A) routines is disabled, and no other settings in ACAMERA_CONTROL_* have any effect, except that ACAMERA_CONTROL_CAPTURE_INTENT may be used by the camera device to select post-processing values for processing blocks that do not allow for manual control, or are not exposed by the camera API.

However, the camera device's 3A routines may continue to collect statistics and update their internal state so that when control is switched to AUTO mode, good control values can be immediately applied.

See also: ACAMERA_CONTROL_CAPTURE_INTENT

ACAMERA_CONTROL_MODE_OFF_KEEP_STATE	
Same as OFF mode, except that this capture will not be used by camera device background auto-exposure, auto-white balance and auto-focus algorithms (3A) to update their statistics.

Specifically, the 3A routines are locked to the last values set from a request with AUTO, OFF, or USE_SCENE_MODE, and any statistics or state updates collected from manual captures with OFF_KEEP_STATE will be discarded by the camera device.

ACAMERA_CONTROL_MODE_USE_EXTENDED_SCENE_MODE	
Use a specific extended scene mode.

When extended scene mode is on, the camera device may override certain control parameters, such as targetFpsRange, AE, AWB, and AF modes, to achieve best power and quality tradeoffs. Only the mandatory stream combinations of LIMITED hardware level are guaranteed.

This setting can only be used if extended scene mode is supported (i.e. android.control.availableExtendedSceneModes contains some modes other than DISABLED).

ACAMERA_CONTROL_MODE_USE_SCENE_MODE	
Use a specific scene mode.

Enabling this disables control.aeMode, control.awbMode and control.afMode controls; the camera device will ignore those settings while USE_SCENE_MODE is active (except for FACE_PRIORITY scene mode). Other control entries are still active. This setting can only be used if scene mode is supported (i.e. ACAMERA_CONTROL_AVAILABLE_SCENE_MODES contain some modes other than DISABLED).

For extended scene modes such as BOKEH, please use USE_EXTENDED_SCENE_MODE instead.

See also: ACAMERA_CONTROL_AVAILABLE_SCENE_MODES

acamera_metadata_enum_acamera_control_scene_mode
 acamera_metadata_enum_acamera_control_scene_mode
Properties
ACAMERA_CONTROL_SCENE_MODE_ACTION	
Optimized for photos of quickly moving objects.

Similar to SPORTS.

ACAMERA_CONTROL_SCENE_MODE_BARCODE	
Optimized for accurately capturing a photo of barcode for use by camera applications that wish to read the barcode value.

ACAMERA_CONTROL_SCENE_MODE_BEACH	
Optimized for bright, outdoor beach settings.

ACAMERA_CONTROL_SCENE_MODE_CANDLELIGHT	
Optimized for dim settings where the main light source is a candle.

ACAMERA_CONTROL_SCENE_MODE_DISABLED	
Indicates that no scene modes are set for a given capture request.

ACAMERA_CONTROL_SCENE_MODE_FACE_PRIORITY	
If face detection support exists, use face detection data for auto-focus, auto-white balance, and auto-exposure routines.

If face detection statistics are disabled (i.e. ACAMERA_STATISTICS_FACE_DETECT_MODE is set to OFF), this should still operate correctly (but will not return face detection statistics to the framework).

Unlike the other scene modes, ACAMERA_CONTROL_AE_MODE, ACAMERA_CONTROL_AWB_MODE, and ACAMERA_CONTROL_AF_MODE remain active when FACE_PRIORITY is set.

See also: ACAMERA_CONTROL_AE_MODE See also: ACAMERA_CONTROL_AF_MODE See also: ACAMERA_CONTROL_AWB_MODE See also: ACAMERA_STATISTICS_FACE_DETECT_MODE

ACAMERA_CONTROL_SCENE_MODE_FIREWORKS	
Optimized for nighttime photos of fireworks.

ACAMERA_CONTROL_SCENE_MODE_HDR	
Turn on a device-specific high dynamic range (HDR) mode.

In this scene mode, the camera device captures images that keep a larger range of scene illumination levels visible in the final image. For example, when taking a picture of a object in front of a bright window, both the object and the scene through the window may be visible when using HDR mode, while in normal AUTO mode, one or the other may be poorly exposed. As a tradeoff, HDR mode generally takes much longer to capture a single image, has no user control, and may have other artifacts depending on the HDR method used.

Therefore, HDR captures operate at a much slower rate than regular captures.

In this mode, on LIMITED or FULL devices, when a request is made with a ACAMERA_CONTROL_CAPTURE_INTENT of STILL_CAPTURE, the camera device will capture an image using a high dynamic range capture technique. On LEGACY devices, captures that target a JPEG-format output will be captured with HDR, and the capture intent is not relevant.

The HDR capture may involve the device capturing a burst of images internally and combining them into one, or it may involve the device using specialized high dynamic range capture hardware. In all cases, a single image is produced in response to a capture request submitted while in HDR mode.

Since substantial post-processing is generally needed to produce an HDR image, only YUV, PRIVATE, and JPEG outputs are supported for LIMITED/FULL device HDR captures, and only JPEG outputs are supported for LEGACY HDR captures. Using a RAW output for HDR capture is not supported.

Some devices may also support always-on HDR, which applies HDR processing at full frame rate. For these devices, intents other than STILL_CAPTURE will also produce an HDR output with no frame rate impact compared to normal operation, though the quality may be lower than for STILL_CAPTURE intents.

If SCENE_MODE_HDR is used with unsupported output types or capture intents, the images captured will be as if the SCENE_MODE was not enabled at all.

See also: ACAMERA_CONTROL_CAPTURE_INTENT

ACAMERA_CONTROL_SCENE_MODE_LANDSCAPE	
Optimized for photos of distant macroscopic objects.

ACAMERA_CONTROL_SCENE_MODE_NIGHT	
Optimized for low-light settings.

ACAMERA_CONTROL_SCENE_MODE_NIGHT_PORTRAIT	
Optimized for still photos of people in low-light settings.

ACAMERA_CONTROL_SCENE_MODE_PARTY	
Optimized for dim, indoor settings with multiple moving people.

ACAMERA_CONTROL_SCENE_MODE_PORTRAIT	
Optimized for still photos of people.

ACAMERA_CONTROL_SCENE_MODE_SNOW	
Optimized for bright, outdoor settings containing snow.

ACAMERA_CONTROL_SCENE_MODE_SPORTS	
Optimized for photos of quickly moving people.

Similar to ACTION.

ACAMERA_CONTROL_SCENE_MODE_STEADYPHOTO	
Optimized to avoid blurry photos due to small amounts of device motion (for example: due to hand shake).

ACAMERA_CONTROL_SCENE_MODE_SUNSET	
Optimized for scenes of the setting sun.

ACAMERA_CONTROL_SCENE_MODE_THEATRE	
Optimized for dim, indoor settings where flash must remain off.

acamera_metadata_enum_acamera_control_video_stabilization_mode
 acamera_metadata_enum_acamera_control_video_stabilization_mode
Properties
ACAMERA_CONTROL_VIDEO_STABILIZATION_MODE_OFF	
Video stabilization is disabled.

ACAMERA_CONTROL_VIDEO_STABILIZATION_MODE_ON	
Video stabilization is enabled.

ACAMERA_CONTROL_VIDEO_STABILIZATION_MODE_PREVIEW_STABILIZATION	
Preview stabilization, where the preview in addition to all other non-RAW streams are stabilized with the same quality of stabilization, is enabled. This mode aims to give clients a 'what you see is what you get' effect. In this mode, the FoV reduction will be a maximum of 20 % both horizontally and vertically (10% from left, right, top, bottom) for the given zoom ratio / crop region. The resultant FoV will also be the same across all processed streams (that have the same aspect ratio).

acamera_metadata_enum_acamera_depth_available_depth_stream_configurations
 acamera_metadata_enum_acamera_depth_available_depth_stream_configurations
Properties
ACAMERA_DEPTH_AVAILABLE_DEPTH_STREAM_CONFIGURATIONS_INPUT	
ACAMERA_DEPTH_AVAILABLE_DEPTH_STREAM_CONFIGURATIONS_OUTPUT	
acamera_metadata_enum_acamera_depth_available_depth_stream_configurations_maximum_resolution
 acamera_metadata_enum_acamera_depth_available_depth_stream_configurations_maximum_resolution
Properties
ACAMERA_DEPTH_AVAILABLE_DEPTH_STREAM_CONFIGURATIONS_MAXIMUM_RESOLUTION_INPUT	
ACAMERA_DEPTH_AVAILABLE_DEPTH_STREAM_CONFIGURATIONS_MAXIMUM_RESOLUTION_OUTPUT	
acamera_metadata_enum_acamera_depth_available_dynamic_depth_stream_configurations
 acamera_metadata_enum_acamera_depth_available_dynamic_depth_stream_configurations
Properties
ACAMERA_DEPTH_AVAILABLE_DYNAMIC_DEPTH_STREAM_CONFIGURATIONS_INPUT	
ACAMERA_DEPTH_AVAILABLE_DYNAMIC_DEPTH_STREAM_CONFIGURATIONS_OUTPUT	
acamera_metadata_enum_acamera_depth_available_dynamic_depth_stream_configurations_maximum_resolution
 acamera_metadata_enum_acamera_depth_available_dynamic_depth_stream_configurations_maximum_resolution
Properties
ACAMERA_DEPTH_AVAILABLE_DYNAMIC_DEPTH_STREAM_CONFIGURATIONS_MAXIMUM_RESOLUTION_INPUT	
ACAMERA_DEPTH_AVAILABLE_DYNAMIC_DEPTH_STREAM_CONFIGURATIONS_MAXIMUM_RESOLUTION_OUTPUT	
acamera_metadata_enum_acamera_depth_depth_is_exclusive
 acamera_metadata_enum_acamera_depth_depth_is_exclusive
Properties
ACAMERA_DEPTH_DEPTH_IS_EXCLUSIVE_FALSE	
ACAMERA_DEPTH_DEPTH_IS_EXCLUSIVE_TRUE	
acamera_metadata_enum_acamera_distortion_correction_mode
 acamera_metadata_enum_acamera_distortion_correction_mode
Properties
ACAMERA_DISTORTION_CORRECTION_MODE_FAST	
Lens distortion correction is applied without reducing frame rate relative to sensor output. It may be the same as OFF if distortion correction would reduce frame rate relative to sensor.

ACAMERA_DISTORTION_CORRECTION_MODE_HIGH_QUALITY	
High-quality distortion correction is applied, at the cost of possibly reduced frame rate relative to sensor output.

ACAMERA_DISTORTION_CORRECTION_MODE_OFF	
No distortion correction is applied.

acamera_metadata_enum_acamera_edge_mode
 acamera_metadata_enum_acamera_edge_mode
Properties
ACAMERA_EDGE_MODE_FAST	
Apply edge enhancement at a quality level that does not slow down frame rate relative to sensor output. It may be the same as OFF if edge enhancement will slow down frame rate relative to sensor.

ACAMERA_EDGE_MODE_HIGH_QUALITY	
Apply high-quality edge enhancement, at a cost of possibly reduced output frame rate.

ACAMERA_EDGE_MODE_OFF	
No edge enhancement is applied.

ACAMERA_EDGE_MODE_ZERO_SHUTTER_LAG	
Edge enhancement is applied at different levels for different output streams, based on resolution. Streams at maximum recording resolution (see ACameraDevice_createCaptureSession) or below have edge enhancement applied, while higher-resolution streams have no edge enhancement applied. The level of edge enhancement for low-resolution streams is tuned so that frame rate is not impacted, and the quality is equal to or better than FAST (since it is only applied to lower-resolution outputs, quality may improve from FAST).

This mode is intended to be used by applications operating in a zero-shutter-lag mode with YUV or PRIVATE reprocessing, where the application continuously captures high-resolution intermediate buffers into a circular buffer, from which a final image is produced via reprocessing when a user takes a picture. For such a use case, the high-resolution buffers must not have edge enhancement applied to maximize efficiency of preview and to avoid double-applying enhancement when reprocessed, while low-resolution buffers (used for recording or preview, generally) need edge enhancement applied for reasonable preview quality.

This mode is guaranteed to be supported by devices that support either the YUV_REPROCESSING or PRIVATE_REPROCESSING capabilities (ACAMERA_REQUEST_AVAILABLE_CAPABILITIES lists either of those capabilities) and it will be the default mode for CAMERA3_TEMPLATE_ZERO_SHUTTER_LAG template.

See also: ACAMERA_REQUEST_AVAILABLE_CAPABILITIES

acamera_metadata_enum_acamera_flash_info_available
 acamera_metadata_enum_acamera_flash_info_available
Properties
ACAMERA_FLASH_INFO_AVAILABLE_FALSE	
ACAMERA_FLASH_INFO_AVAILABLE_TRUE	
acamera_metadata_enum_acamera_flash_mode
 acamera_metadata_enum_acamera_flash_mode
Properties
ACAMERA_FLASH_MODE_OFF	
Do not fire the flash for this capture.

ACAMERA_FLASH_MODE_SINGLE	
If the flash is available and charged, fire flash for this capture.

ACAMERA_FLASH_MODE_TORCH	
Transition flash to continuously on.

acamera_metadata_enum_acamera_flash_state
 acamera_metadata_enum_acamera_flash_state
Properties
ACAMERA_FLASH_STATE_CHARGING	
Flash is charging and cannot be fired.

ACAMERA_FLASH_STATE_FIRED	
Flash fired for this capture.

ACAMERA_FLASH_STATE_PARTIAL	
Flash partially illuminated this frame.

This is usually due to the next or previous frame having the flash fire, and the flash spilling into this capture due to hardware limitations.

ACAMERA_FLASH_STATE_READY	
Flash is ready to fire.

ACAMERA_FLASH_STATE_UNAVAILABLE	
No flash on camera.

acamera_metadata_enum_acamera_heic_available_heic_stream_configurations
 acamera_metadata_enum_acamera_heic_available_heic_stream_configurations
Properties
ACAMERA_HEIC_AVAILABLE_HEIC_STREAM_CONFIGURATIONS_INPUT	
ACAMERA_HEIC_AVAILABLE_HEIC_STREAM_CONFIGURATIONS_OUTPUT	
acamera_metadata_enum_acamera_heic_available_heic_stream_configurations_maximum_resolution
 acamera_metadata_enum_acamera_heic_available_heic_stream_configurations_maximum_resolution
Properties
ACAMERA_HEIC_AVAILABLE_HEIC_STREAM_CONFIGURATIONS_MAXIMUM_RESOLUTION_INPUT	
ACAMERA_HEIC_AVAILABLE_HEIC_STREAM_CONFIGURATIONS_MAXIMUM_RESOLUTION_OUTPUT	
acamera_metadata_enum_acamera_hot_pixel_mode
 acamera_metadata_enum_acamera_hot_pixel_mode
Properties
ACAMERA_HOT_PIXEL_MODE_FAST	
Hot pixel correction is applied, without reducing frame rate relative to sensor raw output.

The hotpixel map may be returned in ACAMERA_STATISTICS_HOT_PIXEL_MAP.

See also: ACAMERA_STATISTICS_HOT_PIXEL_MAP

ACAMERA_HOT_PIXEL_MODE_HIGH_QUALITY	
High-quality hot pixel correction is applied, at a cost of possibly reduced frame rate relative to sensor raw output.

The hotpixel map may be returned in ACAMERA_STATISTICS_HOT_PIXEL_MAP.

See also: ACAMERA_STATISTICS_HOT_PIXEL_MAP

ACAMERA_HOT_PIXEL_MODE_OFF	
No hot pixel correction is applied.

The frame rate must not be reduced relative to sensor raw output for this option.

The hotpixel map may be returned in ACAMERA_STATISTICS_HOT_PIXEL_MAP.

See also: ACAMERA_STATISTICS_HOT_PIXEL_MAP

acamera_metadata_enum_acamera_info_supported_hardware_level
 acamera_metadata_enum_acamera_info_supported_hardware_level
Properties
ACAMERA_INFO_SUPPORTED_HARDWARE_LEVEL_3	
This camera device is capable of YUV reprocessing and RAW data capture, in addition to FULL-level capabilities.

The stream configurations listed in the LEVEL_3, RAW, FULL, LEGACY and LIMITED tables in the createCaptureSession documentation are guaranteed to be supported.

The following additional capabilities are guaranteed to be supported:

YUV_REPROCESSING capability (ACAMERA_REQUEST_AVAILABLE_CAPABILITIES contains YUV_REPROCESSING)
RAW capability (ACAMERA_REQUEST_AVAILABLE_CAPABILITIES contains RAW)
See also: ACAMERA_REQUEST_AVAILABLE_CAPABILITIES

ACAMERA_INFO_SUPPORTED_HARDWARE_LEVEL_EXTERNAL	
This camera device is backed by an external camera connected to this Android device.

The device has capability identical to a LIMITED level device, with the following exceptions:

The device may not report lens/sensor related information such as
ACAMERA_LENS_FOCAL_LENGTH
ACAMERA_LENS_INFO_HYPERFOCAL_DISTANCE
ACAMERA_SENSOR_INFO_PHYSICAL_SIZE
ACAMERA_SENSOR_INFO_WHITE_LEVEL
ACAMERA_SENSOR_BLACK_LEVEL_PATTERN
ACAMERA_SENSOR_INFO_COLOR_FILTER_ARRANGEMENT
ACAMERA_SENSOR_ROLLING_SHUTTER_SKEW
The device will report 0 for ACAMERA_SENSOR_ORIENTATION
The device has less guarantee on stable framerate, as the framerate partly depends on the external camera being used.
See also: ACAMERA_LENS_FOCAL_LENGTH See also: ACAMERA_LENS_INFO_HYPERFOCAL_DISTANCE See also: ACAMERA_SENSOR_BLACK_LEVEL_PATTERN See also: ACAMERA_SENSOR_INFO_COLOR_FILTER_ARRANGEMENT See also: ACAMERA_SENSOR_INFO_PHYSICAL_SIZE See also: ACAMERA_SENSOR_INFO_WHITE_LEVEL See also: ACAMERA_SENSOR_ORIENTATION See also: ACAMERA_SENSOR_ROLLING_SHUTTER_SKEW

ACAMERA_INFO_SUPPORTED_HARDWARE_LEVEL_FULL	
This camera device is capable of supporting advanced imaging applications.

The stream configurations listed in the FULL, LEGACY and LIMITED tables in the createCaptureSession documentation are guaranteed to be supported.

A FULL device will support below capabilities:

BURST_CAPTURE capability (ACAMERA_REQUEST_AVAILABLE_CAPABILITIES contains BURST_CAPTURE)
Per frame control (ACAMERA_SYNC_MAX_LATENCY == PER_FRAME_CONTROL)
Manual sensor control (ACAMERA_REQUEST_AVAILABLE_CAPABILITIES contains MANUAL_SENSOR)
Manual post-processing control (ACAMERA_REQUEST_AVAILABLE_CAPABILITIES contains MANUAL_POST_PROCESSING)
The required exposure time range defined in ACAMERA_SENSOR_INFO_EXPOSURE_TIME_RANGE
The required maxFrameDuration defined in ACAMERA_SENSOR_INFO_MAX_FRAME_DURATION
Note: Pre-API level 23, FULL devices also supported arbitrary cropping region (ACAMERA_SCALER_CROPPING_TYPE == FREEFORM); this requirement was relaxed in API level 23, and FULL devices may only support CENTERED cropping.

See also: ACAMERA_REQUEST_AVAILABLE_CAPABILITIES See also: ACAMERA_SCALER_CROPPING_TYPE See also: ACAMERA_SENSOR_INFO_EXPOSURE_TIME_RANGE See also: ACAMERA_SENSOR_INFO_MAX_FRAME_DURATION See also: ACAMERA_SYNC_MAX_LATENCY

ACAMERA_INFO_SUPPORTED_HARDWARE_LEVEL_LEGACY	
This camera device is running in backward compatibility mode.

Only the stream configurations listed in the LEGACY table in the createCaptureSession documentation are supported.

A LEGACY device does not support per-frame control, manual sensor control, manual post-processing, arbitrary cropping regions, and has relaxed performance constraints. No additional capabilities beyond BACKWARD_COMPATIBLE will ever be listed by a LEGACY device in ACAMERA_REQUEST_AVAILABLE_CAPABILITIES.

In addition, the ACAMERA_CONTROL_AE_PRECAPTURE_TRIGGER is not functional on LEGACY devices. Instead, every request that includes a JPEG-format output target is treated as triggering a still capture, internally executing a precapture trigger. This may fire the flash for flash power metering during precapture, and then fire the flash for the final capture, if a flash is available on the device and the AE mode is set to enable the flash.

Devices that initially shipped with Android version Q or newer will not include any LEGACY-level devices.

See also: ACAMERA_CONTROL_AE_PRECAPTURE_TRIGGER See also: ACAMERA_REQUEST_AVAILABLE_CAPABILITIES

ACAMERA_INFO_SUPPORTED_HARDWARE_LEVEL_LIMITED	
This camera device does not have enough capabilities to qualify as a FULL device or better.

Only the stream configurations listed in the LEGACY and LIMITED tables in the createCaptureSession documentation are guaranteed to be supported.

All LIMITED devices support the BACKWARDS_COMPATIBLE capability, indicating basic support for color image capture. The only exception is that the device may alternatively support only the DEPTH_OUTPUT capability, if it can only output depth measurements and not color images.

LIMITED devices and above require the use of ACAMERA_CONTROL_AE_PRECAPTURE_TRIGGER to lock exposure metering (and calculate flash power, for cameras with flash) before capturing a high-quality still image.

A LIMITED device that only lists the BACKWARDS_COMPATIBLE capability is only required to support full-automatic operation and post-processing (OFF is not supported for ACAMERA_CONTROL_AE_MODE, ACAMERA_CONTROL_AF_MODE, or ACAMERA_CONTROL_AWB_MODE)

Additional capabilities may optionally be supported by a LIMITED-level device, and can be checked for in ACAMERA_REQUEST_AVAILABLE_CAPABILITIES.

See also: ACAMERA_CONTROL_AE_MODE See also: ACAMERA_CONTROL_AE_PRECAPTURE_TRIGGER See also: ACAMERA_CONTROL_AF_MODE See also: ACAMERA_CONTROL_AWB_MODE See also: ACAMERA_REQUEST_AVAILABLE_CAPABILITIES

acamera_metadata_enum_acamera_lens_facing
 acamera_metadata_enum_acamera_lens_facing
Properties
ACAMERA_LENS_FACING_BACK	
The camera device faces the opposite direction as the device's screen.

ACAMERA_LENS_FACING_EXTERNAL	
The camera device is an external camera, and has no fixed facing relative to the device's screen.

ACAMERA_LENS_FACING_FRONT	
The camera device faces the same direction as the device's screen.

acamera_metadata_enum_acamera_lens_info_focus_distance_calibration
 acamera_metadata_enum_acamera_lens_info_focus_distance_calibration
Properties
ACAMERA_LENS_INFO_FOCUS_DISTANCE_CALIBRATION_APPROXIMATE	
The lens focus distance is measured in diopters.

However, setting the lens to the same focus distance on separate occasions may result in a different real focus distance, depending on factors such as the orientation of the device, the age of the focusing mechanism, and the device temperature.

ACAMERA_LENS_INFO_FOCUS_DISTANCE_CALIBRATION_CALIBRATED	
The lens focus distance is measured in diopters, and is calibrated.

The lens mechanism is calibrated so that setting the same focus distance is repeatable on multiple occasions with good accuracy, and the focus distance corresponds to the real physical distance to the plane of best focus.

ACAMERA_LENS_INFO_FOCUS_DISTANCE_CALIBRATION_UNCALIBRATED	
The lens focus distance is not accurate, and the units used for ACAMERA_LENS_FOCUS_DISTANCE do not correspond to any physical units.

Setting the lens to the same focus distance on separate occasions may result in a different real focus distance, depending on factors such as the orientation of the device, the age of the focusing mechanism, and the device temperature. The focus distance value will still be in the range of [0, ACAMERA_LENS_INFO_MINIMUM_FOCUS_DISTANCE], where 0 represents the farthest focus.

See also: ACAMERA_LENS_FOCUS_DISTANCE See also: ACAMERA_LENS_INFO_MINIMUM_FOCUS_DISTANCE

acamera_metadata_enum_acamera_lens_optical_stabilization_mode
 acamera_metadata_enum_acamera_lens_optical_stabilization_mode
Properties
ACAMERA_LENS_OPTICAL_STABILIZATION_MODE_OFF	
Optical stabilization is unavailable.

ACAMERA_LENS_OPTICAL_STABILIZATION_MODE_ON	
Optical stabilization is enabled.

acamera_metadata_enum_acamera_lens_pose_reference
 acamera_metadata_enum_acamera_lens_pose_reference
Properties
ACAMERA_LENS_POSE_REFERENCE_AUTOMOTIVE	
The value of ACAMERA_LENS_POSE_TRANSLATION is relative to the origin of the automotive sensor coordinate system, which is at the center of the rear axle.

See also: ACAMERA_LENS_POSE_TRANSLATION

ACAMERA_LENS_POSE_REFERENCE_GYROSCOPE	
The value of ACAMERA_LENS_POSE_TRANSLATION is relative to the position of the primary gyroscope of this Android device.

See also: ACAMERA_LENS_POSE_TRANSLATION

ACAMERA_LENS_POSE_REFERENCE_PRIMARY_CAMERA	
The value of ACAMERA_LENS_POSE_TRANSLATION is relative to the optical center of the largest camera device facing the same direction as this camera.

This is the default value for API levels before Android P.

See also: ACAMERA_LENS_POSE_TRANSLATION

ACAMERA_LENS_POSE_REFERENCE_UNDEFINED	
The camera device cannot represent the values of ACAMERA_LENS_POSE_TRANSLATION and ACAMERA_LENS_POSE_ROTATION accurately enough. One such example is a camera device on the cover of a foldable phone: in order to measure the pose translation and rotation, some kind of hinge position sensor would be needed.

The value of ACAMERA_LENS_POSE_TRANSLATION must be all zeros, and ACAMERA_LENS_POSE_ROTATION must be values matching its default facing.

See also: ACAMERA_LENS_POSE_ROTATION See also: ACAMERA_LENS_POSE_TRANSLATION

acamera_metadata_enum_acamera_lens_state
 acamera_metadata_enum_acamera_lens_state
Properties
ACAMERA_LENS_STATE_MOVING	
One or several of the lens parameters (ACAMERA_LENS_FOCAL_LENGTH, ACAMERA_LENS_FOCUS_DISTANCE, ACAMERA_LENS_FILTER_DENSITY or ACAMERA_LENS_APERTURE) is currently changing.

See also: ACAMERA_LENS_APERTURE See also: ACAMERA_LENS_FILTER_DENSITY See also: ACAMERA_LENS_FOCAL_LENGTH See also: ACAMERA_LENS_FOCUS_DISTANCE

ACAMERA_LENS_STATE_STATIONARY	
The lens parameters (ACAMERA_LENS_FOCAL_LENGTH, ACAMERA_LENS_FOCUS_DISTANCE, ACAMERA_LENS_FILTER_DENSITY and ACAMERA_LENS_APERTURE) are not changing.

See also: ACAMERA_LENS_APERTURE See also: ACAMERA_LENS_FILTER_DENSITY See also: ACAMERA_LENS_FOCAL_LENGTH See also: ACAMERA_LENS_FOCUS_DISTANCE

acamera_metadata_enum_acamera_logical_multi_camera_sensor_sync_type
 acamera_metadata_enum_acamera_logical_multi_camera_sensor_sync_type
Properties
ACAMERA_LOGICAL_MULTI_CAMERA_SENSOR_SYNC_TYPE_APPROXIMATE	
A software mechanism is used to synchronize between the physical cameras. As a result, the timestamp of an image from a physical stream is only an approximation of the image sensor start-of-exposure time.

ACAMERA_LOGICAL_MULTI_CAMERA_SENSOR_SYNC_TYPE_CALIBRATED	
The camera device supports frame timestamp synchronization at the hardware level, and the timestamp of a physical stream image accurately reflects its start-of-exposure time.

acamera_metadata_enum_acamera_noise_reduction_mode
 acamera_metadata_enum_acamera_noise_reduction_mode
Properties
ACAMERA_NOISE_REDUCTION_MODE_FAST	
Noise reduction is applied without reducing frame rate relative to sensor output. It may be the same as OFF if noise reduction will reduce frame rate relative to sensor.

ACAMERA_NOISE_REDUCTION_MODE_HIGH_QUALITY	
High-quality noise reduction is applied, at the cost of possibly reduced frame rate relative to sensor output.

ACAMERA_NOISE_REDUCTION_MODE_MINIMAL	
MINIMAL noise reduction is applied without reducing frame rate relative to sensor output.

ACAMERA_NOISE_REDUCTION_MODE_OFF	
No noise reduction is applied.

ACAMERA_NOISE_REDUCTION_MODE_ZERO_SHUTTER_LAG	
Noise reduction is applied at different levels for different output streams, based on resolution. Streams at maximum recording resolution (see ACameraDevice_createCaptureSession) or below have noise reduction applied, while higher-resolution streams have MINIMAL (if supported) or no noise reduction applied (if MINIMAL is not supported.) The degree of noise reduction for low-resolution streams is tuned so that frame rate is not impacted, and the quality is equal to or better than FAST (since it is only applied to lower-resolution outputs, quality may improve from FAST).

This mode is intended to be used by applications operating in a zero-shutter-lag mode with YUV or PRIVATE reprocessing, where the application continuously captures high-resolution intermediate buffers into a circular buffer, from which a final image is produced via reprocessing when a user takes a picture. For such a use case, the high-resolution buffers must not have noise reduction applied to maximize efficiency of preview and to avoid over-applying noise filtering when reprocessing, while low-resolution buffers (used for recording or preview, generally) need noise reduction applied for reasonable preview quality.

This mode is guaranteed to be supported by devices that support either the YUV_REPROCESSING or PRIVATE_REPROCESSING capabilities (ACAMERA_REQUEST_AVAILABLE_CAPABILITIES lists either of those capabilities) and it will be the default mode for CAMERA3_TEMPLATE_ZERO_SHUTTER_LAG template.

See also: ACAMERA_REQUEST_AVAILABLE_CAPABILITIES

acamera_metadata_enum_acamera_request_available_capabilities
 acamera_metadata_enum_acamera_request_available_capabilities
Properties
ACAMERA_REQUEST_AVAILABLE_CAPABILITIES_BACKWARD_COMPATIBLE	
The minimal set of capabilities that every camera device (regardless of ACAMERA_INFO_SUPPORTED_HARDWARE_LEVEL) supports.

This capability is listed by all normal devices, and indicates that the camera device has a feature set that's comparable to the baseline requirements for the older android.hardware.Camera API.

Devices with the DEPTH_OUTPUT capability might not list this capability, indicating that they support only depth measurement, not standard color output.

See also: ACAMERA_INFO_SUPPORTED_HARDWARE_LEVEL

ACAMERA_REQUEST_AVAILABLE_CAPABILITIES_BURST_CAPTURE	
The camera device supports capturing high-resolution images at >= 20 frames per second, in at least the uncompressed YUV format, when post-processing settings are set to FAST. Additionally, all image resolutions less than 24 megapixels can be captured at >= 10 frames per second. Here, 'high resolution' means at least 8 megapixels, or the maximum resolution of the device, whichever is smaller.

More specifically, this means that at least one output AIMAGE_FORMAT_YUV_420_888 size listed in ACAMERA_SCALER_AVAILABLE_STREAM_CONFIGURATIONS is larger or equal to the 'high resolution' defined above, and can be captured at at least 20 fps. For the largest AIMAGE_FORMAT_YUV_420_888 size listed in ACAMERA_SCALER_AVAILABLE_STREAM_CONFIGURATIONS, camera device can capture this size for at least 10 frames per second if the size is less than 24 megapixels. Also the ACAMERA_CONTROL_AE_AVAILABLE_TARGET_FPS_RANGES entry lists at least one FPS range where the minimum FPS is >= 1 / minimumFrameDuration for the largest YUV_420_888 size.

If the device supports the AIMAGE_FORMAT_RAW10, AIMAGE_FORMAT_RAW12, AIMAGE_FORMAT_Y8, then those can also be captured at the same rate as the maximum-size YUV_420_888 resolution is.

In addition, the ACAMERA_SYNC_MAX_LATENCY field is guaranteed to have a value between 0 and 4, inclusive. ACAMERA_CONTROL_AE_LOCK_AVAILABLE and ACAMERA_CONTROL_AWB_LOCK_AVAILABLE are also guaranteed to be true so burst capture with these two locks ON yields consistent image output.

See also: ACAMERA_CONTROL_AE_AVAILABLE_TARGET_FPS_RANGES See also: ACAMERA_CONTROL_AE_LOCK_AVAILABLE See also: ACAMERA_CONTROL_AWB_LOCK_AVAILABLE See also: ACAMERA_SYNC_MAX_LATENCY

ACAMERA_REQUEST_AVAILABLE_CAPABILITIES_DEPTH_OUTPUT	
The camera device can produce depth measurements from its field of view.

This capability requires the camera device to support the following:

AIMAGE_FORMAT_DEPTH16 is supported as an output format.
AIMAGE_FORMAT_DEPTH_POINT_CLOUD is optionally supported as an output format.
This camera device, and all camera devices with the same ACAMERA_LENS_FACING, will list the following calibration metadata entries in both ACameraManager_getCameraCharacteristics and ACameraCaptureSession_captureCallback_result:
ACAMERA_LENS_POSE_TRANSLATION
ACAMERA_LENS_POSE_ROTATION
ACAMERA_LENS_INTRINSIC_CALIBRATION
ACAMERA_LENS_DISTORTION
The ACAMERA_DEPTH_DEPTH_IS_EXCLUSIVE entry is listed by this device.
As of Android P, the ACAMERA_LENS_POSE_REFERENCE entry is listed by this device.
A LIMITED camera with only the DEPTH_OUTPUT capability does not have to support normal YUV_420_888, Y8, JPEG, and PRIV-format outputs. It only has to support the DEPTH16 format.
Generally, depth output operates at a slower frame rate than standard color capture, so the DEPTH16 and DEPTH_POINT_CLOUD formats will commonly have a stall duration that should be accounted for (see ACAMERA_DEPTH_AVAILABLE_DEPTH_STALL_DURATIONS). On a device that supports both depth and color-based output, to enable smooth preview, using a repeating burst is recommended, where a depth-output target is only included once every N frames, where N is the ratio between preview output rate and depth output rate, including depth stall time.

See also: ACAMERA_DEPTH_DEPTH_IS_EXCLUSIVE See also: ACAMERA_LENS_DISTORTION See also: ACAMERA_LENS_FACING See also: ACAMERA_LENS_INTRINSIC_CALIBRATION See also: ACAMERA_LENS_POSE_REFERENCE See also: ACAMERA_LENS_POSE_ROTATION See also: ACAMERA_LENS_POSE_TRANSLATION

ACAMERA_REQUEST_AVAILABLE_CAPABILITIES_LOGICAL_MULTI_CAMERA	
The camera device is a logical camera backed by two or more physical cameras.

In API level 28, the physical cameras must also be exposed to the application via CameraManager::getCameraIdList.

Starting from API level 29:

Some or all physical cameras may not be independently exposed to the application, in which case the physical camera IDs will not be available in CameraManager::getCameraIdList. But the application can still query the physical cameras' characteristics by calling CameraManager::getCameraCharacteristics.
If a physical camera is hidden from camera ID list, the mandatory stream combinations for that physical camera must be supported through the logical camera using physical streams. One exception is that in API level 30, a physical camera may become unavailable via ACameraManager_PhysicalCameraAvailabilityCallback callback.
Combinations of logical and physical streams, or physical streams from different physical cameras are not guaranteed. However, if the camera device supports ACameraDevice_isSessionConfigurationSupported, application must be able to query whether a stream combination involving physical streams is supported by calling ACameraDevice_isSessionConfigurationSupported.

Camera application shouldn't assume that there are at most 1 rear camera and 1 front camera in the system. For an application that switches between front and back cameras, the recommendation is to switch between the first rear camera and the first front camera in the list of supported camera devices.

This capability requires the camera device to support the following:

The IDs of underlying physical cameras are returned via CameraCharacteristics::getPhysicalCameraIds.
This camera device must list static metadata ACAMERA_LOGICAL_MULTI_CAMERA_SENSOR_SYNC_TYPE in CameraCharacteristics.
The underlying physical cameras' static metadata must list the following entries, so that the application can correlate pixels from the physical streams:
ACAMERA_LENS_POSE_REFERENCE
ACAMERA_LENS_POSE_ROTATION
ACAMERA_LENS_POSE_TRANSLATION
ACAMERA_LENS_INTRINSIC_CALIBRATION
ACAMERA_LENS_DISTORTION
The SENSOR_INFO_TIMESTAMP_SOURCE of the logical device and physical devices must be the same.
The logical camera must be LIMITED or higher device.
A logical camera device's dynamic metadata may contain ACAMERA_LOGICAL_MULTI_CAMERA_ACTIVE_PHYSICAL_ID to notify the application of the current active physical camera Id. An active physical camera is the physical camera from which the logical camera's main image data outputs (YUV or RAW) and metadata come from. In addition, this serves as an indication which physical camera is used to output to a RAW stream, or in case only physical cameras support RAW, which physical RAW stream the application should request.

Logical camera's static metadata tags below describe the default active physical camera. An active physical camera is default if it's used when application directly uses requests built from a template. All templates will default to the same active physical camera.

ACAMERA_SENSOR_INFO_SENSITIVITY_RANGE
ACAMERA_SENSOR_INFO_COLOR_FILTER_ARRANGEMENT
ACAMERA_SENSOR_INFO_EXPOSURE_TIME_RANGE
ACAMERA_SENSOR_INFO_MAX_FRAME_DURATION
ACAMERA_SENSOR_INFO_PHYSICAL_SIZE
ACAMERA_SENSOR_INFO_WHITE_LEVEL
ACAMERA_SENSOR_INFO_LENS_SHADING_APPLIED
ACAMERA_SENSOR_REFERENCE_ILLUMINANT1
ACAMERA_SENSOR_REFERENCE_ILLUMINANT2
ACAMERA_SENSOR_CALIBRATION_TRANSFORM1
ACAMERA_SENSOR_CALIBRATION_TRANSFORM2
ACAMERA_SENSOR_COLOR_TRANSFORM1
ACAMERA_SENSOR_COLOR_TRANSFORM2
ACAMERA_SENSOR_FORWARD_MATRIX1
ACAMERA_SENSOR_FORWARD_MATRIX2
ACAMERA_SENSOR_BLACK_LEVEL_PATTERN
ACAMERA_SENSOR_MAX_ANALOG_SENSITIVITY
ACAMERA_SENSOR_OPTICAL_BLACK_REGIONS
ACAMERA_SENSOR_AVAILABLE_TEST_PATTERN_MODES
ACAMERA_LENS_INFO_HYPERFOCAL_DISTANCE
ACAMERA_LENS_INFO_MINIMUM_FOCUS_DISTANCE
ACAMERA_LENS_INFO_FOCUS_DISTANCE_CALIBRATION
ACAMERA_LENS_POSE_ROTATION
ACAMERA_LENS_POSE_TRANSLATION
ACAMERA_LENS_INTRINSIC_CALIBRATION
ACAMERA_LENS_POSE_REFERENCE
ACAMERA_LENS_DISTORTION
The field of view of non-RAW physical streams must not be smaller than that of the non-RAW logical streams, or the maximum field-of-view of the physical camera, whichever is smaller. The application should check the physical capture result metadata for how the physical streams are cropped or zoomed. More specifically, given the physical camera result metadata, the effective horizontal field-of-view of the physical camera is:

fov = 2 * atan2(cropW * sensorW / (2 * zoomRatio * activeArrayW), focalLength)
where the equation parameters are the physical camera's crop region width, physical sensor width, zoom ratio, active array width, and focal length respectively. Typically the physical stream of active physical camera has the same field-of-view as the logical streams. However, the same may not be true for physical streams from non-active physical cameras. For example, if the logical camera has a wide-ultrawide configuration where the wide lens is the default, when the crop region is set to the logical camera's active array size, (and the zoom ratio set to 1.0 starting from Android 11), a physical stream for the ultrawide camera may prefer outputting images with larger field-of-view than that of the wide camera for better stereo matching margin or more robust motion tracking. At the same time, the physical non-RAW streams' field of view must not be smaller than the requested crop region and zoom ratio, as long as it's within the physical lens' capability. For example, for a logical camera with wide-tele lens configuration where the wide lens is the default, if the logical camera's crop region is set to maximum size, and zoom ratio set to 1.0, the physical stream for the tele lens will be configured to its maximum size crop region (no zoom).

Deprecated: Prior to Android 11, the field of view of all non-RAW physical streams cannot be larger than that of non-RAW logical streams. If the logical camera has a wide-ultrawide lens configuration where the wide lens is the default, when the logical camera's crop region is set to maximum size, the FOV of the physical streams for the ultrawide lens will be the same as the logical stream, by making the crop region smaller than its active array size to compensate for the smaller focal length.

For a logical camera, typically the underlying physical cameras have different RAW capabilities (such as resolution or CFA pattern). There are two ways for the application to capture RAW images from the logical camera:

If the logical camera has RAW capability, the application can create and use RAW streams in the same way as before. In case a RAW stream is configured, to maintain backward compatibility, the camera device makes sure the default active physical camera remains active and does not switch to other physical cameras. (One exception is that, if the logical camera consists of identical image sensors and advertises multiple focalLength due to different lenses, the camera device may generate RAW images from different physical cameras based on the focalLength being set by the application.) This backward-compatible approach usually results in loss of optical zoom, to telephoto lens or to ultrawide lens.
Alternatively, if supported by the device, MultiResolutionImageReader can be used to capture RAW images from one of the underlying physical cameras ( depending on current zoom level). Because different physical cameras may have different RAW characteristics, the application needs to use the characteristics and result metadata of the active physical camera for the relevant RAW metadata.
The capture request and result metadata tags required for backward compatible camera functionalities will be solely based on the logical camera capability. On the other hand, the use of manual capture controls (sensor or post-processing) with a logical camera may result in unexpected behavior when the HAL decides to switch between physical cameras with different characteristics under the hood. For example, when the application manually sets exposure time and sensitivity while zooming in, the brightness of the camera images may suddenly change because HAL switches from one physical camera to the other.

See also: ACAMERA_LENS_DISTORTION See also: ACAMERA_LENS_INFO_FOCUS_DISTANCE_CALIBRATION See also: ACAMERA_LENS_INFO_HYPERFOCAL_DISTANCE See also: ACAMERA_LENS_INFO_MINIMUM_FOCUS_DISTANCE See also: ACAMERA_LENS_INTRINSIC_CALIBRATION See also: ACAMERA_LENS_POSE_REFERENCE See also: ACAMERA_LENS_POSE_ROTATION See also: ACAMERA_LENS_POSE_TRANSLATION See also: ACAMERA_LOGICAL_MULTI_CAMERA_ACTIVE_PHYSICAL_ID See also: ACAMERA_LOGICAL_MULTI_CAMERA_SENSOR_SYNC_TYPE See also: ACAMERA_SENSOR_AVAILABLE_TEST_PATTERN_MODES See also: ACAMERA_SENSOR_BLACK_LEVEL_PATTERN See also: ACAMERA_SENSOR_CALIBRATION_TRANSFORM1 See also: ACAMERA_SENSOR_CALIBRATION_TRANSFORM2 See also: ACAMERA_SENSOR_COLOR_TRANSFORM1 See also: ACAMERA_SENSOR_COLOR_TRANSFORM2 See also: ACAMERA_SENSOR_FORWARD_MATRIX1 See also: ACAMERA_SENSOR_FORWARD_MATRIX2 See also: ACAMERA_SENSOR_INFO_COLOR_FILTER_ARRANGEMENT See also: ACAMERA_SENSOR_INFO_EXPOSURE_TIME_RANGE See also: ACAMERA_SENSOR_INFO_LENS_SHADING_APPLIED See also: ACAMERA_SENSOR_INFO_MAX_FRAME_DURATION See also: ACAMERA_SENSOR_INFO_PHYSICAL_SIZE See also: ACAMERA_SENSOR_INFO_SENSITIVITY_RANGE See also: ACAMERA_SENSOR_INFO_WHITE_LEVEL See also: ACAMERA_SENSOR_MAX_ANALOG_SENSITIVITY See also: ACAMERA_SENSOR_OPTICAL_BLACK_REGIONS See also: ACAMERA_SENSOR_REFERENCE_ILLUMINANT1 See also: ACAMERA_SENSOR_REFERENCE_ILLUMINANT2

ACAMERA_REQUEST_AVAILABLE_CAPABILITIES_MANUAL_POST_PROCESSING	
The camera device post-processing stages can be manually controlled. The camera device supports basic manual control of the image post-processing stages. This means the following controls are guaranteed to be supported:

Manual tonemap control
android.tonemap.curve
ACAMERA_TONEMAP_MODE
ACAMERA_TONEMAP_MAX_CURVE_POINTS
ACAMERA_TONEMAP_GAMMA
ACAMERA_TONEMAP_PRESET_CURVE
Manual white balance control
ACAMERA_COLOR_CORRECTION_TRANSFORM
ACAMERA_COLOR_CORRECTION_GAINS
Manual lens shading map control
ACAMERA_SHADING_MODE
ACAMERA_STATISTICS_LENS_SHADING_MAP_MODE
ACAMERA_STATISTICS_LENS_SHADING_MAP
ACAMERA_LENS_INFO_SHADING_MAP_SIZE
Manual aberration correction control (if aberration correction is supported)
ACAMERA_COLOR_CORRECTION_ABERRATION_MODE
ACAMERA_COLOR_CORRECTION_AVAILABLE_ABERRATION_MODES
Auto white balance lock
ACAMERA_CONTROL_AWB_LOCK
If auto white balance is enabled, then the camera device will accurately report the values applied by AWB in the result.

A given camera device may also support additional post-processing controls, but this capability only covers the above list of controls.

For camera devices with LOGICAL_MULTI_CAMERA capability, when underlying active physical camera switches, tonemap, white balance, and shading map may change even if awb is locked. However, the overall post-processing experience for users will be consistent. Refer to LOGICAL_MULTI_CAMERA capability for details.

See also: ACAMERA_COLOR_CORRECTION_ABERRATION_MODE See also: ACAMERA_COLOR_CORRECTION_AVAILABLE_ABERRATION_MODES See also: ACAMERA_COLOR_CORRECTION_GAINS See also: ACAMERA_COLOR_CORRECTION_TRANSFORM See also: ACAMERA_CONTROL_AWB_LOCK See also: ACAMERA_LENS_INFO_SHADING_MAP_SIZE See also: ACAMERA_SHADING_MODE See also: ACAMERA_STATISTICS_LENS_SHADING_MAP See also: ACAMERA_STATISTICS_LENS_SHADING_MAP_MODE See also: ACAMERA_TONEMAP_GAMMA See also: ACAMERA_TONEMAP_MAX_CURVE_POINTS See also: ACAMERA_TONEMAP_MODE See also: ACAMERA_TONEMAP_PRESET_CURVE

ACAMERA_REQUEST_AVAILABLE_CAPABILITIES_MANUAL_SENSOR	
The camera device can be manually controlled (3A algorithms such as auto-exposure, and auto-focus can be bypassed). The camera device supports basic manual control of the sensor image acquisition related stages. This means the following controls are guaranteed to be supported:

Manual frame duration control
ACAMERA_SENSOR_FRAME_DURATION
ACAMERA_SENSOR_INFO_MAX_FRAME_DURATION
Manual exposure control
ACAMERA_SENSOR_EXPOSURE_TIME
ACAMERA_SENSOR_INFO_EXPOSURE_TIME_RANGE
Manual sensitivity control
ACAMERA_SENSOR_SENSITIVITY
ACAMERA_SENSOR_INFO_SENSITIVITY_RANGE
Manual lens control (if the lens is adjustable)
ACAMERA_LENS_*
Manual flash control (if a flash unit is present)
ACAMERA_FLASH_*
Manual black level locking
ACAMERA_BLACK_LEVEL_LOCK
Auto exposure lock
ACAMERA_CONTROL_AE_LOCK
If any of the above 3A algorithms are enabled, then the camera device will accurately report the values applied by 3A in the result.

A given camera device may also support additional manual sensor controls, but this capability only covers the above list of controls.

If this is supported, android.scaler.streamConfigurationMap will additionally return a min frame duration that is greater than zero for each supported size-format combination.

For camera devices with LOGICAL_MULTI_CAMERA capability, when the underlying active physical camera switches, exposureTime, sensitivity, and lens properties may change even if AE/AF is locked. However, the overall auto exposure and auto focus experience for users will be consistent. Refer to LOGICAL_MULTI_CAMERA capability for details.

See also: ACAMERA_BLACK_LEVEL_LOCK See also: ACAMERA_CONTROL_AE_LOCK See also: ACAMERA_SENSOR_EXPOSURE_TIME See also: ACAMERA_SENSOR_FRAME_DURATION See also: ACAMERA_SENSOR_INFO_EXPOSURE_TIME_RANGE See also: ACAMERA_SENSOR_INFO_MAX_FRAME_DURATION See also: ACAMERA_SENSOR_INFO_SENSITIVITY_RANGE See also: ACAMERA_SENSOR_SENSITIVITY

ACAMERA_REQUEST_AVAILABLE_CAPABILITIES_MONOCHROME	
The camera device is a monochrome camera that doesn't contain a color filter array, and for YUV_420_888 stream, the pixel values on U and V planes are all 128.

A MONOCHROME camera must support the guaranteed stream combinations required for its device level and capabilities. Additionally, if the monochrome camera device supports Y8 format, all mandatory stream combination requirements related to YUV_420_888 apply to Y8 as well. There are no mandatory stream combination requirements with regard to Y8 for Bayer camera devices.

Starting from Android Q, the SENSOR_INFO_COLOR_FILTER_ARRANGEMENT of a MONOCHROME camera will be either MONO or NIR.

ACAMERA_REQUEST_AVAILABLE_CAPABILITIES_MOTION_TRACKING	
The camera device supports the MOTION_TRACKING value for ACAMERA_CONTROL_CAPTURE_INTENT, which limits maximum exposure time to 20 ms.

This limits the motion blur of capture images, resulting in better image tracking results for use cases such as image stabilization or augmented reality.

See also: ACAMERA_CONTROL_CAPTURE_INTENT

ACAMERA_REQUEST_AVAILABLE_CAPABILITIES_RAW	
The camera device supports outputting RAW buffers and metadata for interpreting them.

Devices supporting the RAW capability allow both for saving DNG files, and for direct application processing of raw sensor images.

RAW_SENSOR is supported as an output format.
The maximum available resolution for RAW_SENSOR streams will match either the value in ACAMERA_SENSOR_INFO_PIXEL_ARRAY_SIZE or ACAMERA_SENSOR_INFO_PRE_CORRECTION_ACTIVE_ARRAY_SIZE.
All DNG-related optional metadata entries are provided by the camera device.
See also: ACAMERA_SENSOR_INFO_PIXEL_ARRAY_SIZE See also: ACAMERA_SENSOR_INFO_PRE_CORRECTION_ACTIVE_ARRAY_SIZE

ACAMERA_REQUEST_AVAILABLE_CAPABILITIES_READ_SENSOR_SETTINGS	
The camera device supports accurately reporting the sensor settings for many of the sensor controls while the built-in 3A algorithm is running. This allows reporting of sensor settings even when these settings cannot be manually changed.

The values reported for the following controls are guaranteed to be available in the CaptureResult, including when 3A is enabled:

Exposure control
ACAMERA_SENSOR_EXPOSURE_TIME
Sensitivity control
ACAMERA_SENSOR_SENSITIVITY
Lens controls (if the lens is adjustable)
ACAMERA_LENS_FOCUS_DISTANCE
ACAMERA_LENS_APERTURE
This capability is a subset of the MANUAL_SENSOR control capability, and will always be included if the MANUAL_SENSOR capability is available.

See also: ACAMERA_LENS_APERTURE See also: ACAMERA_LENS_FOCUS_DISTANCE See also: ACAMERA_SENSOR_EXPOSURE_TIME See also: ACAMERA_SENSOR_SENSITIVITY

ACAMERA_REQUEST_AVAILABLE_CAPABILITIES_SECURE_IMAGE_DATA	
The camera device is capable of writing image data into a region of memory inaccessible to Android userspace or the Android kernel, and only accessible to trusted execution environments (TEE).

ACAMERA_REQUEST_AVAILABLE_CAPABILITIES_STREAM_USE_CASE	
The camera device supports selecting a per-stream use case via OutputConfiguration::setStreamUseCase so that the device can optimize camera pipeline parameters such as tuning, sensor mode, or ISP settings for a specific user scenario. Some sample usages of this capability are:

Distinguish high quality YUV captures from a regular YUV stream where the image quality may not be as good as the JPEG stream, or
Use one stream to serve multiple purposes: viewfinder, video recording and still capture. This is common with applications that wish to apply edits equally to preview, saved images, and saved videos.
This capability requires the camera device to support the following stream use cases:

DEFAULT for backward compatibility where the application doesn't set a stream use case
PREVIEW for live viewfinder and in-app image analysis
STILL_CAPTURE for still photo capture
VIDEO_RECORD for recording video clips
PREVIEW_VIDEO_STILL for one single stream used for viewfinder, video recording, and still capture.
VIDEO_CALL for long running video calls
CameraCharacteristics::SCALER_AVAILABLE_STREAM_USE_CASES lists all of the supported stream use cases.

Refer to CameraDevice::createCaptureSession for the mandatory stream combinations involving stream use cases, which can also be queried via MandatoryStreamCombination.

ACAMERA_REQUEST_AVAILABLE_CAPABILITIES_SYSTEM_CAMERA	
The camera device is only accessible by Android's system components and privileged applications. Processes need to have the android.permission.SYSTEM_CAMERA in addition to android.permission.CAMERA in order to connect to this camera device.

ACAMERA_REQUEST_AVAILABLE_CAPABILITIES_ULTRA_HIGH_RESOLUTION_SENSOR	
This camera device is capable of producing ultra high resolution images in addition to the image sizes described in the android.scaler.streamConfigurationMap. It can operate in 'default' mode and 'max resolution' mode. It generally does this by binning pixels in 'default' mode and not binning them in 'max resolution' mode. android.scaler.streamConfigurationMap describes the streams supported in 'default' mode. The stream configurations supported in 'max resolution' mode are described by android.scaler.streamConfigurationMapMaximumResolution. The maximum resolution mode pixel array size of a camera device (ACAMERA_SENSOR_INFO_PIXEL_ARRAY_SIZE) with this capability, will be at least 24 megapixels.

See also: ACAMERA_SENSOR_INFO_PIXEL_ARRAY_SIZE

acamera_metadata_enum_acamera_request_available_dynamic_range_profiles_map
 acamera_metadata_enum_acamera_request_available_dynamic_range_profiles_map
Properties
ACAMERA_REQUEST_AVAILABLE_DYNAMIC_RANGE_PROFILES_MAP_DOLBY_VISION_10B_HDR_OEM	
This is the camera mode for the default Dolby Vision capture mode for the specific device. This would be tuned by each specific device for consumer pleasing results that resonate with their particular audience. We expect that each specific device would have a different look for their default Dolby Vision capture.

ACAMERA_REQUEST_AVAILABLE_DYNAMIC_RANGE_PROFILES_MAP_DOLBY_VISION_10B_HDR_OEM_PO	
This is the power optimized mode for 10-bit Dolby Vision HDR device specific capture Mode.

ACAMERA_REQUEST_AVAILABLE_DYNAMIC_RANGE_PROFILES_MAP_DOLBY_VISION_10B_HDR_REF	
This is a camera mode for Dolby Vision capture optimized for a more scene accurate capture. This would typically differ from what a specific device might want to tune for a consumer optimized Dolby Vision general capture.

ACAMERA_REQUEST_AVAILABLE_DYNAMIC_RANGE_PROFILES_MAP_DOLBY_VISION_10B_HDR_REF_PO	
This is the power optimized mode for 10-bit Dolby Vision HDR Reference Mode.

ACAMERA_REQUEST_AVAILABLE_DYNAMIC_RANGE_PROFILES_MAP_DOLBY_VISION_8B_HDR_OEM	
This is the 8-bit version of device specific tuned and optimized Dolby Vision capture mode.

ACAMERA_REQUEST_AVAILABLE_DYNAMIC_RANGE_PROFILES_MAP_DOLBY_VISION_8B_HDR_OEM_PO	
This is the power optimized mode for 8-bit Dolby Vision HDR device specific capture Mode.

ACAMERA_REQUEST_AVAILABLE_DYNAMIC_RANGE_PROFILES_MAP_DOLBY_VISION_8B_HDR_REF	
This is the 8-bit version of the Dolby Vision reference capture mode optimized for scene accuracy.

ACAMERA_REQUEST_AVAILABLE_DYNAMIC_RANGE_PROFILES_MAP_DOLBY_VISION_8B_HDR_REF_PO	
This is the power optimized mode for 8-bit Dolby Vision HDR Reference Mode.

ACAMERA_REQUEST_AVAILABLE_DYNAMIC_RANGE_PROFILES_MAP_HDR10	
10-bit pixel samples encoded using the SMPTE ST 2084 transfer function. This profile utilizes internal static metadata to increase the quality of the capture.

ACAMERA_REQUEST_AVAILABLE_DYNAMIC_RANGE_PROFILES_MAP_HDR10_PLUS	
10-bit pixel samples encoded using the SMPTE ST 2084 transfer function. In contrast to HDR10, this profile uses internal per-frame metadata to further enhance the quality of the capture.

ACAMERA_REQUEST_AVAILABLE_DYNAMIC_RANGE_PROFILES_MAP_HLG10	
10-bit pixel samples encoded using the Hybrid log-gamma transfer function.

ACAMERA_REQUEST_AVAILABLE_DYNAMIC_RANGE_PROFILES_MAP_MAX	
ACAMERA_REQUEST_AVAILABLE_DYNAMIC_RANGE_PROFILES_MAP_STANDARD	
8-bit SDR profile which is the default for all non 10-bit output capable devices.

acamera_metadata_enum_acamera_scaler_available_recommended_stream_configurations
 acamera_metadata_enum_acamera_scaler_available_recommended_stream_configurations
Properties
ACAMERA_SCALER_AVAILABLE_RECOMMENDED_STREAM_CONFIGURATIONS_10BIT_OUTPUT	
If supported, the recommended 10-bit output stream configurations must include a subset of the advertised ImageFormat::YCBCR_P010 and ImageFormat::PRIVATE outputs that are optimized for power and performance when registered along with a supported 10-bit dynamic range profile. see android.hardware.camera2.params.OutputConfiguration::setDynamicRangeProfile for details.

ACAMERA_SCALER_AVAILABLE_RECOMMENDED_STREAM_CONFIGURATIONS_LOW_LATENCY_SNAPSHOT	
If supported, the recommended low latency stream configurations must have end-to-end latency that does not exceed 200 ms. under standard operating conditions (reasonable light levels, not loaded system) and using template TEMPLATE_STILL_CAPTURE. This is primarily for listing configurations for the JPEG output format however other supported output formats can be added as well.

ACAMERA_SCALER_AVAILABLE_RECOMMENDED_STREAM_CONFIGURATIONS_PREVIEW	
Preview must only include non-stalling processed stream configurations with output formats like AIMAGE_FORMAT_YUV_420_888, AIMAGE_FORMAT_PRIVATE, etc.

ACAMERA_SCALER_AVAILABLE_RECOMMENDED_STREAM_CONFIGURATIONS_PUBLIC_END	
ACAMERA_SCALER_AVAILABLE_RECOMMENDED_STREAM_CONFIGURATIONS_PUBLIC_END_3_8	
ACAMERA_SCALER_AVAILABLE_RECOMMENDED_STREAM_CONFIGURATIONS_RAW	
If supported, recommended raw stream configurations must only include RAW based output formats.

ACAMERA_SCALER_AVAILABLE_RECOMMENDED_STREAM_CONFIGURATIONS_RECORD	
Video record must include stream configurations that match the advertised supported media profiles CamcorderProfile with IMPLEMENTATION_DEFINED format.

ACAMERA_SCALER_AVAILABLE_RECOMMENDED_STREAM_CONFIGURATIONS_SNAPSHOT	
Recommended snapshot stream configurations must include at least one with size close to ACAMERA_SENSOR_INFO_ACTIVE_ARRAY_SIZE and JPEG output format. Taking into account restrictions on aspect ratio, alignment etc. the area of the maximum suggested size shouldn’t be less than 97% of the sensor array size area.

See also: ACAMERA_SENSOR_INFO_ACTIVE_ARRAY_SIZE

ACAMERA_SCALER_AVAILABLE_RECOMMENDED_STREAM_CONFIGURATIONS_VENDOR_START	
Vendor defined use cases. These depend on the vendor implementation.

ACAMERA_SCALER_AVAILABLE_RECOMMENDED_STREAM_CONFIGURATIONS_VIDEO_SNAPSHOT	
Video snapshot must include stream configurations at least as big as the maximum RECORD resolutions and only with JPEG output format. Additionally the configurations shouldn't cause preview glitches and also be able to run at 30 fps.

ACAMERA_SCALER_AVAILABLE_RECOMMENDED_STREAM_CONFIGURATIONS_ZSL	
If supported, recommended input stream configurations must only be advertised with ZSL along with other processed and/or stalling output formats.

acamera_metadata_enum_acamera_scaler_available_stream_configurations
 acamera_metadata_enum_acamera_scaler_available_stream_configurations
Properties
ACAMERA_SCALER_AVAILABLE_STREAM_CONFIGURATIONS_INPUT	
ACAMERA_SCALER_AVAILABLE_STREAM_CONFIGURATIONS_OUTPUT	
acamera_metadata_enum_acamera_scaler_available_stream_configurations_maximum_resolution
 acamera_metadata_enum_acamera_scaler_available_stream_configurations_maximum_resolution
Properties
ACAMERA_SCALER_AVAILABLE_STREAM_CONFIGURATIONS_MAXIMUM_RESOLUTION_INPUT	
ACAMERA_SCALER_AVAILABLE_STREAM_CONFIGURATIONS_MAXIMUM_RESOLUTION_OUTPUT	
acamera_metadata_enum_acamera_scaler_available_stream_use_cases
 acamera_metadata_enum_acamera_scaler_available_stream_use_cases
Properties
ACAMERA_SCALER_AVAILABLE_STREAM_USE_CASES_DEFAULT	
Default stream use case.

This use case is the same as when the application doesn't set any use case for the stream. The camera device uses the properties of the output target, such as format, dataSpace, or surface class type, to optimize the image processing pipeline.

ACAMERA_SCALER_AVAILABLE_STREAM_USE_CASES_PREVIEW	
Live stream shown to the user.

Optimized for performance and usability as a viewfinder, but not necessarily for image quality. The output is not meant to be persisted as saved images or video.

No stall if ACAMERA_CONTROL_* are set to FAST. There may be stall if they are set to HIGH_QUALITY. This use case has the same behavior as the default SurfaceView and SurfaceTexture targets. Additionally, this use case can be used for in-app image analysis.

ACAMERA_SCALER_AVAILABLE_STREAM_USE_CASES_PREVIEW_VIDEO_STILL	
One single stream used for combined purposes of preview, video, and still capture.

For such multi-purpose streams, the camera device aims to make the best tradeoff between the individual use cases. For example, the STILL_CAPTURE use case by itself may have stalls for achieving best image quality. But if combined with PREVIEW and VIDEO_RECORD, the camera device needs to trade off the additional image processing for speed so that preview and video recording aren't slowed down.

Similarly, VIDEO_RECORD may produce frames with a substantial lag, but PREVIEW_VIDEO_STILL must have minimal output delay. This means that to enable video stabilization with this use case, the device must support and the app must select the PREVIEW_STABILIZATION mode for video stabilization.

ACAMERA_SCALER_AVAILABLE_STREAM_USE_CASES_STILL_CAPTURE	
Still photo capture.

Optimized for high-quality high-resolution capture, and not expected to maintain preview-like frame rates.

The stream may have stalls regardless of whether ACAMERA_CONTROL_* is HIGH_QUALITY. This use case has the same behavior as the default JPEG and RAW related formats.

ACAMERA_SCALER_AVAILABLE_STREAM_USE_CASES_VIDEO_CALL	
Long-running video call optimized for both power efficiency and video quality.

The camera sensor may run in a lower-resolution mode to reduce power consumption at the cost of some image and digital zoom quality. Unlike VIDEO_RECORD, VIDEO_CALL outputs are expected to work in dark conditions, so are usually accompanied with variable frame rate settings to allow sufficient exposure time in low light.

ACAMERA_SCALER_AVAILABLE_STREAM_USE_CASES_VIDEO_RECORD	
Recording video clips.

Optimized for high-quality video capture, including high-quality image stabilization if supported by the device and enabled by the application. As a result, may produce output frames with a substantial lag from real time, to allow for highest-quality stabilization or other processing. As such, such an output is not suitable for drawing to screen directly, and is expected to be persisted to disk or similar for later playback or processing. Only streams that set the VIDEO_RECORD use case are guaranteed to have video stabilization applied when the video stabilization control is set to ON, as opposed to PREVIEW_STABILIZATION.

This use case has the same behavior as the default MediaRecorder and MediaCodec targets.

acamera_metadata_enum_acamera_scaler_cropping_type
 acamera_metadata_enum_acamera_scaler_cropping_type
Properties
ACAMERA_SCALER_CROPPING_TYPE_CENTER_ONLY	
The camera device only supports centered crop regions.

ACAMERA_SCALER_CROPPING_TYPE_FREEFORM	
The camera device supports arbitrarily chosen crop regions.

acamera_metadata_enum_acamera_scaler_multi_resolution_stream_supported
 acamera_metadata_enum_acamera_scaler_multi_resolution_stream_supported
Properties
ACAMERA_SCALER_MULTI_RESOLUTION_STREAM_SUPPORTED_FALSE	
ACAMERA_SCALER_MULTI_RESOLUTION_STREAM_SUPPORTED_TRUE	
acamera_metadata_enum_acamera_scaler_physical_camera_multi_resolution_stream_configurations
 acamera_metadata_enum_acamera_scaler_physical_camera_multi_resolution_stream_configurations
Properties
ACAMERA_SCALER_PHYSICAL_CAMERA_MULTI_RESOLUTION_STREAM_CONFIGURATIONS_INPUT	
ACAMERA_SCALER_PHYSICAL_CAMERA_MULTI_RESOLUTION_STREAM_CONFIGURATIONS_OUTPUT	
acamera_metadata_enum_acamera_scaler_rotate_and_crop
 acamera_metadata_enum_acamera_scaler_rotate_and_crop
Properties
ACAMERA_SCALER_ROTATE_AND_CROP_180	
Processed images are rotated by 180 degrees. Since the aspect ratio does not change, no cropping is performed.

ACAMERA_SCALER_ROTATE_AND_CROP_270	
Processed images are rotated by 270 degrees clockwise, and then cropped to the original aspect ratio.

ACAMERA_SCALER_ROTATE_AND_CROP_90	
Processed images are rotated by 90 degrees clockwise, and then cropped to the original aspect ratio.

ACAMERA_SCALER_ROTATE_AND_CROP_AUTO	
The camera API automatically selects the best concrete value for rotate-and-crop based on the application's support for resizability and the current multi-window mode.

If the application does not support resizing but the display mode for its main Activity is not in a typical orientation, the camera API will set ROTATE_AND_CROP_90 or some other supported rotation value, depending on device configuration, to ensure preview and captured images are correctly shown to the user. Otherwise, ROTATE_AND_CROP_NONE will be selected.

When a value other than NONE is selected, several metadata fields will also be parsed differently to ensure that coordinates are correctly handled for features like drawing face detection boxes or passing in tap-to-focus coordinates. The camera API will convert positions in the active array coordinate system to/from the cropped-and-rotated coordinate system to make the operation transparent for applications.

No coordinate mapping will be done when the application selects a non-AUTO mode.

ACAMERA_SCALER_ROTATE_AND_CROP_NONE	
No rotate and crop is applied. Processed outputs are in the sensor orientation.

acamera_metadata_enum_acamera_sensor_info_color_filter_arrangement
 acamera_metadata_enum_acamera_sensor_info_color_filter_arrangement
Properties
ACAMERA_SENSOR_INFO_COLOR_FILTER_ARRANGEMENT_BGGR	
ACAMERA_SENSOR_INFO_COLOR_FILTER_ARRANGEMENT_GBRG	
ACAMERA_SENSOR_INFO_COLOR_FILTER_ARRANGEMENT_GRBG	
ACAMERA_SENSOR_INFO_COLOR_FILTER_ARRANGEMENT_MONO	
Sensor doesn't have any Bayer color filter. Such sensor captures visible light in monochrome. The exact weighting and wavelengths captured is not specified, but generally only includes the visible frequencies. This value implies a MONOCHROME camera.

ACAMERA_SENSOR_INFO_COLOR_FILTER_ARRANGEMENT_NIR	
Sensor has a near infrared filter capturing light with wavelength between roughly 750nm and 1400nm, and the same filter covers the whole sensor array. This value implies a MONOCHROME camera.

ACAMERA_SENSOR_INFO_COLOR_FILTER_ARRANGEMENT_RGB	
Sensor is not Bayer; output has 3 16-bit values for each pixel, instead of just 1 16-bit value per pixel.

ACAMERA_SENSOR_INFO_COLOR_FILTER_ARRANGEMENT_RGGB	
acamera_metadata_enum_acamera_sensor_info_lens_shading_applied
 acamera_metadata_enum_acamera_sensor_info_lens_shading_applied
Properties
ACAMERA_SENSOR_INFO_LENS_SHADING_APPLIED_FALSE	
ACAMERA_SENSOR_INFO_LENS_SHADING_APPLIED_TRUE	
acamera_metadata_enum_acamera_sensor_info_timestamp_source
 acamera_metadata_enum_acamera_sensor_info_timestamp_source
Properties
ACAMERA_SENSOR_INFO_TIMESTAMP_SOURCE_REALTIME	
Timestamps from ACAMERA_SENSOR_TIMESTAMP are in the same timebase as SystemClock::elapsedRealtimeNanos, and they can be compared to other timestamps using that base.

When buffers from a REALTIME device are passed directly to a video encoder from the camera, automatic compensation is done to account for differing timebases of the audio and camera subsystems. If the application is receiving buffers and then later sending them to a video encoder or other application where they are compared with audio subsystem timestamps or similar, this compensation is not present. In those cases, applications need to adjust the timestamps themselves. Since SystemClock::elapsedRealtimeNanos and SystemClock::uptimeMillis only diverge while the device is asleep, an offset between the two sources can be measured once per active session and applied to timestamps for sufficient accuracy for A/V sync.

See also: ACAMERA_SENSOR_TIMESTAMP

ACAMERA_SENSOR_INFO_TIMESTAMP_SOURCE_UNKNOWN	
Timestamps from ACAMERA_SENSOR_TIMESTAMP are in nanoseconds and monotonic, but can not be compared to timestamps from other subsystems (e.g. accelerometer, gyro etc.), or other instances of the same or different camera devices in the same system with accuracy. However, the timestamps are roughly in the same timebase as SystemClock::uptimeMillis. The accuracy is sufficient for tasks like A/V synchronization for video recording, at least, and the timestamps can be directly used together with timestamps from the audio subsystem for that task.

Timestamps between streams and results for a single camera instance are comparable, and the timestamps for all buffers and the result metadata generated by a single capture are identical.

See also: ACAMERA_SENSOR_TIMESTAMP

acamera_metadata_enum_acamera_sensor_pixel_mode
 acamera_metadata_enum_acamera_sensor_pixel_mode
Properties
ACAMERA_SENSOR_PIXEL_MODE_DEFAULT	
This is the default sensor pixel mode. This is the only sensor pixel mode supported unless a camera device advertises CameraMetadata::REQUEST_AVAILABLE_CAPABILITIES_ULTRA_HIGH_RESOLUTION_SENSOR.

ACAMERA_SENSOR_PIXEL_MODE_MAXIMUM_RESOLUTION	
This sensor pixel mode is offered by devices with capability CameraMetadata::REQUEST_AVAILABLE_CAPABILITIES_ULTRA_HIGH_RESOLUTION_SENSOR. In this mode, sensors typically do not bin pixels, as a result can offer larger image sizes.

acamera_metadata_enum_acamera_sensor_raw_binning_factor_used
 acamera_metadata_enum_acamera_sensor_raw_binning_factor_used
Properties
ACAMERA_SENSOR_RAW_BINNING_FACTOR_USED_FALSE	
The RAW targets have a regular bayer pattern in this capture.

ACAMERA_SENSOR_RAW_BINNING_FACTOR_USED_TRUE	
The RAW targets in this capture have ACAMERA_SENSOR_INFO_BINNING_FACTOR as the bayer pattern.

See also: ACAMERA_SENSOR_INFO_BINNING_FACTOR

acamera_metadata_enum_acamera_sensor_reference_illuminant1
 acamera_metadata_enum_acamera_sensor_reference_illuminant1
Properties
ACAMERA_SENSOR_REFERENCE_ILLUMINANT1_CLOUDY_WEATHER	
ACAMERA_SENSOR_REFERENCE_ILLUMINANT1_COOL_WHITE_FLUORESCENT	
W 3900 - 4500K

ACAMERA_SENSOR_REFERENCE_ILLUMINANT1_D50	
ACAMERA_SENSOR_REFERENCE_ILLUMINANT1_D55	
ACAMERA_SENSOR_REFERENCE_ILLUMINANT1_D65	
ACAMERA_SENSOR_REFERENCE_ILLUMINANT1_D75	
ACAMERA_SENSOR_REFERENCE_ILLUMINANT1_DAYLIGHT	
ACAMERA_SENSOR_REFERENCE_ILLUMINANT1_DAYLIGHT_FLUORESCENT	
D 5700 - 7100K

ACAMERA_SENSOR_REFERENCE_ILLUMINANT1_DAY_WHITE_FLUORESCENT	
N 4600 - 5400K

ACAMERA_SENSOR_REFERENCE_ILLUMINANT1_FINE_WEATHER	
ACAMERA_SENSOR_REFERENCE_ILLUMINANT1_FLASH	
ACAMERA_SENSOR_REFERENCE_ILLUMINANT1_FLUORESCENT	
ACAMERA_SENSOR_REFERENCE_ILLUMINANT1_ISO_STUDIO_TUNGSTEN	
ACAMERA_SENSOR_REFERENCE_ILLUMINANT1_SHADE	
ACAMERA_SENSOR_REFERENCE_ILLUMINANT1_STANDARD_A	
ACAMERA_SENSOR_REFERENCE_ILLUMINANT1_STANDARD_B	
ACAMERA_SENSOR_REFERENCE_ILLUMINANT1_STANDARD_C	
ACAMERA_SENSOR_REFERENCE_ILLUMINANT1_TUNGSTEN	
Incandescent light

ACAMERA_SENSOR_REFERENCE_ILLUMINANT1_WHITE_FLUORESCENT	
WW 3200 - 3700K

acamera_metadata_enum_acamera_sensor_test_pattern_mode
 acamera_metadata_enum_acamera_sensor_test_pattern_mode
Properties
ACAMERA_SENSOR_TEST_PATTERN_MODE_COLOR_BARS	
All pixel data is replaced with an 8-bar color pattern.

The vertical bars (left-to-right) are as follows:

100% white
yellow
cyan
green
magenta
red
blue
black
In general the image would look like the following:

W Y C G M R B K
W Y C G M R B K
W Y C G M R B K
W Y C G M R B K
W Y C G M R B K
. . . . . . . .
. . . . . . . .
. . . . . . . .
(B = Blue, K = Black)
Each bar should take up 1/8 of the sensor pixel array width. When this is not possible, the bar size should be rounded down to the nearest integer and the pattern can repeat on the right side.

Each bar's height must always take up the full sensor pixel array height.

Each pixel in this test pattern must be set to either 0% intensity or 100% intensity.

ACAMERA_SENSOR_TEST_PATTERN_MODE_COLOR_BARS_FADE_TO_GRAY	
The test pattern is similar to COLOR_BARS, except that each bar should start at its specified color at the top, and fade to gray at the bottom.

Furthermore each bar is further subdivided into a left and right half. The left half should have a smooth gradient, and the right half should have a quantized gradient.

In particular, the right half's should consist of blocks of the same color for 1/16th active sensor pixel array width.

The least significant bits in the quantized gradient should be copied from the most significant bits of the smooth gradient.

The height of each bar should always be a multiple of 128. When this is not the case, the pattern should repeat at the bottom of the image.

ACAMERA_SENSOR_TEST_PATTERN_MODE_CUSTOM1	
The first custom test pattern. All custom patterns that are available only on this camera device are at least this numeric value.

All of the custom test patterns will be static (that is the raw image must not vary from frame to frame).

ACAMERA_SENSOR_TEST_PATTERN_MODE_OFF	
No test pattern mode is used, and the camera device returns captures from the image sensor.

This is the default if the key is not set.

ACAMERA_SENSOR_TEST_PATTERN_MODE_PN9	
All pixel data is replaced by a pseudo-random sequence generated from a PN9 512-bit sequence (typically implemented in hardware with a linear feedback shift register).

The generator should be reset at the beginning of each frame, and thus each subsequent raw frame with this test pattern should be exactly the same as the last.

ACAMERA_SENSOR_TEST_PATTERN_MODE_SOLID_COLOR	
Each pixel in [R, G_even, G_odd, B] is replaced by its respective color channel provided in ACAMERA_SENSOR_TEST_PATTERN_DATA.

For example:

ACAMERA_SENSOR_TEST_PATTERN_DATA = [0, 0xFFFFFFFF, 0xFFFFFFFF, 0]
All green pixels are 100% green. All red/blue pixels are black.

ACAMERA_SENSOR_TEST_PATTERN_DATA = [0xFFFFFFFF, 0, 0xFFFFFFFF, 0]
All red pixels are 100% red. Only the odd green pixels are 100% green. All blue pixels are 100% black.

See also: ACAMERA_SENSOR_TEST_PATTERN_DATA

acamera_metadata_enum_acamera_shading_mode
 acamera_metadata_enum_acamera_shading_mode
Properties
ACAMERA_SHADING_MODE_FAST	
Apply lens shading corrections, without slowing frame rate relative to sensor raw output

ACAMERA_SHADING_MODE_HIGH_QUALITY	
Apply high-quality lens shading correction, at the cost of possibly reduced frame rate.

ACAMERA_SHADING_MODE_OFF	
No lens shading correction is applied.

acamera_metadata_enum_acamera_statistics_face_detect_mode
 acamera_metadata_enum_acamera_statistics_face_detect_mode
Properties
ACAMERA_STATISTICS_FACE_DETECT_MODE_FULL	
Return all face metadata.

In this mode, face rectangles, scores, landmarks, and face IDs are all valid.

ACAMERA_STATISTICS_FACE_DETECT_MODE_OFF	
Do not include face detection statistics in capture results.

ACAMERA_STATISTICS_FACE_DETECT_MODE_SIMPLE	
Return face rectangle and confidence values only.

acamera_metadata_enum_acamera_statistics_hot_pixel_map_mode
 acamera_metadata_enum_acamera_statistics_hot_pixel_map_mode
Properties
ACAMERA_STATISTICS_HOT_PIXEL_MAP_MODE_OFF	
Hot pixel map production is disabled.

ACAMERA_STATISTICS_HOT_PIXEL_MAP_MODE_ON	
Hot pixel map production is enabled.

acamera_metadata_enum_acamera_statistics_lens_shading_map_mode
 acamera_metadata_enum_acamera_statistics_lens_shading_map_mode
Properties
ACAMERA_STATISTICS_LENS_SHADING_MAP_MODE_OFF	
Do not include a lens shading map in the capture result.

ACAMERA_STATISTICS_LENS_SHADING_MAP_MODE_ON	
Include a lens shading map in the capture result.

acamera_metadata_enum_acamera_statistics_ois_data_mode
 acamera_metadata_enum_acamera_statistics_ois_data_mode
Properties
ACAMERA_STATISTICS_OIS_DATA_MODE_OFF	
Do not include OIS data in the capture result.

ACAMERA_STATISTICS_OIS_DATA_MODE_ON	
Include OIS data in the capture result.

ACAMERA_STATISTICS_OIS_TIMESTAMPS, ACAMERA_STATISTICS_OIS_X_SHIFTS, and ACAMERA_STATISTICS_OIS_Y_SHIFTS provide OIS data in the output result metadata.

See also: ACAMERA_STATISTICS_OIS_TIMESTAMPS See also: ACAMERA_STATISTICS_OIS_X_SHIFTS See also: ACAMERA_STATISTICS_OIS_Y_SHIFTS

acamera_metadata_enum_acamera_statistics_scene_flicker
 acamera_metadata_enum_acamera_statistics_scene_flicker
Properties
ACAMERA_STATISTICS_SCENE_FLICKER_50HZ	
The camera device detects illumination flickering at 50Hz in the current scene.

ACAMERA_STATISTICS_SCENE_FLICKER_60HZ	
The camera device detects illumination flickering at 60Hz in the current scene.

ACAMERA_STATISTICS_SCENE_FLICKER_NONE	
The camera device does not detect any flickering illumination in the current scene.

acamera_metadata_enum_acamera_sync_frame_number
 acamera_metadata_enum_acamera_sync_frame_number
Properties
ACAMERA_SYNC_FRAME_NUMBER_CONVERGING	
The current result is not yet fully synchronized to any request.

Synchronization is in progress, and reading metadata from this result may include a mix of data that have taken effect since the last synchronization time.

In some future result, within ACAMERA_SYNC_MAX_LATENCY frames, this value will update to the actual frame number frame number the result is guaranteed to be synchronized to (as long as the request settings remain constant).

See also: ACAMERA_SYNC_MAX_LATENCY

ACAMERA_SYNC_FRAME_NUMBER_UNKNOWN	
The current result's synchronization status is unknown.

The result may have already converged, or it may be in progress. Reading from this result may include some mix of settings from past requests.

After a settings change, the new settings will eventually all take effect for the output buffers and results. However, this value will not change when that happens. Altering settings rapidly may provide outcomes using mixes of settings from recent requests.

This value is intended primarily for backwards compatibility with the older camera implementations (for android.hardware.Camera).

acamera_metadata_enum_acamera_sync_max_latency
 acamera_metadata_enum_acamera_sync_max_latency
Properties
ACAMERA_SYNC_MAX_LATENCY_PER_FRAME_CONTROL	
Every frame has the requests immediately applied.

Changing controls over multiple requests one after another will produce results that have those controls applied atomically each frame.

All FULL capability devices will have this as their maxLatency.

ACAMERA_SYNC_MAX_LATENCY_UNKNOWN	
Each new frame has some subset (potentially the entire set) of the past requests applied to the camera settings.

By submitting a series of identical requests, the camera device will eventually have the camera settings applied, but it is unknown when that exact point will be.

All LEGACY capability devices will have this as their maxLatency.

acamera_metadata_enum_acamera_tonemap_mode
 acamera_metadata_enum_acamera_tonemap_mode
Properties
ACAMERA_TONEMAP_MODE_CONTRAST_CURVE	
Use the tone mapping curve specified in the ACAMERA_TONEMAPCURVE_* entries.

All color enhancement and tonemapping must be disabled, except for applying the tonemapping curve specified by android.tonemap.curve.

Must not slow down frame rate relative to raw sensor output.

ACAMERA_TONEMAP_MODE_FAST	
Advanced gamma mapping and color enhancement may be applied, without reducing frame rate compared to raw sensor output.

ACAMERA_TONEMAP_MODE_GAMMA_VALUE	
Use the gamma value specified in ACAMERA_TONEMAP_GAMMA to perform tonemapping.

All color enhancement and tonemapping must be disabled, except for applying the tonemapping curve specified by ACAMERA_TONEMAP_GAMMA.

Must not slow down frame rate relative to raw sensor output.

See also: ACAMERA_TONEMAP_GAMMA

ACAMERA_TONEMAP_MODE_HIGH_QUALITY	
High-quality gamma mapping and color enhancement will be applied, at the cost of possibly reduced frame rate compared to raw sensor output.

ACAMERA_TONEMAP_MODE_PRESET_CURVE	
Use the preset tonemapping curve specified in ACAMERA_TONEMAP_PRESET_CURVE to perform tonemapping.

All color enhancement and tonemapping must be disabled, except for applying the tonemapping curve specified by ACAMERA_TONEMAP_PRESET_CURVE.

Must not slow down frame rate relative to raw sensor output.

See also: ACAMERA_TONEMAP_PRESET_CURVE

acamera_metadata_enum_acamera_tonemap_preset_curve
 acamera_metadata_enum_acamera_tonemap_preset_curve
Properties
ACAMERA_TONEMAP_PRESET_CURVE_REC709	
Tonemapping curve is defined by ITU-R BT.709

ACAMERA_TONEMAP_PRESET_CURVE_SRGB	
Tonemapping curve is defined by sRGB

acamera_metadata_section
 acamera_metadata_section
Properties
ACAMERA_AUTOMOTIVE	
ACAMERA_AUTOMOTIVE_LENS	
ACAMERA_BLACK_LEVEL	
ACAMERA_COLOR_CORRECTION	
ACAMERA_CONTROL	
ACAMERA_DEMOSAIC	
ACAMERA_DEPTH	
ACAMERA_DISTORTION_CORRECTION	
ACAMERA_EDGE	
ACAMERA_FLASH	
ACAMERA_FLASH_INFO	
ACAMERA_HEIC	
ACAMERA_HEIC_INFO	
ACAMERA_HOT_PIXEL	
ACAMERA_INFO	
ACAMERA_JPEG	
ACAMERA_LED	
ACAMERA_LENS	
ACAMERA_LENS_INFO	
ACAMERA_LOGICAL_MULTI_CAMERA	
ACAMERA_NOISE_REDUCTION	
ACAMERA_QUIRKS	
ACAMERA_REPROCESS	
ACAMERA_REQUEST	
ACAMERA_SCALER	
ACAMERA_SECTION_COUNT	
ACAMERA_SENSOR	
ACAMERA_SENSOR_INFO	
ACAMERA_SHADING	
ACAMERA_STATISTICS	
ACAMERA_STATISTICS_INFO	
ACAMERA_SYNC	
ACAMERA_TONEMAP	
ACAMERA_VENDOR	
acamera_metadata_section_start
 acamera_metadata_section_start
Hierarchy positions in enum space.

Properties
ACAMERA_AUTOMOTIVE_LENS_START	
ACAMERA_AUTOMOTIVE_START	
ACAMERA_BLACK_LEVEL_START	
ACAMERA_COLOR_CORRECTION_START	
ACAMERA_CONTROL_START	
ACAMERA_DEMOSAIC_START	
ACAMERA_DEPTH_START	
ACAMERA_DISTORTION_CORRECTION_START	
ACAMERA_EDGE_START	
ACAMERA_FLASH_INFO_START	
ACAMERA_FLASH_START	
ACAMERA_HEIC_INFO_START	
ACAMERA_HEIC_START	
ACAMERA_HOT_PIXEL_START	
ACAMERA_INFO_START	
ACAMERA_JPEG_START	
ACAMERA_LED_START	
ACAMERA_LENS_INFO_START	
ACAMERA_LENS_START	
ACAMERA_LOGICAL_MULTI_CAMERA_START	
ACAMERA_NOISE_REDUCTION_START	
ACAMERA_QUIRKS_START	
ACAMERA_REPROCESS_START	
ACAMERA_REQUEST_START	
ACAMERA_SCALER_START	
ACAMERA_SENSOR_INFO_START	
ACAMERA_SENSOR_START	
ACAMERA_SHADING_START	
ACAMERA_STATISTICS_INFO_START	
ACAMERA_STATISTICS_START	
ACAMERA_SYNC_START	
ACAMERA_TONEMAP_START	
ACAMERA_VENDOR_START	
acamera_metadata_tag
 acamera_metadata_tag
Main enum for camera metadata tags.

Properties
ACAMERA_AUTOMOTIVE_END	
ACAMERA_AUTOMOTIVE_LENS_END	
ACAMERA_AUTOMOTIVE_LENS_FACING	
The direction of the camera faces relative to the vehicle body frame and the passenger seats.

Type: byte[n] (acamera_metadata_enum_android_automotive_lens_facing_t)

This tag may appear in:

ACameraMetadata from ACameraManager_getCameraCharacteristics
This enum defines the lens facing characteristic of the cameras on the automotive devices with locations ACAMERA_AUTOMOTIVE_LOCATION defines. If the system has FEATURE_AUTOMOTIVE, the camera will have this entry in its static metadata.

When ACAMERA_AUTOMOTIVE_LOCATION is INTERIOR, this has one or more INTERIOR_* values or a single EXTERIOR_* value. When this has more than one INTERIOR_*, the first value must be the one for the seat closest to the optical axis. If this contains INTERIOR_OTHER, all other values will be ineffective.

When ACAMERA_AUTOMOTIVE_LOCATION is EXTERIOR_* or EXTRA, this has a single EXTERIOR_* value.

If a camera has INTERIOR_OTHER or EXTERIOR_OTHER, or more than one camera is at the same location and facing the same direction, their static metadata will list the following entries, so that applications can determine their lenses' exact facing directions:

ACAMERA_LENS_POSE_REFERENCE
ACAMERA_LENS_POSE_ROTATION
ACAMERA_LENS_POSE_TRANSLATION
See also: ACAMERA_AUTOMOTIVE_LOCATION See also: ACAMERA_LENS_POSE_REFERENCE See also: ACAMERA_LENS_POSE_ROTATION See also: ACAMERA_LENS_POSE_TRANSLATION

ACAMERA_AUTOMOTIVE_LOCATION	
Location of the cameras on the automotive devices.

Type: byte (acamera_metadata_enum_android_automotive_location_t)

This tag may appear in:

ACameraMetadata from ACameraManager_getCameraCharacteristics
This enum defines the locations of the cameras relative to the vehicle body frame on the automotive sensor coordinate system. If the system has FEATURE_AUTOMOTIVE, the camera will have this entry in its static metadata.

INTERIOR is the inside of the vehicle body frame (or the passenger cabin).
EXTERIOR is the outside of the vehicle body frame.
EXTRA is the extra vehicle such as a trailer.
Each side of the vehicle body frame on this coordinate system is defined as below:

FRONT is where the Y-axis increases toward.
REAR is where the Y-axis decreases toward.
LEFT is where the X-axis decreases toward.
RIGHT is where the X-axis increases toward.
If the camera has either EXTERIOR_OTHER or EXTRA_OTHER, its static metadata will list the following entries, so that applications can determine the camera's exact location:

ACAMERA_LENS_POSE_REFERENCE
ACAMERA_LENS_POSE_ROTATION
ACAMERA_LENS_POSE_TRANSLATION
See also: ACAMERA_LENS_POSE_REFERENCE See also: ACAMERA_LENS_POSE_ROTATION See also: ACAMERA_LENS_POSE_TRANSLATION

ACAMERA_BLACK_LEVEL_END	
ACAMERA_BLACK_LEVEL_LOCK	
Whether black-level compensation is locked to its current values, or is free to vary.

Type: byte (acamera_metadata_enum_android_black_level_lock_t)

This tag may appear in:

ACameraMetadata from ACameraCaptureSession_captureCallback_result callbacks
ACaptureRequest
Whether the black level offset was locked for this frame. Should be ON if ACAMERA_BLACK_LEVEL_LOCK was ON in the capture request, unless a change in other capture settings forced the camera device to perform a black level reset.

See also: ACAMERA_BLACK_LEVEL_LOCK

ACAMERA_COLOR_CORRECTION_ABERRATION_MODE	
Mode of operation for the chromatic aberration correction algorithm.

Type: byte (acamera_metadata_enum_android_color_correction_aberration_mode_t)

This tag may appear in:

ACameraMetadata from ACameraCaptureSession_captureCallback_result callbacks
ACaptureRequest
Chromatic (color) aberration is caused by the fact that different wavelengths of light can not focus on the same point after exiting from the lens. This metadata defines the high level control of chromatic aberration correction algorithm, which aims to minimize the chromatic artifacts that may occur along the object boundaries in an image.

FAST/HIGH_QUALITY both mean that camera device determined aberration correction will be applied. HIGH_QUALITY mode indicates that the camera device will use the highest-quality aberration correction algorithms, even if it slows down capture rate. FAST means the camera device will not slow down capture rate when applying aberration correction.

LEGACY devices will always be in FAST mode.

ACAMERA_COLOR_CORRECTION_AVAILABLE_ABERRATION_MODES	
List of aberration correction modes for ACAMERA_COLOR_CORRECTION_ABERRATION_MODE that are supported by this camera device.

See also: ACAMERA_COLOR_CORRECTION_ABERRATION_MODE

Type: byte[n]

This tag may appear in:

ACameraMetadata from ACameraManager_getCameraCharacteristics
This key lists the valid modes for ACAMERA_COLOR_CORRECTION_ABERRATION_MODE. If no aberration correction modes are available for a device, this list will solely include OFF mode. All camera devices will support either OFF or FAST mode.

Camera devices that support the MANUAL_POST_PROCESSING capability will always list OFF mode. This includes all FULL level devices.

LEGACY devices will always only support FAST mode.

See also: ACAMERA_COLOR_CORRECTION_ABERRATION_MODE

ACAMERA_COLOR_CORRECTION_END	
ACAMERA_COLOR_CORRECTION_GAINS	
Gains applying to Bayer raw color channels for white-balance.

Type: float[4]

This tag may appear in:

ACameraMetadata from ACameraCaptureSession_captureCallback_result callbacks
ACaptureRequest
These per-channel gains are either set by the camera device when the request ACAMERA_COLOR_CORRECTION_MODE is not TRANSFORM_MATRIX, or directly by the application in the request when the ACAMERA_COLOR_CORRECTION_MODE is TRANSFORM_MATRIX.

The gains in the result metadata are the gains actually applied by the camera device to the current frame.

The valid range of gains varies on different devices, but gains between [1.0, 3.0] are guaranteed not to be clipped. Even if a given device allows gains below 1.0, this is usually not recommended because this can create color artifacts.

See also: ACAMERA_COLOR_CORRECTION_MODE

ACAMERA_COLOR_CORRECTION_MODE	
The mode control selects how the image data is converted from the sensor's native color into linear sRGB color.

Type: byte (acamera_metadata_enum_android_color_correction_mode_t)

This tag may appear in:

ACameraMetadata from ACameraCaptureSession_captureCallback_result callbacks
ACaptureRequest
When auto-white balance (AWB) is enabled with ACAMERA_CONTROL_AWB_MODE, this control is overridden by the AWB routine. When AWB is disabled, the application controls how the color mapping is performed.

We define the expected processing pipeline below. For consistency across devices, this is always the case with TRANSFORM_MATRIX.

When either FAST or HIGH_QUALITY is used, the camera device may do additional processing but ACAMERA_COLOR_CORRECTION_GAINS and ACAMERA_COLOR_CORRECTION_TRANSFORM will still be provided by the camera device (in the results) and be roughly correct.

Switching to TRANSFORM_MATRIX and using the data provided from FAST or HIGH_QUALITY will yield a picture with the same white point as what was produced by the camera device in the earlier frame.

The expected processing pipeline is as follows:


The white balance is encoded by two values, a 4-channel white-balance gain vector (applied in the Bayer domain), and a 3x3 color transform matrix (applied after demosaic).

The 4-channel white-balance gains are defined as:

ACAMERA_COLOR_CORRECTION_GAINS = [ R G_even G_odd B ]
where G_even is the gain for green pixels on even rows of the output, and G_odd is the gain for green pixels on the odd rows. These may be identical for a given camera device implementation; if the camera device does not support a separate gain for even/odd green channels, it will use the G_even value, and write G_odd equal to G_even in the output result metadata.

The matrices for color transforms are defined as a 9-entry vector:

ACAMERA_COLOR_CORRECTION_TRANSFORM = [ I0 I1 I2 I3 I4 I5 I6 I7 I8 ]
which define a transform from input sensor colors, P_in = [ r g b ], to output linear sRGB, P_out = [ r' g' b' ],

with colors as follows:

r' = I0r + I1g + I2b
g' = I3r + I4g + I5b
b' = I6r + I7g + I8b
Both the input and output value ranges must match. Overflow/underflow values are clipped to fit within the range.

See also: ACAMERA_COLOR_CORRECTION_GAINS See also: ACAMERA_COLOR_CORRECTION_TRANSFORM See also: ACAMERA_CONTROL_AWB_MODE

ACAMERA_COLOR_CORRECTION_TRANSFORM	
A color transform matrix to use to transform from sensor RGB color space to output linear sRGB color space.

Type: rational[3*3]

This tag may appear in:

ACameraMetadata from ACameraCaptureSession_captureCallback_result callbacks
ACaptureRequest
This matrix is either set by the camera device when the request ACAMERA_COLOR_CORRECTION_MODE is not TRANSFORM_MATRIX, or directly by the application in the request when the ACAMERA_COLOR_CORRECTION_MODE is TRANSFORM_MATRIX.

In the latter case, the camera device may round the matrix to account for precision issues; the final rounded matrix should be reported back in this matrix result metadata. The transform should keep the magnitude of the output color values within [0, 1.0] (assuming input color values is within the normalized range [0, 1.0]), or clipping may occur.

The valid range of each matrix element varies on different devices, but values within [-1.5, 3.0] are guaranteed not to be clipped.

See also: ACAMERA_COLOR_CORRECTION_MODE

ACAMERA_CONTROL_AE_ANTIBANDING_MODE	
The desired setting for the camera device's auto-exposure algorithm's antibanding compensation.

Type: byte (acamera_metadata_enum_android_control_ae_antibanding_mode_t)

This tag may appear in:

ACameraMetadata from ACameraCaptureSession_captureCallback_result callbacks
ACaptureRequest
Some kinds of lighting fixtures, such as some fluorescent lights, flicker at the rate of the power supply frequency (60Hz or 50Hz, depending on country). While this is typically not noticeable to a person, it can be visible to a camera device. If a camera sets its exposure time to the wrong value, the flicker may become visible in the viewfinder as flicker or in a final captured image, as a set of variable-brightness bands across the image.

Therefore, the auto-exposure routines of camera devices include antibanding routines that ensure that the chosen exposure value will not cause such banding. The choice of exposure time depends on the rate of flicker, which the camera device can detect automatically, or the expected rate can be selected by the application using this control.

A given camera device may not support all of the possible options for the antibanding mode. The ACAMERA_CONTROL_AE_AVAILABLE_ANTIBANDING_MODES key contains the available modes for a given camera device.

AUTO mode is the default if it is available on given camera device. When AUTO mode is not available, the default will be either 50HZ or 60HZ, and both 50HZ and 60HZ will be available.

If manual exposure control is enabled (by setting ACAMERA_CONTROL_AE_MODE or ACAMERA_CONTROL_MODE to OFF), then this setting has no effect, and the application must ensure it selects exposure times that do not cause banding issues. The ACAMERA_STATISTICS_SCENE_FLICKER key can assist the application in this.

See also: ACAMERA_CONTROL_AE_AVAILABLE_ANTIBANDING_MODES See also: ACAMERA_CONTROL_AE_MODE See also: ACAMERA_CONTROL_MODE See also: ACAMERA_STATISTICS_SCENE_FLICKER

ACAMERA_CONTROL_AE_AVAILABLE_ANTIBANDING_MODES	
List of auto-exposure antibanding modes for ACAMERA_CONTROL_AE_ANTIBANDING_MODE that are supported by this camera device.

See also: ACAMERA_CONTROL_AE_ANTIBANDING_MODE

Type: byte[n]

This tag may appear in:

ACameraMetadata from ACameraManager_getCameraCharacteristics
Not all of the auto-exposure anti-banding modes may be supported by a given camera device. This field lists the valid anti-banding modes that the application may request for this camera device with the ACAMERA_CONTROL_AE_ANTIBANDING_MODE control.

See also: ACAMERA_CONTROL_AE_ANTIBANDING_MODE

ACAMERA_CONTROL_AE_AVAILABLE_MODES	
List of auto-exposure modes for ACAMERA_CONTROL_AE_MODE that are supported by this camera device.

See also: ACAMERA_CONTROL_AE_MODE

Type: byte[n]

This tag may appear in:

ACameraMetadata from ACameraManager_getCameraCharacteristics
Not all the auto-exposure modes may be supported by a given camera device, especially if no flash unit is available. This entry lists the valid modes for ACAMERA_CONTROL_AE_MODE for this camera device.

All camera devices support ON, and all camera devices with flash units support ON_AUTO_FLASH and ON_ALWAYS_FLASH.

FULL mode camera devices always support OFF mode, which enables application control of camera exposure time, sensitivity, and frame duration.

LEGACY mode camera devices never support OFF mode. LIMITED mode devices support OFF if they support the MANUAL_SENSOR capability.

See also: ACAMERA_CONTROL_AE_MODE

ACAMERA_CONTROL_AE_AVAILABLE_TARGET_FPS_RANGES	
List of frame rate ranges for ACAMERA_CONTROL_AE_TARGET_FPS_RANGE supported by this camera device.

See also: ACAMERA_CONTROL_AE_TARGET_FPS_RANGE

Type: int32[2*n]

This tag may appear in:

ACameraMetadata from ACameraManager_getCameraCharacteristics
For devices at the LEGACY level or above:

For constant-framerate recording, for each normal CamcorderProfile, that is, a CamcorderProfile that has quality in the range [QUALITY_LOW, QUALITY_2160P], if the profile is supported by the device and has videoFrameRatex, this list will always include (x,x).
Also, a camera device must either not support any CamcorderProfile, or support at least one normal CamcorderProfile that has videoFrameRatex >= 24.
For devices at the LIMITED level or above:

For devices that advertise NIR color filter arrangement in ACAMERA_SENSOR_INFO_COLOR_FILTER_ARRANGEMENT, this list will always include (max, max) where max = the maximum output frame rate of the maximum YUV_420_888 output size.
For devices advertising any color filter arrangement other than NIR, or devices not advertising color filter arrangement, this list will always include (min, max) and (max, max) where min <= 15 and max = the maximum output frame rate of the maximum YUV_420_888 output size.
See also: ACAMERA_SENSOR_INFO_COLOR_FILTER_ARRANGEMENT

ACAMERA_CONTROL_AE_COMPENSATION_RANGE	
Maximum and minimum exposure compensation values for ACAMERA_CONTROL_AE_EXPOSURE_COMPENSATION, in counts of ACAMERA_CONTROL_AE_COMPENSATION_STEP, that are supported by this camera device.

See also: ACAMERA_CONTROL_AE_COMPENSATION_STEP See also: ACAMERA_CONTROL_AE_EXPOSURE_COMPENSATION

Type: int32[2]

This tag may appear in:

ACameraMetadata from ACameraManager_getCameraCharacteristics
ACAMERA_CONTROL_AE_COMPENSATION_STEP	
Smallest step by which the exposure compensation can be changed.

Type: rational

This tag may appear in:

ACameraMetadata from ACameraManager_getCameraCharacteristics
This is the unit for ACAMERA_CONTROL_AE_EXPOSURE_COMPENSATION. For example, if this key has a value of 1/2, then a setting of -2 for ACAMERA_CONTROL_AE_EXPOSURE_COMPENSATION means that the target EV offset for the auto-exposure routine is -1 EV.

One unit of EV compensation changes the brightness of the captured image by a factor of two. +1 EV doubles the image brightness, while -1 EV halves the image brightness.

See also: ACAMERA_CONTROL_AE_EXPOSURE_COMPENSATION

ACAMERA_CONTROL_AE_EXPOSURE_COMPENSATION	
Adjustment to auto-exposure (AE) target image brightness.

Type: int32

This tag may appear in:

ACameraMetadata from ACameraCaptureSession_captureCallback_result callbacks
ACaptureRequest
The adjustment is measured as a count of steps, with the step size defined by ACAMERA_CONTROL_AE_COMPENSATION_STEP and the allowed range by ACAMERA_CONTROL_AE_COMPENSATION_RANGE.

For example, if the exposure value (EV) step is 0.333, '6' will mean an exposure compensation of +2 EV; -3 will mean an exposure compensation of -1 EV. One EV represents a doubling of image brightness. Note that this control will only be effective if ACAMERA_CONTROL_AE_MODE != OFF. This control will take effect even when ACAMERA_CONTROL_AE_LOCK == true.

In the event of exposure compensation value being changed, camera device may take several frames to reach the newly requested exposure target. During that time, ACAMERA_CONTROL_AE_STATE field will be in the SEARCHING state. Once the new exposure target is reached, ACAMERA_CONTROL_AE_STATE will change from SEARCHING to either CONVERGED, LOCKED (if AE lock is enabled), or FLASH_REQUIRED (if the scene is too dark for still capture).

See also: ACAMERA_CONTROL_AE_COMPENSATION_RANGE See also: ACAMERA_CONTROL_AE_COMPENSATION_STEP See also: ACAMERA_CONTROL_AE_LOCK See also: ACAMERA_CONTROL_AE_MODE See also: ACAMERA_CONTROL_AE_STATE

ACAMERA_CONTROL_AE_LOCK	
Whether auto-exposure (AE) is currently locked to its latest calculated values.

Type: byte (acamera_metadata_enum_android_control_ae_lock_t)

This tag may appear in:

ACameraMetadata from ACameraCaptureSession_captureCallback_result callbacks
ACaptureRequest
When set to true (ON), the AE algorithm is locked to its latest parameters, and will not change exposure settings until the lock is set to false (OFF).

Note that even when AE is locked, the flash may be fired if the ACAMERA_CONTROL_AE_MODE is ON_AUTO_FLASH / ON_ALWAYS_FLASH / ON_AUTO_FLASH_REDEYE.

When ACAMERA_CONTROL_AE_EXPOSURE_COMPENSATION is changed, even if the AE lock is ON, the camera device will still adjust its exposure value.

If AE precapture is triggered (see ACAMERA_CONTROL_AE_PRECAPTURE_TRIGGER) when AE is already locked, the camera device will not change the exposure time (ACAMERA_SENSOR_EXPOSURE_TIME) and sensitivity (ACAMERA_SENSOR_SENSITIVITY) parameters. The flash may be fired if the ACAMERA_CONTROL_AE_MODE is ON_AUTO_FLASH/ON_AUTO_FLASH_REDEYE and the scene is too dark. If the ACAMERA_CONTROL_AE_MODE is ON_ALWAYS_FLASH, the scene may become overexposed. Similarly, AE precapture trigger CANCEL has no effect when AE is already locked.

When an AE precapture sequence is triggered, AE unlock will not be able to unlock the AE if AE is locked by the camera device internally during precapture metering sequence In other words, submitting requests with AE unlock has no effect for an ongoing precapture metering sequence. Otherwise, the precapture metering sequence will never succeed in a sequence of preview requests where AE lock is always set to false.

Since the camera device has a pipeline of in-flight requests, the settings that get locked do not necessarily correspond to the settings that were present in the latest capture result received from the camera device, since additional captures and AE updates may have occurred even before the result was sent out. If an application is switching between automatic and manual control and wishes to eliminate any flicker during the switch, the following procedure is recommended:

Starting in auto-AE mode:
Lock AE
Wait for the first result to be output that has the AE locked
Copy exposure settings from that result into a request, set the request to manual AE
Submit the capture request, proceed to run manual AE as desired.
See ACAMERA_CONTROL_AE_STATE for AE lock related state transition details.

See also: ACAMERA_CONTROL_AE_EXPOSURE_COMPENSATION See also: ACAMERA_CONTROL_AE_MODE See also: ACAMERA_CONTROL_AE_PRECAPTURE_TRIGGER See also: ACAMERA_CONTROL_AE_STATE See also: ACAMERA_SENSOR_EXPOSURE_TIME See also: ACAMERA_SENSOR_SENSITIVITY

ACAMERA_CONTROL_AE_LOCK_AVAILABLE	
Whether the camera device supports ACAMERA_CONTROL_AE_LOCK

See also: ACAMERA_CONTROL_AE_LOCK

Type: byte (acamera_metadata_enum_android_control_ae_lock_available_t)

This tag may appear in:

ACameraMetadata from ACameraManager_getCameraCharacteristics
Devices with MANUAL_SENSOR capability or BURST_CAPTURE capability will always list true. This includes FULL devices.

ACAMERA_CONTROL_AE_MODE	
The desired mode for the camera device's auto-exposure routine.

Type: byte (acamera_metadata_enum_android_control_ae_mode_t)

This tag may appear in:

ACameraMetadata from ACameraCaptureSession_captureCallback_result callbacks
ACaptureRequest
This control is only effective if ACAMERA_CONTROL_MODE is AUTO.

When set to any of the ON modes, the camera device's auto-exposure routine is enabled, overriding the application's selected exposure time, sensor sensitivity, and frame duration (ACAMERA_SENSOR_EXPOSURE_TIME, ACAMERA_SENSOR_SENSITIVITY, and ACAMERA_SENSOR_FRAME_DURATION). If one of the FLASH modes is selected, the camera device's flash unit controls are also overridden.

The FLASH modes are only available if the camera device has a flash unit (ACAMERA_FLASH_INFO_AVAILABLE is true).

If flash TORCH mode is desired, this field must be set to ON or OFF, and ACAMERA_FLASH_MODE set to TORCH.

When set to any of the ON modes, the values chosen by the camera device auto-exposure routine for the overridden fields for a given capture will be available in its CaptureResult.

See also: ACAMERA_CONTROL_MODE See also: ACAMERA_FLASH_INFO_AVAILABLE See also: ACAMERA_FLASH_MODE See also: ACAMERA_SENSOR_EXPOSURE_TIME See also: ACAMERA_SENSOR_FRAME_DURATION See also: ACAMERA_SENSOR_SENSITIVITY

ACAMERA_CONTROL_AE_PRECAPTURE_TRIGGER	
Whether the camera device will trigger a precapture metering sequence when it processes this request.

Type: byte (acamera_metadata_enum_android_control_ae_precapture_trigger_t)

This tag may appear in:

ACameraMetadata from ACameraCaptureSession_captureCallback_result callbacks
ACaptureRequest
This entry is normally set to IDLE, or is not included at all in the request settings. When included and set to START, the camera device will trigger the auto-exposure (AE) precapture metering sequence.

When set to CANCEL, the camera device will cancel any active precapture metering trigger, and return to its initial AE state. If a precapture metering sequence is already completed, and the camera device has implicitly locked the AE for subsequent still capture, the CANCEL trigger will unlock the AE and return to its initial AE state.

The precapture sequence should be triggered before starting a high-quality still capture for final metering decisions to be made, and for firing pre-capture flash pulses to estimate scene brightness and required final capture flash power, when the flash is enabled.

Normally, this entry should be set to START for only a single request, and the application should wait until the sequence completes before starting a new one.

When a precapture metering sequence is finished, the camera device may lock the auto-exposure routine internally to be able to accurately expose the subsequent still capture image (ACAMERA_CONTROL_CAPTURE_INTENT == STILL_CAPTURE). For this case, the AE may not resume normal scan if no subsequent still capture is submitted. To ensure that the AE routine restarts normal scan, the application should submit a request with ACAMERA_CONTROL_AE_LOCK == true, followed by a request with ACAMERA_CONTROL_AE_LOCK == false, if the application decides not to submit a still capture request after the precapture sequence completes. Alternatively, for API level 23 or newer devices, the CANCEL can be used to unlock the camera device internally locked AE if the application doesn't submit a still capture request after the AE precapture trigger. Note that, the CANCEL was added in API level 23, and must not be used in devices that have earlier API levels.

The exact effect of auto-exposure (AE) precapture trigger depends on the current AE mode and state; see ACAMERA_CONTROL_AE_STATE for AE precapture state transition details.

On LEGACY-level devices, the precapture trigger is not supported; capturing a high-resolution JPEG image will automatically trigger a precapture sequence before the high-resolution capture, including potentially firing a pre-capture flash.

Using the precapture trigger and the auto-focus trigger ACAMERA_CONTROL_AF_TRIGGER simultaneously is allowed. However, since these triggers often require cooperation between the auto-focus and auto-exposure routines (for example, the may need to be enabled for a focus sweep), the camera device may delay acting on a later trigger until the previous trigger has been fully handled. This may lead to longer intervals between the trigger and changes to ACAMERA_CONTROL_AE_STATE indicating the start of the precapture sequence, for example.

If both the precapture and the auto-focus trigger are activated on the same request, then the camera device will complete them in the optimal order for that device.

See also: ACAMERA_CONTROL_AE_LOCK See also: ACAMERA_CONTROL_AE_STATE See also: ACAMERA_CONTROL_AF_TRIGGER See also: ACAMERA_CONTROL_CAPTURE_INTENT

ACAMERA_CONTROL_AE_REGIONS	
List of metering areas to use for auto-exposure adjustment.

Type: int32[5*area_count]

This tag may appear in:

ACameraMetadata from ACameraCaptureSession_captureCallback_result callbacks
ACaptureRequest
Not available if android.control.maxRegionsAe is 0. Otherwise will always be present.

The maximum number of regions supported by the device is determined by the value of android.control.maxRegionsAe.

For devices not supporting ACAMERA_DISTORTION_CORRECTION_MODE control, the coordinate system always follows that of ACAMERA_SENSOR_INFO_ACTIVE_ARRAY_SIZE, with (0,0) being the top-left pixel in the active pixel array, and (ACAMERA_SENSOR_INFO_ACTIVE_ARRAY_SIZE.width - 1, ACAMERA_SENSOR_INFO_ACTIVE_ARRAY_SIZE.height - 1) being the bottom-right pixel in the active pixel array.

For devices supporting ACAMERA_DISTORTION_CORRECTION_MODE control, the coordinate system depends on the mode being set. When the distortion correction mode is OFF, the coordinate system follows ACAMERA_SENSOR_INFO_PRE_CORRECTION_ACTIVE_ARRAY_SIZE, with (0, 0) being the top-left pixel of the pre-correction active array, and (ACAMERA_SENSOR_INFO_PRE_CORRECTION_ACTIVE_ARRAY_SIZE.width - 1, ACAMERA_SENSOR_INFO_PRE_CORRECTION_ACTIVE_ARRAY_SIZE.height - 1) being the bottom-right pixel in the pre-correction active pixel array. When the distortion correction mode is not OFF, the coordinate system follows ACAMERA_SENSOR_INFO_ACTIVE_ARRAY_SIZE, with (0, 0) being the top-left pixel of the active array, and (ACAMERA_SENSOR_INFO_ACTIVE_ARRAY_SIZE.width - 1, ACAMERA_SENSOR_INFO_ACTIVE_ARRAY_SIZE.height - 1) being the bottom-right pixel in the active pixel array.

The weight must be within [0, 1000], and represents a weight for every pixel in the area. This means that a large metering area with the same weight as a smaller area will have more effect in the metering result. Metering areas can partially overlap and the camera device will add the weights in the overlap region.

The weights are relative to weights of other exposure metering regions, so if only one region is used, all non-zero weights will have the same effect. A region with 0 weight is ignored.

If all regions have 0 weight, then no specific metering area needs to be used by the camera device.

If the metering region is outside the used ACAMERA_SCALER_CROP_REGION returned in capture result metadata, the camera device will ignore the sections outside the crop region and output only the intersection rectangle as the metering region in the result metadata. If the region is entirely outside the crop region, it will be ignored and not reported in the result metadata.

When setting the AE metering regions, the application must consider the additional crop resulted from the aspect ratio differences between the preview stream and ACAMERA_SCALER_CROP_REGION. For example, if the ACAMERA_SCALER_CROP_REGION is the full active array size with 4:3 aspect ratio, and the preview stream is 16:9, the boundary of AE regions will be [0, y_crop] and [active_width, active_height - 2 * y_crop] rather than [0, 0] and [active_width, active_height], where y_crop is the additional crop due to aspect ratio mismatch.

Starting from API level 30, the coordinate system of activeArraySize or preCorrectionActiveArraySize is used to represent post-zoomRatio field of view, not pre-zoom field of view. This means that the same aeRegions values at different ACAMERA_CONTROL_ZOOM_RATIO represent different parts of the scene. The aeRegions coordinates are relative to the activeArray/preCorrectionActiveArray representing the zoomed field of view. If ACAMERA_CONTROL_ZOOM_RATIO is set to 1.0 (default), the same aeRegions at different ACAMERA_SCALER_CROP_REGION still represent the same parts of the scene as they do before. See ACAMERA_CONTROL_ZOOM_RATIO for details. Whether to use activeArraySize or preCorrectionActiveArraySize still depends on distortion correction mode.

For camera devices with the CameraMetadata::REQUEST_AVAILABLE_CAPABILITIES_ULTRA_HIGH_RESOLUTION_SENSOR capability, ACAMERA_SENSOR_INFO_ACTIVE_ARRAY_SIZE_MAXIMUM_RESOLUTION / ACAMERA_SENSOR_INFO_PRE_CORRECTION_ACTIVE_ARRAY_SIZE_MAXIMUM_RESOLUTION must be used as the coordinate system for requests where ACAMERA_SENSOR_PIXEL_MODE is set to CameraMetadata::SENSOR_PIXEL_MODE_MAXIMUM_RESOLUTION.

The data representation is int[5 * area_count]. Every five elements represent a metering region of (xmin, ymin, xmax, ymax, weight). The rectangle is defined to be inclusive on xmin and ymin, but exclusive on xmax and ymax.

See also: ACAMERA_CONTROL_ZOOM_RATIO See also: ACAMERA_DISTORTION_CORRECTION_MODE See also: ACAMERA_SCALER_CROP_REGION See also: ACAMERA_SENSOR_INFO_ACTIVE_ARRAY_SIZE See also: ACAMERA_SENSOR_INFO_ACTIVE_ARRAY_SIZE_MAXIMUM_RESOLUTION See also: ACAMERA_SENSOR_INFO_PRE_CORRECTION_ACTIVE_ARRAY_SIZE See also: ACAMERA_SENSOR_INFO_PRE_CORRECTION_ACTIVE_ARRAY_SIZE_MAXIMUM_RESOLUTION See also: ACAMERA_SENSOR_PIXEL_MODE

ACAMERA_CONTROL_AE_STATE	
Current state of the auto-exposure (AE) algorithm.

Type: byte (acamera_metadata_enum_android_control_ae_state_t)

This tag may appear in:

ACameraMetadata from ACameraCaptureSession_captureCallback_result callbacks
Switching between or enabling AE modes (ACAMERA_CONTROL_AE_MODE) always resets the AE state to INACTIVE. Similarly, switching between ACAMERA_CONTROL_MODE, or ACAMERA_CONTROL_SCENE_MODE if ACAMERA_CONTROL_MODE == USE_SCENE_MODE resets all the algorithm states to INACTIVE.

The camera device can do several state transitions between two results, if it is allowed by the state transition table. For example: INACTIVE may never actually be seen in a result.

The state in the result is the state for this image (in sync with this image): if AE state becomes CONVERGED, then the image data associated with this result should be good to use.

Below are state transition tables for different AE modes.

State	Transition Cause	New State	Notes
INACTIVE		INACTIVE	Camera device auto exposure algorithm is disabled
When ACAMERA_CONTROL_AE_MODE is AE_MODE_ON*:

State	Transition Cause	New State	Notes
INACTIVE	Camera device initiates AE scan	SEARCHING	Values changing
INACTIVE	ACAMERA_CONTROL_AE_LOCK is ON	LOCKED	Values locked
SEARCHING	Camera device finishes AE scan	CONVERGED	Good values, not changing
SEARCHING	Camera device finishes AE scan	FLASH_REQUIRED	Converged but too dark w/o flash
SEARCHING	ACAMERA_CONTROL_AE_LOCK is ON	LOCKED	Values locked
CONVERGED	Camera device initiates AE scan	SEARCHING	Values changing
CONVERGED	ACAMERA_CONTROL_AE_LOCK is ON	LOCKED	Values locked
FLASH_REQUIRED	Camera device initiates AE scan	SEARCHING	Values changing
FLASH_REQUIRED	ACAMERA_CONTROL_AE_LOCK is ON	LOCKED	Values locked
LOCKED	ACAMERA_CONTROL_AE_LOCK is OFF	SEARCHING	Values not good after unlock
LOCKED	ACAMERA_CONTROL_AE_LOCK is OFF	CONVERGED	Values good after unlock
LOCKED	ACAMERA_CONTROL_AE_LOCK is OFF	FLASH_REQUIRED	Exposure good, but too dark
PRECAPTURE	Sequence done. ACAMERA_CONTROL_AE_LOCK is OFF	CONVERGED	Ready for high-quality capture
PRECAPTURE	Sequence done. ACAMERA_CONTROL_AE_LOCK is ON	LOCKED	Ready for high-quality capture
LOCKED	aeLock is ON and aePrecaptureTrigger is START	LOCKED	Precapture trigger is ignored when AE is already locked
LOCKED	aeLock is ON and aePrecaptureTrigger is CANCEL	LOCKED	Precapture trigger is ignored when AE is already locked
Any state (excluding LOCKED)	ACAMERA_CONTROL_AE_PRECAPTURE_TRIGGER is START	PRECAPTURE	Start AE precapture metering sequence
Any state (excluding LOCKED)	ACAMERA_CONTROL_AE_PRECAPTURE_TRIGGER is CANCEL	INACTIVE	Currently active precapture metering sequence is canceled
If the camera device supports AE external flash mode (ON_EXTERNAL_FLASH is included in ACAMERA_CONTROL_AE_AVAILABLE_MODES), ACAMERA_CONTROL_AE_STATE must be FLASH_REQUIRED after the camera device finishes AE scan and it's too dark without flash.

For the above table, the camera device may skip reporting any state changes that happen without application intervention (i.e. mode switch, trigger, locking). Any state that can be skipped in that manner is called a transient state.

For example, for above AE modes (AE_MODE_ON*), in addition to the state transitions listed in above table, it is also legal for the camera device to skip one or more transient states between two results. See below table for examples:

State	Transition Cause	New State	Notes
INACTIVE	Camera device finished AE scan	CONVERGED	Values are already good, transient states are skipped by camera device.
Any state (excluding LOCKED)	ACAMERA_CONTROL_AE_PRECAPTURE_TRIGGER is START, sequence done	FLASH_REQUIRED	Converged but too dark w/o flash after a precapture sequence, transient states are skipped by camera device.
Any state (excluding LOCKED)	ACAMERA_CONTROL_AE_PRECAPTURE_TRIGGER is START, sequence done	CONVERGED	Converged after a precapture sequence, transient states are skipped by camera device.
Any state (excluding LOCKED)	ACAMERA_CONTROL_AE_PRECAPTURE_TRIGGER is CANCEL, converged	FLASH_REQUIRED	Converged but too dark w/o flash after a precapture sequence is canceled, transient states are skipped by camera device.
Any state (excluding LOCKED)	ACAMERA_CONTROL_AE_PRECAPTURE_TRIGGER is CANCEL, converged	CONVERGED	Converged after a precapture sequences canceled, transient states are skipped by camera device.
CONVERGED	Camera device finished AE scan	FLASH_REQUIRED	Converged but too dark w/o flash after a new scan, transient states are skipped by camera device.
FLASH_REQUIRED	Camera device finished AE scan	CONVERGED	Converged after a new scan, transient states are skipped by camera device.
See also: ACAMERA_CONTROL_AE_AVAILABLE_MODES See also: ACAMERA_CONTROL_AE_LOCK See also: ACAMERA_CONTROL_AE_MODE See also: ACAMERA_CONTROL_AE_PRECAPTURE_TRIGGER See also: ACAMERA_CONTROL_AE_STATE See also: ACAMERA_CONTROL_MODE See also: ACAMERA_CONTROL_SCENE_MODE
ACAMERA_CONTROL_AE_TARGET_FPS_RANGE	
Range over which the auto-exposure routine can adjust the capture frame rate to maintain good exposure.

Type: int32[2]

This tag may appear in:

ACameraMetadata from ACameraCaptureSession_captureCallback_result callbacks
ACaptureRequest
Only constrains auto-exposure (AE) algorithm, not manual control of ACAMERA_SENSOR_EXPOSURE_TIME and ACAMERA_SENSOR_FRAME_DURATION.

See also: ACAMERA_SENSOR_EXPOSURE_TIME See also: ACAMERA_SENSOR_FRAME_DURATION

ACAMERA_CONTROL_AF_AVAILABLE_MODES	
List of auto-focus (AF) modes for ACAMERA_CONTROL_AF_MODE that are supported by this camera device.

See also: ACAMERA_CONTROL_AF_MODE

Type: byte[n]

This tag may appear in:

ACameraMetadata from ACameraManager_getCameraCharacteristics
Not all the auto-focus modes may be supported by a given camera device. This entry lists the valid modes for ACAMERA_CONTROL_AF_MODE for this camera device.

All LIMITED and FULL mode camera devices will support OFF mode, and all camera devices with adjustable focuser units (ACAMERA_LENS_INFO_MINIMUM_FOCUS_DISTANCE > 0) will support AUTO mode.

LEGACY devices will support OFF mode only if they support focusing to infinity (by also setting ACAMERA_LENS_FOCUS_DISTANCE to 0.0f).

See also: ACAMERA_CONTROL_AF_MODE See also: ACAMERA_LENS_FOCUS_DISTANCE See also: ACAMERA_LENS_INFO_MINIMUM_FOCUS_DISTANCE

ACAMERA_CONTROL_AF_MODE	
Whether auto-focus (AF) is currently enabled, and what mode it is set to.

Type: byte (acamera_metadata_enum_android_control_af_mode_t)

This tag may appear in:

ACameraMetadata from ACameraCaptureSession_captureCallback_result callbacks
ACaptureRequest
Only effective if ACAMERA_CONTROL_MODE = AUTO and the lens is not fixed focus (i.e. ACAMERA_LENS_INFO_MINIMUM_FOCUS_DISTANCE > 0). Also note that when ACAMERA_CONTROL_AE_MODE is OFF, the behavior of AF is device dependent. It is recommended to lock AF by using ACAMERA_CONTROL_AF_TRIGGER before setting ACAMERA_CONTROL_AE_MODE to OFF, or set AF mode to OFF when AE is OFF.

If the lens is controlled by the camera device auto-focus algorithm, the camera device will report the current AF status in ACAMERA_CONTROL_AF_STATE in result metadata.

See also: ACAMERA_CONTROL_AE_MODE See also: ACAMERA_CONTROL_AF_STATE See also: ACAMERA_CONTROL_AF_TRIGGER See also: ACAMERA_CONTROL_MODE See also: ACAMERA_LENS_INFO_MINIMUM_FOCUS_DISTANCE

ACAMERA_CONTROL_AF_REGIONS	
List of metering areas to use for auto-focus.

Type: int32[5*area_count]

This tag may appear in:

ACameraMetadata from ACameraCaptureSession_captureCallback_result callbacks
ACaptureRequest
Not available if android.control.maxRegionsAf is 0. Otherwise will always be present.

The maximum number of focus areas supported by the device is determined by the value of android.control.maxRegionsAf.

For devices not supporting ACAMERA_DISTORTION_CORRECTION_MODE control, the coordinate system always follows that of ACAMERA_SENSOR_INFO_ACTIVE_ARRAY_SIZE, with (0,0) being the top-left pixel in the active pixel array, and (ACAMERA_SENSOR_INFO_ACTIVE_ARRAY_SIZE.width - 1, ACAMERA_SENSOR_INFO_ACTIVE_ARRAY_SIZE.height - 1) being the bottom-right pixel in the active pixel array.

For devices supporting ACAMERA_DISTORTION_CORRECTION_MODE control, the coordinate system depends on the mode being set. When the distortion correction mode is OFF, the coordinate system follows ACAMERA_SENSOR_INFO_PRE_CORRECTION_ACTIVE_ARRAY_SIZE, with (0, 0) being the top-left pixel of the pre-correction active array, and (ACAMERA_SENSOR_INFO_PRE_CORRECTION_ACTIVE_ARRAY_SIZE.width - 1, ACAMERA_SENSOR_INFO_PRE_CORRECTION_ACTIVE_ARRAY_SIZE.height - 1) being the bottom-right pixel in the pre-correction active pixel array. When the distortion correction mode is not OFF, the coordinate system follows ACAMERA_SENSOR_INFO_ACTIVE_ARRAY_SIZE, with (0, 0) being the top-left pixel of the active array, and (ACAMERA_SENSOR_INFO_ACTIVE_ARRAY_SIZE.width - 1, ACAMERA_SENSOR_INFO_ACTIVE_ARRAY_SIZE.height - 1) being the bottom-right pixel in the active pixel array.

The weight must be within [0, 1000], and represents a weight for every pixel in the area. This means that a large metering area with the same weight as a smaller area will have more effect in the metering result. Metering areas can partially overlap and the camera device will add the weights in the overlap region.

The weights are relative to weights of other metering regions, so if only one region is used, all non-zero weights will have the same effect. A region with 0 weight is ignored.

If all regions have 0 weight, then no specific metering area needs to be used by the camera device. The capture result will either be a zero weight region as well, or the region selected by the camera device as the focus area of interest.

If the metering region is outside the used ACAMERA_SCALER_CROP_REGION returned in capture result metadata, the camera device will ignore the sections outside the crop region and output only the intersection rectangle as the metering region in the result metadata. If the region is entirely outside the crop region, it will be ignored and not reported in the result metadata.

When setting the AF metering regions, the application must consider the additional crop resulted from the aspect ratio differences between the preview stream and ACAMERA_SCALER_CROP_REGION. For example, if the ACAMERA_SCALER_CROP_REGION is the full active array size with 4:3 aspect ratio, and the preview stream is 16:9, the boundary of AF regions will be [0, y_crop] and [active_width, active_height - 2 * y_crop] rather than [0, 0] and [active_width, active_height], where y_crop is the additional crop due to aspect ratio mismatch.

Starting from API level 30, the coordinate system of activeArraySize or preCorrectionActiveArraySize is used to represent post-zoomRatio field of view, not pre-zoom field of view. This means that the same afRegions values at different ACAMERA_CONTROL_ZOOM_RATIO represent different parts of the scene. The afRegions coordinates are relative to the activeArray/preCorrectionActiveArray representing the zoomed field of view. If ACAMERA_CONTROL_ZOOM_RATIO is set to 1.0 (default), the same afRegions at different ACAMERA_SCALER_CROP_REGION still represent the same parts of the scene as they do before. See ACAMERA_CONTROL_ZOOM_RATIO for details. Whether to use activeArraySize or preCorrectionActiveArraySize still depends on distortion correction mode.

For camera devices with the CameraMetadata::REQUEST_AVAILABLE_CAPABILITIES_ULTRA_HIGH_RESOLUTION_SENSOR capability, ACAMERA_SENSOR_INFO_ACTIVE_ARRAY_SIZE_MAXIMUM_RESOLUTION / ACAMERA_SENSOR_INFO_PRE_CORRECTION_ACTIVE_ARRAY_SIZE_MAXIMUM_RESOLUTION must be used as the coordinate system for requests where ACAMERA_SENSOR_PIXEL_MODE is set to CameraMetadata::SENSOR_PIXEL_MODE_MAXIMUM_RESOLUTION.

The data representation is int[5 * area_count]. Every five elements represent a metering region of (xmin, ymin, xmax, ymax, weight). The rectangle is defined to be inclusive on xmin and ymin, but exclusive on xmax and ymax.

See also: ACAMERA_CONTROL_ZOOM_RATIO See also: ACAMERA_DISTORTION_CORRECTION_MODE See also: ACAMERA_SCALER_CROP_REGION See also: ACAMERA_SENSOR_INFO_ACTIVE_ARRAY_SIZE See also: ACAMERA_SENSOR_INFO_ACTIVE_ARRAY_SIZE_MAXIMUM_RESOLUTION See also: ACAMERA_SENSOR_INFO_PRE_CORRECTION_ACTIVE_ARRAY_SIZE See also: ACAMERA_SENSOR_INFO_PRE_CORRECTION_ACTIVE_ARRAY_SIZE_MAXIMUM_RESOLUTION See also: ACAMERA_SENSOR_PIXEL_MODE

ACAMERA_CONTROL_AF_SCENE_CHANGE	
Whether a significant scene change is detected within the currently-set AF region(s).

Type: byte (acamera_metadata_enum_android_control_af_scene_change_t)

This tag may appear in:

ACameraMetadata from ACameraCaptureSession_captureCallback_result callbacks
When the camera focus routine detects a change in the scene it is looking at, such as a large shift in camera viewpoint, significant motion in the scene, or a significant illumination change, this value will be set to DETECTED for a single capture result. Otherwise the value will be NOT_DETECTED. The threshold for detection is similar to what would trigger a new passive focus scan to begin in CONTINUOUS autofocus modes.

This key will be available if the camera device advertises this key via ACAMERA_REQUEST_AVAILABLE_RESULT_KEYS.

ACAMERA_CONTROL_AF_STATE	
Current state of auto-focus (AF) algorithm.

Type: byte (acamera_metadata_enum_android_control_af_state_t)

This tag may appear in:

ACameraMetadata from ACameraCaptureSession_captureCallback_result callbacks
Switching between or enabling AF modes (ACAMERA_CONTROL_AF_MODE) always resets the AF state to INACTIVE. Similarly, switching between ACAMERA_CONTROL_MODE, or ACAMERA_CONTROL_SCENE_MODE if ACAMERA_CONTROL_MODE == USE_SCENE_MODE resets all the algorithm states to INACTIVE.

The camera device can do several state transitions between two results, if it is allowed by the state transition table. For example: INACTIVE may never actually be seen in a result.

The state in the result is the state for this image (in sync with this image): if AF state becomes FOCUSED, then the image data associated with this result should be sharp.

Below are state transition tables for different AF modes.

When ACAMERA_CONTROL_AF_MODE is AF_MODE_OFF or AF_MODE_EDOF:

State	Transition Cause	New State	Notes
INACTIVE		INACTIVE	Never changes
When ACAMERA_CONTROL_AF_MODE is AF_MODE_AUTO or AF_MODE_MACRO:

State	Transition Cause	New State	Notes
INACTIVE	AF_TRIGGER	ACTIVE_SCAN	Start AF sweep, Lens now moving
ACTIVE_SCAN	AF sweep done	FOCUSED_LOCKED	Focused, Lens now locked
ACTIVE_SCAN	AF sweep done	NOT_FOCUSED_LOCKED	Not focused, Lens now locked
ACTIVE_SCAN	AF_CANCEL	INACTIVE	Cancel/reset AF, Lens now locked
FOCUSED_LOCKED	AF_CANCEL	INACTIVE	Cancel/reset AF
FOCUSED_LOCKED	AF_TRIGGER	ACTIVE_SCAN	Start new sweep, Lens now moving
NOT_FOCUSED_LOCKED	AF_CANCEL	INACTIVE	Cancel/reset AF
NOT_FOCUSED_LOCKED	AF_TRIGGER	ACTIVE_SCAN	Start new sweep, Lens now moving
Any state	Mode change	INACTIVE	
For the above table, the camera device may skip reporting any state changes that happen without application intervention (i.e. mode switch, trigger, locking). Any state that can be skipped in that manner is called a transient state.

For example, for these AF modes (AF_MODE_AUTO and AF_MODE_MACRO), in addition to the state transitions listed in above table, it is also legal for the camera device to skip one or more transient states between two results. See below table for examples:

State	Transition Cause	New State	Notes
INACTIVE	AF_TRIGGER	FOCUSED_LOCKED	Focus is already good or good after a scan, lens is now locked.
INACTIVE	AF_TRIGGER	NOT_FOCUSED_LOCKED	Focus failed after a scan, lens is now locked.
FOCUSED_LOCKED	AF_TRIGGER	FOCUSED_LOCKED	Focus is already good or good after a scan, lens is now locked.
NOT_FOCUSED_LOCKED	AF_TRIGGER	FOCUSED_LOCKED	Focus is good after a scan, lens is not locked.
When ACAMERA_CONTROL_AF_MODE is AF_MODE_CONTINUOUS_VIDEO:

State	Transition Cause	New State	Notes
INACTIVE	Camera device initiates new scan	PASSIVE_SCAN	Start AF scan, Lens now moving
INACTIVE	AF_TRIGGER	NOT_FOCUSED_LOCKED	AF state query, Lens now locked
PASSIVE_SCAN	Camera device completes current scan	PASSIVE_FOCUSED	End AF scan, Lens now locked
PASSIVE_SCAN	Camera device fails current scan	PASSIVE_UNFOCUSED	End AF scan, Lens now locked
PASSIVE_SCAN	AF_TRIGGER	FOCUSED_LOCKED	Immediate transition, if focus is good. Lens now locked
PASSIVE_SCAN	AF_TRIGGER	NOT_FOCUSED_LOCKED	Immediate transition, if focus is bad. Lens now locked
PASSIVE_SCAN	AF_CANCEL	INACTIVE	Reset lens position, Lens now locked
PASSIVE_FOCUSED	Camera device initiates new scan	PASSIVE_SCAN	Start AF scan, Lens now moving
PASSIVE_UNFOCUSED	Camera device initiates new scan	PASSIVE_SCAN	Start AF scan, Lens now moving
PASSIVE_FOCUSED	AF_TRIGGER	FOCUSED_LOCKED	Immediate transition, lens now locked
PASSIVE_UNFOCUSED	AF_TRIGGER	NOT_FOCUSED_LOCKED	Immediate transition, lens now locked
FOCUSED_LOCKED	AF_TRIGGER	FOCUSED_LOCKED	No effect
FOCUSED_LOCKED	AF_CANCEL	INACTIVE	Restart AF scan
NOT_FOCUSED_LOCKED	AF_TRIGGER	NOT_FOCUSED_LOCKED	No effect
NOT_FOCUSED_LOCKED	AF_CANCEL	INACTIVE	Restart AF scan
When ACAMERA_CONTROL_AF_MODE is AF_MODE_CONTINUOUS_PICTURE:

State	Transition Cause	New State	Notes
INACTIVE	Camera device initiates new scan	PASSIVE_SCAN	Start AF scan, Lens now moving
INACTIVE	AF_TRIGGER	NOT_FOCUSED_LOCKED	AF state query, Lens now locked
PASSIVE_SCAN	Camera device completes current scan	PASSIVE_FOCUSED	End AF scan, Lens now locked
PASSIVE_SCAN	Camera device fails current scan	PASSIVE_UNFOCUSED	End AF scan, Lens now locked
PASSIVE_SCAN	AF_TRIGGER	FOCUSED_LOCKED	Eventual transition once the focus is good. Lens now locked
PASSIVE_SCAN	AF_TRIGGER	NOT_FOCUSED_LOCKED	Eventual transition if cannot find focus. Lens now locked
PASSIVE_SCAN	AF_CANCEL	INACTIVE	Reset lens position, Lens now locked
PASSIVE_FOCUSED	Camera device initiates new scan	PASSIVE_SCAN	Start AF scan, Lens now moving
PASSIVE_UNFOCUSED	Camera device initiates new scan	PASSIVE_SCAN	Start AF scan, Lens now moving
PASSIVE_FOCUSED	AF_TRIGGER	FOCUSED_LOCKED	Immediate trans. Lens now locked
PASSIVE_UNFOCUSED	AF_TRIGGER	NOT_FOCUSED_LOCKED	Immediate trans. Lens now locked
FOCUSED_LOCKED	AF_TRIGGER	FOCUSED_LOCKED	No effect
FOCUSED_LOCKED	AF_CANCEL	INACTIVE	Restart AF scan
NOT_FOCUSED_LOCKED	AF_TRIGGER	NOT_FOCUSED_LOCKED	No effect
NOT_FOCUSED_LOCKED	AF_CANCEL	INACTIVE	Restart AF scan
When switch between AF_MODE_CONTINUOUS_* (CAF modes) and AF_MODE_AUTO/AF_MODE_MACRO (AUTO modes), the initial INACTIVE or PASSIVE_SCAN states may be skipped by the camera device. When a trigger is included in a mode switch request, the trigger will be evaluated in the context of the new mode in the request. See below table for examples:

State	Transition Cause	New State	Notes
any state	CAF>AUTO mode switch	INACTIVE	Mode switch without trigger, initial state must be INACTIVE
any state	CAF>AUTO mode switch with AF_TRIGGER	trigger-reachable states from INACTIVE	Mode switch with trigger, INACTIVE is skipped
any state	AUTO>CAF mode switch	passively reachable states from INACTIVE	Mode switch without trigger, passive transient state is skipped
See also: ACAMERA_CONTROL_AF_MODE See also: ACAMERA_CONTROL_MODE See also: ACAMERA_CONTROL_SCENE_MODE
ACAMERA_CONTROL_AF_TRIGGER	
Whether the camera device will trigger autofocus for this request.

Type: byte (acamera_metadata_enum_android_control_af_trigger_t)

This tag may appear in:

ACameraMetadata from ACameraCaptureSession_captureCallback_result callbacks
ACaptureRequest
This entry is normally set to IDLE, or is not included at all in the request settings.

When included and set to START, the camera device will trigger the autofocus algorithm. If autofocus is disabled, this trigger has no effect.

When set to CANCEL, the camera device will cancel any active trigger, and return to its initial AF state.

Generally, applications should set this entry to START or CANCEL for only a single capture, and then return it to IDLE (or not set at all). Specifying START for multiple captures in a row means restarting the AF operation over and over again.

See ACAMERA_CONTROL_AF_STATE for what the trigger means for each AF mode.

Using the autofocus trigger and the precapture trigger ACAMERA_CONTROL_AE_PRECAPTURE_TRIGGER simultaneously is allowed. However, since these triggers often require cooperation between the auto-focus and auto-exposure routines (for example, the may need to be enabled for a focus sweep), the camera device may delay acting on a later trigger until the previous trigger has been fully handled. This may lead to longer intervals between the trigger and changes to ACAMERA_CONTROL_AF_STATE, for example.

See also: ACAMERA_CONTROL_AE_PRECAPTURE_TRIGGER See also: ACAMERA_CONTROL_AF_STATE

ACAMERA_CONTROL_AVAILABLE_EFFECTS	
List of color effects for ACAMERA_CONTROL_EFFECT_MODE that are supported by this camera device.

See also: ACAMERA_CONTROL_EFFECT_MODE

Type: byte[n]

This tag may appear in:

ACameraMetadata from ACameraManager_getCameraCharacteristics
This list contains the color effect modes that can be applied to images produced by the camera device. Implementations are not expected to be consistent across all devices. If no color effect modes are available for a device, this will only list OFF.

A color effect will only be applied if ACAMERA_CONTROL_MODE != OFF. OFF is always included in this list.

This control has no effect on the operation of other control routines such as auto-exposure, white balance, or focus.

See also: ACAMERA_CONTROL_MODE

ACAMERA_CONTROL_AVAILABLE_EXTENDED_SCENE_MODE_MAX_SIZES	
The list of extended scene modes for ACAMERA_CONTROL_EXTENDED_SCENE_MODE that are supported by this camera device, and each extended scene mode's maximum streaming (non-stall) size with effect.

See also: ACAMERA_CONTROL_EXTENDED_SCENE_MODE

Type: int32[3*n]

This tag may appear in:

ACameraMetadata from ACameraManager_getCameraCharacteristics
For DISABLED mode, the camera behaves normally with no extended scene mode enabled.

For BOKEH_STILL_CAPTURE mode, the maximum streaming dimension specifies the limit under which bokeh is effective when capture intent is PREVIEW. Note that when capture intent is PREVIEW, the bokeh effect may not be as high in quality compared to STILL_CAPTURE intent in order to maintain reasonable frame rate. The maximum streaming dimension must be one of the YUV_420_888 or PRIVATE resolutions in availableStreamConfigurations, or (0, 0) if preview bokeh is not supported. If the application configures a stream larger than the maximum streaming dimension, bokeh effect may not be applied for this stream for PREVIEW intent.

For BOKEH_CONTINUOUS mode, the maximum streaming dimension specifies the limit under which bokeh is effective. This dimension must be one of the YUV_420_888 or PRIVATE resolutions in availableStreamConfigurations, and if the sensor maximum resolution is larger than or equal to 1080p, the maximum streaming dimension must be at least 1080p. If the application configures a stream with larger dimension, the stream may not have bokeh effect applied.

ACAMERA_CONTROL_AVAILABLE_EXTENDED_SCENE_MODE_ZOOM_RATIO_RANGES	
The ranges of supported zoom ratio for non-DISABLED ACAMERA_CONTROL_EXTENDED_SCENE_MODE.

See also: ACAMERA_CONTROL_EXTENDED_SCENE_MODE

Type: float[2*n]

This tag may appear in:

ACameraMetadata from ACameraManager_getCameraCharacteristics
When extended scene mode is set, the camera device may have limited range of zoom ratios compared to when extended scene mode is DISABLED. This tag lists the zoom ratio ranges for all supported non-DISABLED extended scene modes, in the same order as in android.control.availableExtended.

Range [1.0, 1.0] means that no zoom (optical or digital) is supported.

ACAMERA_CONTROL_AVAILABLE_MODES	
List of control modes for ACAMERA_CONTROL_MODE that are supported by this camera device.

See also: ACAMERA_CONTROL_MODE

Type: byte[n]

This tag may appear in:

ACameraMetadata from ACameraManager_getCameraCharacteristics
This list contains control modes that can be set for the camera device. LEGACY mode devices will always support AUTO mode. LIMITED and FULL devices will always support OFF, AUTO modes.

ACAMERA_CONTROL_AVAILABLE_SCENE_MODES	
List of scene modes for ACAMERA_CONTROL_SCENE_MODE that are supported by this camera device.

See also: ACAMERA_CONTROL_SCENE_MODE

Type: byte[n]

This tag may appear in:

ACameraMetadata from ACameraManager_getCameraCharacteristics
This list contains scene modes that can be set for the camera device. Only scene modes that have been fully implemented for the camera device may be included here. Implementations are not expected to be consistent across all devices.

If no scene modes are supported by the camera device, this will be set to DISABLED. Otherwise DISABLED will not be listed.

FACE_PRIORITY is always listed if face detection is supported (i.e.ACAMERA_STATISTICS_INFO_MAX_FACE_COUNT > 0).

See also: ACAMERA_STATISTICS_INFO_MAX_FACE_COUNT

ACAMERA_CONTROL_AVAILABLE_VIDEO_STABILIZATION_MODES	
List of video stabilization modes for ACAMERA_CONTROL_VIDEO_STABILIZATION_MODE that are supported by this camera device.

See also: ACAMERA_CONTROL_VIDEO_STABILIZATION_MODE

Type: byte[n]

This tag may appear in:

ACameraMetadata from ACameraManager_getCameraCharacteristics
OFF will always be listed.

ACAMERA_CONTROL_AWB_AVAILABLE_MODES	
List of auto-white-balance modes for ACAMERA_CONTROL_AWB_MODE that are supported by this camera device.

See also: ACAMERA_CONTROL_AWB_MODE

Type: byte[n]

This tag may appear in:

ACameraMetadata from ACameraManager_getCameraCharacteristics
Not all the auto-white-balance modes may be supported by a given camera device. This entry lists the valid modes for ACAMERA_CONTROL_AWB_MODE for this camera device.

All camera devices will support ON mode.

Camera devices that support the MANUAL_POST_PROCESSING capability will always support OFF mode, which enables application control of white balance, by using ACAMERA_COLOR_CORRECTION_TRANSFORM and ACAMERA_COLOR_CORRECTION_GAINS(ACAMERA_COLOR_CORRECTION_MODE must be set to TRANSFORM_MATRIX). This includes all FULL mode camera devices.

See also: ACAMERA_COLOR_CORRECTION_GAINS See also: ACAMERA_COLOR_CORRECTION_MODE See also: ACAMERA_COLOR_CORRECTION_TRANSFORM See also: ACAMERA_CONTROL_AWB_MODE

ACAMERA_CONTROL_AWB_LOCK	
Whether auto-white balance (AWB) is currently locked to its latest calculated values.

Type: byte (acamera_metadata_enum_android_control_awb_lock_t)

This tag may appear in:

ACameraMetadata from ACameraCaptureSession_captureCallback_result callbacks
ACaptureRequest
When set to true (ON), the AWB algorithm is locked to its latest parameters, and will not change color balance settings until the lock is set to false (OFF).

Since the camera device has a pipeline of in-flight requests, the settings that get locked do not necessarily correspond to the settings that were present in the latest capture result received from the camera device, since additional captures and AWB updates may have occurred even before the result was sent out. If an application is switching between automatic and manual control and wishes to eliminate any flicker during the switch, the following procedure is recommended:

Starting in auto-AWB mode:
Lock AWB
Wait for the first result to be output that has the AWB locked
Copy AWB settings from that result into a request, set the request to manual AWB
Submit the capture request, proceed to run manual AWB as desired.
Note that AWB lock is only meaningful when ACAMERA_CONTROL_AWB_MODE is in the AUTO mode; in other modes, AWB is already fixed to a specific setting.

Some LEGACY devices may not support ON; the value is then overridden to OFF.

See also: ACAMERA_CONTROL_AWB_MODE

ACAMERA_CONTROL_AWB_LOCK_AVAILABLE	
Whether the camera device supports ACAMERA_CONTROL_AWB_LOCK

See also: ACAMERA_CONTROL_AWB_LOCK

Type: byte (acamera_metadata_enum_android_control_awb_lock_available_t)

This tag may appear in:

ACameraMetadata from ACameraManager_getCameraCharacteristics
Devices with MANUAL_POST_PROCESSING capability or BURST_CAPTURE capability will always list true. This includes FULL devices.

ACAMERA_CONTROL_AWB_MODE	
Whether auto-white balance (AWB) is currently setting the color transform fields, and what its illumination target is.

Type: byte (acamera_metadata_enum_android_control_awb_mode_t)

This tag may appear in:

ACameraMetadata from ACameraCaptureSession_captureCallback_result callbacks
ACaptureRequest
This control is only effective if ACAMERA_CONTROL_MODE is AUTO.

When set to the AUTO mode, the camera device's auto-white balance routine is enabled, overriding the application's selected ACAMERA_COLOR_CORRECTION_TRANSFORM, ACAMERA_COLOR_CORRECTION_GAINS and ACAMERA_COLOR_CORRECTION_MODE. Note that when ACAMERA_CONTROL_AE_MODE is OFF, the behavior of AWB is device dependent. It is recommended to also set AWB mode to OFF or lock AWB by using ACAMERA_CONTROL_AWB_LOCK before setting AE mode to OFF.

When set to the OFF mode, the camera device's auto-white balance routine is disabled. The application manually controls the white balance by ACAMERA_COLOR_CORRECTION_TRANSFORM, ACAMERA_COLOR_CORRECTION_GAINS and ACAMERA_COLOR_CORRECTION_MODE.

When set to any other modes, the camera device's auto-white balance routine is disabled. The camera device uses each particular illumination target for white balance adjustment. The application's values for ACAMERA_COLOR_CORRECTION_TRANSFORM, ACAMERA_COLOR_CORRECTION_GAINS and ACAMERA_COLOR_CORRECTION_MODE are ignored.

See also: ACAMERA_COLOR_CORRECTION_GAINS See also: ACAMERA_COLOR_CORRECTION_MODE See also: ACAMERA_COLOR_CORRECTION_TRANSFORM See also: ACAMERA_CONTROL_AE_MODE See also: ACAMERA_CONTROL_AWB_LOCK See also: ACAMERA_CONTROL_MODE

ACAMERA_CONTROL_AWB_REGIONS	
List of metering areas to use for auto-white-balance illuminant estimation.

Type: int32[5*area_count]

This tag may appear in:

ACameraMetadata from ACameraCaptureSession_captureCallback_result callbacks
ACaptureRequest
Not available if android.control.maxRegionsAwb is 0. Otherwise will always be present.

The maximum number of regions supported by the device is determined by the value of android.control.maxRegionsAwb.

For devices not supporting ACAMERA_DISTORTION_CORRECTION_MODE control, the coordinate system always follows that of ACAMERA_SENSOR_INFO_ACTIVE_ARRAY_SIZE, with (0,0) being the top-left pixel in the active pixel array, and (ACAMERA_SENSOR_INFO_ACTIVE_ARRAY_SIZE.width - 1, ACAMERA_SENSOR_INFO_ACTIVE_ARRAY_SIZE.height - 1) being the bottom-right pixel in the active pixel array.

For devices supporting ACAMERA_DISTORTION_CORRECTION_MODE control, the coordinate system depends on the mode being set. When the distortion correction mode is OFF, the coordinate system follows ACAMERA_SENSOR_INFO_PRE_CORRECTION_ACTIVE_ARRAY_SIZE, with (0, 0) being the top-left pixel of the pre-correction active array, and (ACAMERA_SENSOR_INFO_PRE_CORRECTION_ACTIVE_ARRAY_SIZE.width - 1, ACAMERA_SENSOR_INFO_PRE_CORRECTION_ACTIVE_ARRAY_SIZE.height - 1) being the bottom-right pixel in the pre-correction active pixel array. When the distortion correction mode is not OFF, the coordinate system follows ACAMERA_SENSOR_INFO_ACTIVE_ARRAY_SIZE, with (0, 0) being the top-left pixel of the active array, and (ACAMERA_SENSOR_INFO_ACTIVE_ARRAY_SIZE.width - 1, ACAMERA_SENSOR_INFO_ACTIVE_ARRAY_SIZE.height - 1) being the bottom-right pixel in the active pixel array.

The weight must range from 0 to 1000, and represents a weight for every pixel in the area. This means that a large metering area with the same weight as a smaller area will have more effect in the metering result. Metering areas can partially overlap and the camera device will add the weights in the overlap region.

The weights are relative to weights of other white balance metering regions, so if only one region is used, all non-zero weights will have the same effect. A region with 0 weight is ignored.

If all regions have 0 weight, then no specific metering area needs to be used by the camera device.

If the metering region is outside the used ACAMERA_SCALER_CROP_REGION returned in capture result metadata, the camera device will ignore the sections outside the crop region and output only the intersection rectangle as the metering region in the result metadata. If the region is entirely outside the crop region, it will be ignored and not reported in the result metadata.

When setting the AWB metering regions, the application must consider the additional crop resulted from the aspect ratio differences between the preview stream and ACAMERA_SCALER_CROP_REGION. For example, if the ACAMERA_SCALER_CROP_REGION is the full active array size with 4:3 aspect ratio, and the preview stream is 16:9, the boundary of AWB regions will be [0, y_crop] and [active_width, active_height - 2 * y_crop] rather than [0, 0] and [active_width, active_height], where y_crop is the additional crop due to aspect ratio mismatch.

Starting from API level 30, the coordinate system of activeArraySize or preCorrectionActiveArraySize is used to represent post-zoomRatio field of view, not pre-zoom field of view. This means that the same awbRegions values at different ACAMERA_CONTROL_ZOOM_RATIO represent different parts of the scene. The awbRegions coordinates are relative to the activeArray/preCorrectionActiveArray representing the zoomed field of view. If ACAMERA_CONTROL_ZOOM_RATIO is set to 1.0 (default), the same awbRegions at different ACAMERA_SCALER_CROP_REGION still represent the same parts of the scene as they do before. See ACAMERA_CONTROL_ZOOM_RATIO for details. Whether to use activeArraySize or preCorrectionActiveArraySize still depends on distortion correction mode.

For camera devices with the CameraMetadata::REQUEST_AVAILABLE_CAPABILITIES_ULTRA_HIGH_RESOLUTION_SENSOR capability, ACAMERA_SENSOR_INFO_ACTIVE_ARRAY_SIZE_MAXIMUM_RESOLUTION / ACAMERA_SENSOR_INFO_PRE_CORRECTION_ACTIVE_ARRAY_SIZE_MAXIMUM_RESOLUTION must be used as the coordinate system for requests where ACAMERA_SENSOR_PIXEL_MODE is set to CameraMetadata::SENSOR_PIXEL_MODE_MAXIMUM_RESOLUTION.

The data representation is int[5 * area_count]. Every five elements represent a metering region of (xmin, ymin, xmax, ymax, weight). The rectangle is defined to be inclusive on xmin and ymin, but exclusive on xmax and ymax.

See also: ACAMERA_CONTROL_ZOOM_RATIO See also: ACAMERA_DISTORTION_CORRECTION_MODE See also: ACAMERA_SCALER_CROP_REGION See also: ACAMERA_SENSOR_INFO_ACTIVE_ARRAY_SIZE See also: ACAMERA_SENSOR_INFO_ACTIVE_ARRAY_SIZE_MAXIMUM_RESOLUTION See also: ACAMERA_SENSOR_INFO_PRE_CORRECTION_ACTIVE_ARRAY_SIZE See also: ACAMERA_SENSOR_INFO_PRE_CORRECTION_ACTIVE_ARRAY_SIZE_MAXIMUM_RESOLUTION See also: ACAMERA_SENSOR_PIXEL_MODE

ACAMERA_CONTROL_AWB_STATE	
Current state of auto-white balance (AWB) algorithm.

Type: byte (acamera_metadata_enum_android_control_awb_state_t)

This tag may appear in:

ACameraMetadata from ACameraCaptureSession_captureCallback_result callbacks
Switching between or enabling AWB modes (ACAMERA_CONTROL_AWB_MODE) always resets the AWB state to INACTIVE. Similarly, switching between ACAMERA_CONTROL_MODE, or ACAMERA_CONTROL_SCENE_MODE if ACAMERA_CONTROL_MODE == USE_SCENE_MODE resets all the algorithm states to INACTIVE.

The camera device can do several state transitions between two results, if it is allowed by the state transition table. So INACTIVE may never actually be seen in a result.

The state in the result is the state for this image (in sync with this image): if AWB state becomes CONVERGED, then the image data associated with this result should be good to use.

Below are state transition tables for different AWB modes.

When ACAMERA_CONTROL_AWB_MODE != AWB_MODE_AUTO:

State	Transition Cause	New State	Notes
INACTIVE		INACTIVE	Camera device auto white balance algorithm is disabled
When ACAMERA_CONTROL_AWB_MODE is AWB_MODE_AUTO:

State	Transition Cause	New State	Notes
INACTIVE	Camera device initiates AWB scan	SEARCHING	Values changing
INACTIVE	ACAMERA_CONTROL_AWB_LOCK is ON	LOCKED	Values locked
SEARCHING	Camera device finishes AWB scan	CONVERGED	Good values, not changing
SEARCHING	ACAMERA_CONTROL_AWB_LOCK is ON	LOCKED	Values locked
CONVERGED	Camera device initiates AWB scan	SEARCHING	Values changing
CONVERGED	ACAMERA_CONTROL_AWB_LOCK is ON	LOCKED	Values locked
LOCKED	ACAMERA_CONTROL_AWB_LOCK is OFF	SEARCHING	Values not good after unlock
For the above table, the camera device may skip reporting any state changes that happen without application intervention (i.e. mode switch, trigger, locking). Any state that can be skipped in that manner is called a transient state.

For example, for this AWB mode (AWB_MODE_AUTO), in addition to the state transitions listed in above table, it is also legal for the camera device to skip one or more transient states between two results. See below table for examples:

State	Transition Cause	New State	Notes
INACTIVE	Camera device finished AWB scan	CONVERGED	Values are already good, transient states are skipped by camera device.
LOCKED	ACAMERA_CONTROL_AWB_LOCK is OFF	CONVERGED	Values good after unlock, transient states are skipped by camera device.
See also: ACAMERA_CONTROL_AWB_LOCK See also: ACAMERA_CONTROL_AWB_MODE See also: ACAMERA_CONTROL_MODE See also: ACAMERA_CONTROL_SCENE_MODE
ACAMERA_CONTROL_CAPTURE_INTENT	
Information to the camera device 3A (auto-exposure, auto-focus, auto-white balance) routines about the purpose of this capture, to help the camera device to decide optimal 3A strategy.

Type: byte (acamera_metadata_enum_android_control_capture_intent_t)

This tag may appear in:

ACameraMetadata from ACameraCaptureSession_captureCallback_result callbacks
ACaptureRequest
This control (except for MANUAL) is only effective if ACAMERA_CONTROL_MODE != OFF and any 3A routine is active.

All intents are supported by all devices, except that:

ZERO_SHUTTER_LAG will be supported if ACAMERA_REQUEST_AVAILABLE_CAPABILITIES contains PRIVATE_REPROCESSING or YUV_REPROCESSING.
MANUAL will be supported if ACAMERA_REQUEST_AVAILABLE_CAPABILITIES contains MANUAL_SENSOR.
MOTION_TRACKING will be supported if ACAMERA_REQUEST_AVAILABLE_CAPABILITIES contains MOTION_TRACKING.
See also: ACAMERA_CONTROL_MODE See also: ACAMERA_REQUEST_AVAILABLE_CAPABILITIES

ACAMERA_CONTROL_EFFECT_MODE	
A special color effect to apply.

Type: byte (acamera_metadata_enum_android_control_effect_mode_t)

This tag may appear in:

ACameraMetadata from ACameraCaptureSession_captureCallback_result callbacks
ACaptureRequest
When this mode is set, a color effect will be applied to images produced by the camera device. The interpretation and implementation of these color effects is left to the implementor of the camera device, and should not be depended on to be consistent (or present) across all devices.

ACAMERA_CONTROL_ENABLE_ZSL	
Allow camera device to enable zero-shutter-lag mode for requests with ACAMERA_CONTROL_CAPTURE_INTENT == STILL_CAPTURE.

See also: ACAMERA_CONTROL_CAPTURE_INTENT

Type: byte (acamera_metadata_enum_android_control_enable_zsl_t)

This tag may appear in:

ACameraMetadata from ACameraCaptureSession_captureCallback_result callbacks
ACaptureRequest
If enableZsl is true, the camera device may enable zero-shutter-lag mode for requests with STILL_CAPTURE capture intent. The camera device may use images captured in the past to produce output images for a zero-shutter-lag request. The result metadata including the ACAMERA_SENSOR_TIMESTAMP reflects the source frames used to produce output images. Therefore, the contents of the output images and the result metadata may be out of order compared to previous regular requests. enableZsl does not affect requests with other capture intents.

For example, when requests are submitted in the following order: Request A: enableZsl is ON, ACAMERA_CONTROL_CAPTURE_INTENT is PREVIEW Request B: enableZsl is ON, ACAMERA_CONTROL_CAPTURE_INTENT is STILL_CAPTURE

The output images for request B may have contents captured before the output images for request A, and the result metadata for request B may be older than the result metadata for request A.

Note that when enableZsl is true, it is not guaranteed to get output images captured in the past for requests with STILL_CAPTURE capture intent.

For applications targeting SDK versions O and newer, the value of enableZsl in TEMPLATE_STILL_CAPTURE template may be true. The value in other templates is always false if present.

For applications targeting SDK versions older than O, the value of enableZsl in all capture templates is always false if present.

For application-operated ZSL, use CAMERA3_TEMPLATE_ZERO_SHUTTER_LAG template.

See also: ACAMERA_CONTROL_CAPTURE_INTENT See also: ACAMERA_SENSOR_TIMESTAMP

ACAMERA_CONTROL_END	
ACAMERA_CONTROL_EXTENDED_SCENE_MODE	
Whether extended scene mode is enabled for a particular capture request.

Type: byte (acamera_metadata_enum_android_control_extended_scene_mode_t)

This tag may appear in:

ACameraMetadata from ACameraCaptureSession_captureCallback_result callbacks
ACaptureRequest
With bokeh mode, the camera device may blur out the parts of scene that are not in focus, creating a bokeh (or shallow depth of field) effect for people or objects.

When set to BOKEH_STILL_CAPTURE mode with STILL_CAPTURE capture intent, due to the extra processing needed for high quality bokeh effect, the stall may be longer than when capture intent is not STILL_CAPTURE.

When set to BOKEH_STILL_CAPTURE mode with PREVIEW capture intent,

If the camera device has BURST_CAPTURE capability, the frame rate requirement of BURST_CAPTURE must still be met.
All streams not larger than the maximum streaming dimension for BOKEH_STILL_CAPTURE mode (queried via ACAMERA_CONTROL_AVAILABLE_EXTENDED_SCENE_MODE_MAX_SIZES) will have preview bokeh effect applied.
When set to BOKEH_CONTINUOUS mode, configured streams dimension should not exceed this mode's maximum streaming dimension in order to have bokeh effect applied. Bokeh effect may not be available for streams larger than the maximum streaming dimension.

Switching between different extended scene modes may involve reconfiguration of the camera pipeline, resulting in long latency. The application should check this key against the available session keys queried via ACameraManager_getCameraCharacteristics.

For a logical multi-camera, bokeh may be implemented by stereo vision from sub-cameras with different field of view. As a result, when bokeh mode is enabled, the camera device may override ACAMERA_SCALER_CROP_REGION or ACAMERA_CONTROL_ZOOM_RATIO, and the field of view may be smaller than when bokeh mode is off.

See also: ACAMERA_CONTROL_ZOOM_RATIO See also: ACAMERA_SCALER_CROP_REGION

ACAMERA_CONTROL_MAX_REGIONS	
List of the maximum number of regions that can be used for metering in auto-exposure (AE), auto-white balance (AWB), and auto-focus (AF); this corresponds to the maximum number of elements in ACAMERA_CONTROL_AE_REGIONS, ACAMERA_CONTROL_AWB_REGIONS, and ACAMERA_CONTROL_AF_REGIONS.

See also: ACAMERA_CONTROL_AE_REGIONS See also: ACAMERA_CONTROL_AF_REGIONS See also: ACAMERA_CONTROL_AWB_REGIONS

Type: int32[3]

This tag may appear in:

ACameraMetadata from ACameraManager_getCameraCharacteristics
ACAMERA_CONTROL_MODE	
Overall mode of 3A (auto-exposure, auto-white-balance, auto-focus) control routines.

Type: byte (acamera_metadata_enum_android_control_mode_t)

This tag may appear in:

ACameraMetadata from ACameraCaptureSession_captureCallback_result callbacks
ACaptureRequest
This is a top-level 3A control switch. When set to OFF, all 3A control by the camera device is disabled. The application must set the fields for capture parameters itself.

When set to AUTO, the individual algorithm controls in ACAMERA_CONTROL_* are in effect, such as ACAMERA_CONTROL_AF_MODE.

When set to USE_SCENE_MODE or USE_EXTENDED_SCENE_MODE, the individual controls in ACAMERA_CONTROL_* are mostly disabled, and the camera device implements one of the scene mode or extended scene mode settings (such as ACTION, SUNSET, PARTY, or BOKEH) as it wishes. The camera device scene mode 3A settings are provided by capture results.

When set to OFF_KEEP_STATE, it is similar to OFF mode, the only difference is that this frame will not be used by camera device background 3A statistics update, as if this frame is never captured. This mode can be used in the scenario where the application doesn't want a 3A manual control capture to affect the subsequent auto 3A capture results.

See also: ACAMERA_CONTROL_AF_MODE

ACAMERA_CONTROL_POST_RAW_SENSITIVITY_BOOST	
The amount of additional sensitivity boost applied to output images after RAW sensor data is captured.

Type: int32

This tag may appear in:

ACameraMetadata from ACameraCaptureSession_captureCallback_result callbacks
ACaptureRequest
Some camera devices support additional digital sensitivity boosting in the camera processing pipeline after sensor RAW image is captured. Such a boost will be applied to YUV/JPEG format output images but will not have effect on RAW output formats like RAW_SENSOR, RAW10, RAW12 or RAW_OPAQUE.

This key will be null for devices that do not support any RAW format outputs. For devices that do support RAW format outputs, this key will always present, and if a device does not support post RAW sensitivity boost, it will list 100 in this key.

If the camera device cannot apply the exact boost requested, it will reduce the boost to the nearest supported value. The final boost value used will be available in the output capture result.

For devices that support post RAW sensitivity boost, the YUV/JPEG output images of such device will have the total sensitivity of ACAMERA_SENSOR_SENSITIVITY * ACAMERA_CONTROL_POST_RAW_SENSITIVITY_BOOST / 100 The sensitivity of RAW format images will always be ACAMERA_SENSOR_SENSITIVITY

This control is only effective if ACAMERA_CONTROL_AE_MODE or ACAMERA_CONTROL_MODE is set to OFF; otherwise the auto-exposure algorithm will override this value.

See also: ACAMERA_CONTROL_AE_MODE See also: ACAMERA_CONTROL_MODE See also: ACAMERA_CONTROL_POST_RAW_SENSITIVITY_BOOST See also: ACAMERA_SENSOR_SENSITIVITY

ACAMERA_CONTROL_POST_RAW_SENSITIVITY_BOOST_RANGE	
Range of boosts for ACAMERA_CONTROL_POST_RAW_SENSITIVITY_BOOST supported by this camera device.

See also: ACAMERA_CONTROL_POST_RAW_SENSITIVITY_BOOST

Type: int32[2]

This tag may appear in:

ACameraMetadata from ACameraManager_getCameraCharacteristics
Devices support post RAW sensitivity boost will advertise ACAMERA_CONTROL_POST_RAW_SENSITIVITY_BOOST key for controlling post RAW sensitivity boost.

This key will be null for devices that do not support any RAW format outputs. For devices that do support RAW format outputs, this key will always present, and if a device does not support post RAW sensitivity boost, it will list (100, 100) in this key.

See also: ACAMERA_CONTROL_POST_RAW_SENSITIVITY_BOOST

ACAMERA_CONTROL_SCENE_MODE	
Control for which scene mode is currently active.

Type: byte (acamera_metadata_enum_android_control_scene_mode_t)

This tag may appear in:

ACameraMetadata from ACameraCaptureSession_captureCallback_result callbacks
ACaptureRequest
Scene modes are custom camera modes optimized for a certain set of conditions and capture settings.

This is the mode that that is active when ACAMERA_CONTROL_MODE == USE_SCENE_MODE. Aside from FACE_PRIORITY, these modes will disable ACAMERA_CONTROL_AE_MODE, ACAMERA_CONTROL_AWB_MODE, and ACAMERA_CONTROL_AF_MODE while in use.

The interpretation and implementation of these scene modes is left to the implementor of the camera device. Their behavior will not be consistent across all devices, and any given device may only implement a subset of these modes.

See also: ACAMERA_CONTROL_AE_MODE See also: ACAMERA_CONTROL_AF_MODE See also: ACAMERA_CONTROL_AWB_MODE See also: ACAMERA_CONTROL_MODE

ACAMERA_CONTROL_VIDEO_STABILIZATION_MODE	
Whether video stabilization is active.

Type: byte (acamera_metadata_enum_android_control_video_stabilization_mode_t)

This tag may appear in:

ACameraMetadata from ACameraCaptureSession_captureCallback_result callbacks
ACaptureRequest
Video stabilization automatically warps images from the camera in order to stabilize motion between consecutive frames.

If enabled, video stabilization can modify the ACAMERA_SCALER_CROP_REGION to keep the video stream stabilized.

Switching between different video stabilization modes may take several frames to initialize, the camera device will report the current mode in capture result metadata. For example, When "ON" mode is requested, the video stabilization modes in the first several capture results may still be "OFF", and it will become "ON" when the initialization is done.

In addition, not all recording sizes or frame rates may be supported for stabilization by a device that reports stabilization support. It is guaranteed that an output targeting a MediaRecorder or MediaCodec will be stabilized if the recording resolution is less than or equal to 1920 x 1080 (width less than or equal to 1920, height less than or equal to 1080), and the recording frame rate is less than or equal to 30fps. At other sizes, the CaptureResult ACAMERA_CONTROL_VIDEO_STABILIZATION_MODE field will return OFF if the recording output is not stabilized, or if there are no output Surface types that can be stabilized.

If a camera device supports both this mode and OIS (ACAMERA_LENS_OPTICAL_STABILIZATION_MODE), turning both modes on may produce undesirable interaction, so it is recommended not to enable both at the same time.

If video stabilization is set to "PREVIEW_STABILIZATION", ACAMERA_LENS_OPTICAL_STABILIZATION_MODE is overridden. The camera sub-system may choose to turn on hardware based image stabilization in addition to software based stabilization if it deems that appropriate. This key may be a part of the available session keys, which camera clients may query via ACameraManager_getCameraCharacteristics. If this is the case, changing this key over the life-time of a capture session may cause delays / glitches.

See also: ACAMERA_CONTROL_VIDEO_STABILIZATION_MODE See also: ACAMERA_LENS_OPTICAL_STABILIZATION_MODE See also: ACAMERA_SCALER_CROP_REGION

ACAMERA_CONTROL_ZOOM_RATIO	
The desired zoom ratio

Type: float

This tag may appear in:

ACameraMetadata from ACameraCaptureSession_captureCallback_result callbacks
ACaptureRequest
Instead of using ACAMERA_SCALER_CROP_REGION for zoom, the application can now choose to use this tag to specify the desired zoom level.

By using this control, the application gains a simpler way to control zoom, which can be a combination of optical and digital zoom. For example, a multi-camera system may contain more than one lens with different focal lengths, and the user can use optical zoom by switching between lenses. Using zoomRatio has benefits in the scenarios below:

Zooming in from a wide-angle lens to a telephoto lens: A floating-point ratio provides better precision compared to an integer value of ACAMERA_SCALER_CROP_REGION.
Zooming out from a wide lens to an ultrawide lens: zoomRatio supports zoom-out whereas ACAMERA_SCALER_CROP_REGION doesn't.
To illustrate, here are several scenarios of different zoom ratios, crop regions, and output streams, for a hypothetical camera device with an active array of size (2000,1500).

Camera Configuration:
Active array size: 2000x1500 (3 MP, 4:3 aspect ratio)
Output stream #1: 640x480 (VGA, 4:3 aspect ratio)
Output stream #2: 1280x720 (720p, 16:9 aspect ratio)
Case #1: 4:3 crop region with 2.0x zoom ratio
Zoomed field of view: 1/4 of original field of view
Crop region: Rect(0, 0, 2000, 1500) // (left, top, right, bottom) (post zoom)

640x480 stream source area: (0, 0, 2000, 1500) (equal to crop region)
1280x720 stream source area: (0, 187, 2000, 1312) (letterboxed)
Case #2: 16:9 crop region with 2.0x zoom.
Zoomed field of view: 1/4 of original field of view
Crop region: Rect(0, 187, 2000, 1312)

640x480 stream source area: (250, 187, 1750, 1312) (pillarboxed)
1280x720 stream source area: (0, 187, 2000, 1312) (equal to crop region)
Case #3: 1:1 crop region with 0.5x zoom out to ultrawide lens.
Zoomed field of view: 4x of original field of view (switched from wide lens to ultrawide lens)
Crop region: Rect(250, 0, 1750, 1500)

640x480 stream source area: (250, 187, 1750, 1312) (letterboxed)
1280x720 stream source area: (250, 328, 1750, 1172) (letterboxed)
As seen from the graphs above, the coordinate system of cropRegion now changes to the effective after-zoom field-of-view, and is represented by the rectangle of (0, 0, activeArrayWith, activeArrayHeight). The same applies to AE/AWB/AF regions, and faces. This coordinate system change isn't applicable to RAW capture and its related metadata such as intrinsicCalibration and lensShadingMap.

Using the same hypothetical example above, and assuming output stream #1 (640x480) is the viewfinder stream, the application can achieve 2.0x zoom in one of two ways:

zoomRatio = 2.0, scaler.cropRegion = (0, 0, 2000, 1500)
zoomRatio = 1.0 (default), scaler.cropRegion = (500, 375, 1500, 1125)
If the application intends to set aeRegions to be top-left quarter of the viewfinder field-of-view, the ACAMERA_CONTROL_AE_REGIONS should be set to (0, 0, 1000, 750) with zoomRatio set to 2.0. Alternatively, the application can set aeRegions to the equivalent region of (500, 375, 1000, 750) for zoomRatio of 1.0. If the application doesn't explicitly set ACAMERA_CONTROL_ZOOM_RATIO, its value defaults to 1.0.

One limitation of controlling zoom using zoomRatio is that the ACAMERA_SCALER_CROP_REGION must only be used for letterboxing or pillarboxing of the sensor active array, and no FREEFORM cropping can be used with ACAMERA_CONTROL_ZOOM_RATIO other than 1.0. If ACAMERA_CONTROL_ZOOM_RATIO is not 1.0, and ACAMERA_SCALER_CROP_REGION is set to be windowboxing, the camera framework will override the ACAMERA_SCALER_CROP_REGION to be the active array.

In the capture request, if the application sets ACAMERA_CONTROL_ZOOM_RATIO to a value != 1.0, the ACAMERA_CONTROL_ZOOM_RATIO tag in the capture result reflects the effective zoom ratio achieved by the camera device, and the ACAMERA_SCALER_CROP_REGION adjusts for additional crops that are not zoom related. Otherwise, if the application sets ACAMERA_CONTROL_ZOOM_RATIO to 1.0, or does not set it at all, the ACAMERA_CONTROL_ZOOM_RATIO tag in the result metadata will also be 1.0.

When the application requests a physical stream for a logical multi-camera, the ACAMERA_CONTROL_ZOOM_RATIO in the physical camera result metadata will be 1.0, and the ACAMERA_SCALER_CROP_REGION tag reflects the amount of zoom and crop done by the physical camera device.

See also: ACAMERA_CONTROL_AE_REGIONS See also: ACAMERA_CONTROL_ZOOM_RATIO See also: ACAMERA_SCALER_CROP_REGION

ACAMERA_CONTROL_ZOOM_RATIO_RANGE	
Minimum and maximum zoom ratios supported by this camera device.

Type: float[2]

This tag may appear in:

ACameraMetadata from ACameraManager_getCameraCharacteristics
If the camera device supports zoom-out from 1x zoom, minZoom will be less than 1.0, and setting ACAMERA_CONTROL_ZOOM_RATIO to values less than 1.0 increases the camera's field of view.

See also: ACAMERA_CONTROL_ZOOM_RATIO

ACAMERA_DEPTH_AVAILABLE_DEPTH_MIN_FRAME_DURATIONS	
This lists the minimum frame duration for each format/size combination for depth output formats.

Type: int64[4*n]

This tag may appear in:

ACameraMetadata from ACameraManager_getCameraCharacteristics
This should correspond to the frame duration when only that stream is active, with all processing (typically in android.*.mode) set to either OFF or FAST.

When multiple streams are used in a request, the minimum frame duration will be max(individual stream min durations).

The minimum frame duration of a stream (of a particular format, size) is the same regardless of whether the stream is input or output.

See ACAMERA_SENSOR_FRAME_DURATION and ACAMERA_SCALER_AVAILABLE_STALL_DURATIONS for more details about calculating the max frame rate.

See also: ACAMERA_SCALER_AVAILABLE_STALL_DURATIONS See also: ACAMERA_SENSOR_FRAME_DURATION

ACAMERA_DEPTH_AVAILABLE_DEPTH_MIN_FRAME_DURATIONS_MAXIMUM_RESOLUTION	
This lists the minimum frame duration for each format/size combination for depth output formats when a CaptureRequest is submitted with ACAMERA_SENSOR_PIXEL_MODE set to CameraMetadata::SENSOR_PIXEL_MODE_MAXIMUM_RESOLUTION.

See also: ACAMERA_SENSOR_PIXEL_MODE

Type: int64[4*n]

This tag may appear in:

ACameraMetadata from ACameraManager_getCameraCharacteristics
Analogous to ACAMERA_DEPTH_AVAILABLE_DEPTH_MIN_FRAME_DURATIONS, for configurations which are applicable when ACAMERA_SENSOR_PIXEL_MODE is set to CameraMetadata::SENSOR_PIXEL_MODE_MAXIMUM_RESOLUTION.

See ACAMERA_SENSOR_FRAME_DURATION and ACAMERA_SCALER_AVAILABLE_STALL_DURATIONS_MAXIMUM_RESOLUTION for more details about calculating the max frame rate.

See also: ACAMERA_DEPTH_AVAILABLE_DEPTH_MIN_FRAME_DURATIONS See also: ACAMERA_SCALER_AVAILABLE_STALL_DURATIONS_MAXIMUM_RESOLUTION See also: ACAMERA_SENSOR_FRAME_DURATION See also: ACAMERA_SENSOR_PIXEL_MODE

ACAMERA_DEPTH_AVAILABLE_DEPTH_STALL_DURATIONS	
This lists the maximum stall duration for each output format/size combination for depth streams.

Type: int64[4*n]

This tag may appear in:

ACameraMetadata from ACameraManager_getCameraCharacteristics
A stall duration is how much extra time would get added to the normal minimum frame duration for a repeating request that has streams with non-zero stall.

This functions similarly to ACAMERA_SCALER_AVAILABLE_STALL_DURATIONS for depth streams.

All depth output stream formats may have a nonzero stall duration.

See also: ACAMERA_SCALER_AVAILABLE_STALL_DURATIONS

ACAMERA_DEPTH_AVAILABLE_DEPTH_STALL_DURATIONS_MAXIMUM_RESOLUTION	
This lists the maximum stall duration for each output format/size combination for depth streams for CaptureRequests where ACAMERA_SENSOR_PIXEL_MODE is set to CameraMetadata::SENSOR_PIXEL_MODE_MAXIMUM_RESOLUTION.

See also: ACAMERA_SENSOR_PIXEL_MODE

Type: int64[4*n]

This tag may appear in:

ACameraMetadata from ACameraManager_getCameraCharacteristics
Analogous to ACAMERA_DEPTH_AVAILABLE_DEPTH_STALL_DURATIONS, for configurations which are applicable when ACAMERA_SENSOR_PIXEL_MODE is set to CameraMetadata::SENSOR_PIXEL_MODE_MAXIMUM_RESOLUTION.

See also: ACAMERA_DEPTH_AVAILABLE_DEPTH_STALL_DURATIONS See also: ACAMERA_SENSOR_PIXEL_MODE

ACAMERA_DEPTH_AVAILABLE_DEPTH_STREAM_CONFIGURATIONS	
The available depth dataspace stream configurations that this camera device supports (i.e. format, width, height, output/input stream).

Type: int32[n*4] (acamera_metadata_enum_android_depth_available_depth_stream_configurations_t)

This tag may appear in:

ACameraMetadata from ACameraManager_getCameraCharacteristics
These are output stream configurations for use with dataSpace HAL_DATASPACE_DEPTH. The configurations are listed as (format, width, height, input?) tuples.

Only devices that support depth output for at least the HAL_PIXEL_FORMAT_Y16 dense depth map may include this entry.

A device that also supports the HAL_PIXEL_FORMAT_BLOB sparse depth point cloud must report a single entry for the format in this list as (HAL_PIXEL_FORMAT_BLOB, android.depth.maxDepthSamples, 1, OUTPUT) in addition to the entries for HAL_PIXEL_FORMAT_Y16.

ACAMERA_DEPTH_AVAILABLE_DEPTH_STREAM_CONFIGURATIONS_MAXIMUM_RESOLUTION	
The available depth dataspace stream configurations that this camera device supports (i.e. format, width, height, output/input stream) when a CaptureRequest is submitted with ACAMERA_SENSOR_PIXEL_MODE set to CameraMetadata::SENSOR_PIXEL_MODE_MAXIMUM_RESOLUTION.

See also: ACAMERA_SENSOR_PIXEL_MODE

Type: int32[n*4] (acamera_metadata_enum_android_depth_available_depth_stream_configurations_maximum_resolution_t)

This tag may appear in:

ACameraMetadata from ACameraManager_getCameraCharacteristics
Analogous to ACAMERA_DEPTH_AVAILABLE_DEPTH_STREAM_CONFIGURATIONS, for configurations which are applicable when ACAMERA_SENSOR_PIXEL_MODE is set to CameraMetadata::SENSOR_PIXEL_MODE_MAXIMUM_RESOLUTION.

See also: ACAMERA_DEPTH_AVAILABLE_DEPTH_STREAM_CONFIGURATIONS See also: ACAMERA_SENSOR_PIXEL_MODE

ACAMERA_DEPTH_AVAILABLE_DYNAMIC_DEPTH_MIN_FRAME_DURATIONS	
This lists the minimum frame duration for each format/size combination for dynamic depth output streams.

Type: int64[4*n]

This tag may appear in:

ACameraMetadata from ACameraManager_getCameraCharacteristics
This should correspond to the frame duration when only that stream is active, with all processing (typically in android.*.mode) set to either OFF or FAST.

When multiple streams are used in a request, the minimum frame duration will be max(individual stream min durations).

The minimum frame duration of a stream (of a particular format, size) is the same regardless of whether the stream is input or output.

ACAMERA_DEPTH_AVAILABLE_DYNAMIC_DEPTH_MIN_FRAME_DURATIONS_MAXIMUM_RESOLUTION	
This lists the minimum frame duration for each format/size combination for dynamic depth output streams for CaptureRequests where ACAMERA_SENSOR_PIXEL_MODE is set to CameraMetadata::SENSOR_PIXEL_MODE_MAXIMUM_RESOLUTION.

See also: ACAMERA_SENSOR_PIXEL_MODE

Type: int64[4*n]

This tag may appear in:

ACameraMetadata from ACameraManager_getCameraCharacteristics
Analogous to ACAMERA_DEPTH_AVAILABLE_DYNAMIC_DEPTH_MIN_FRAME_DURATIONS, for configurations which are applicable when ACAMERA_SENSOR_PIXEL_MODE is set to CameraMetadata::SENSOR_PIXEL_MODE_MAXIMUM_RESOLUTION.

See also: ACAMERA_DEPTH_AVAILABLE_DYNAMIC_DEPTH_MIN_FRAME_DURATIONS See also: ACAMERA_SENSOR_PIXEL_MODE

ACAMERA_DEPTH_AVAILABLE_DYNAMIC_DEPTH_STALL_DURATIONS	
This lists the maximum stall duration for each output format/size combination for dynamic depth streams.

Type: int64[4*n]

This tag may appear in:

ACameraMetadata from ACameraManager_getCameraCharacteristics
A stall duration is how much extra time would get added to the normal minimum frame duration for a repeating request that has streams with non-zero stall.

All dynamic depth output streams may have a nonzero stall duration.

ACAMERA_DEPTH_AVAILABLE_DYNAMIC_DEPTH_STALL_DURATIONS_MAXIMUM_RESOLUTION	
This lists the maximum stall duration for each output format/size combination for dynamic depth streams for CaptureRequests where ACAMERA_SENSOR_PIXEL_MODE is set to CameraMetadata::SENSOR_PIXEL_MODE_MAXIMUM_RESOLUTION.

See also: ACAMERA_SENSOR_PIXEL_MODE

Type: int64[4*n]

This tag may appear in:

ACameraMetadata from ACameraManager_getCameraCharacteristics
Analogous to ACAMERA_DEPTH_AVAILABLE_DYNAMIC_DEPTH_STALL_DURATIONS, for configurations which are applicable when ACAMERA_SENSOR_PIXEL_MODE is set to CameraMetadata::SENSOR_PIXEL_MODE_MAXIMUM_RESOLUTION.

See also: ACAMERA_DEPTH_AVAILABLE_DYNAMIC_DEPTH_STALL_DURATIONS See also: ACAMERA_SENSOR_PIXEL_MODE

ACAMERA_DEPTH_AVAILABLE_DYNAMIC_DEPTH_STREAM_CONFIGURATIONS	
The available dynamic depth dataspace stream configurations that this camera device supports (i.e. format, width, height, output/input stream).

Type: int32[n*4] (acamera_metadata_enum_android_depth_available_dynamic_depth_stream_configurations_t)

This tag may appear in:

ACameraMetadata from ACameraManager_getCameraCharacteristics
These are output stream configurations for use with dataSpace DYNAMIC_DEPTH. The configurations are listed as (format, width, height, input?) tuples.

Only devices that support depth output for at least the HAL_PIXEL_FORMAT_Y16 dense depth map along with HAL_PIXEL_FORMAT_BLOB with the same size or size with the same aspect ratio can have dynamic depth dataspace stream configuration. ACAMERA_DEPTH_DEPTH_IS_EXCLUSIVE also needs to be set to FALSE.

See also: ACAMERA_DEPTH_DEPTH_IS_EXCLUSIVE

ACAMERA_DEPTH_AVAILABLE_DYNAMIC_DEPTH_STREAM_CONFIGURATIONS_MAXIMUM_RESOLUTION	
The available dynamic depth dataspace stream configurations that this camera device supports (i.e. format, width, height, output/input stream) for CaptureRequests where ACAMERA_SENSOR_PIXEL_MODE is set to CameraMetadata::SENSOR_PIXEL_MODE_MAXIMUM_RESOLUTION.

See also: ACAMERA_SENSOR_PIXEL_MODE

Type: int32[n*4] (acamera_metadata_enum_android_depth_available_dynamic_depth_stream_configurations_maximum_resolution_t)

This tag may appear in:

ACameraMetadata from ACameraManager_getCameraCharacteristics
Analogous to ACAMERA_DEPTH_AVAILABLE_DYNAMIC_DEPTH_STREAM_CONFIGURATIONS, for configurations which are applicable when ACAMERA_SENSOR_PIXEL_MODE is set to CameraMetadata::SENSOR_PIXEL_MODE_MAXIMUM_RESOLUTION.

See also: ACAMERA_DEPTH_AVAILABLE_DYNAMIC_DEPTH_STREAM_CONFIGURATIONS See also: ACAMERA_SENSOR_PIXEL_MODE

ACAMERA_DEPTH_AVAILABLE_RECOMMENDED_DEPTH_STREAM_CONFIGURATIONS	
Recommended depth stream configurations for common client use cases.

Type: int32[n*5]

This tag may appear in:

ACameraMetadata from ACameraManager_getCameraCharacteristics
Optional subset of the ACAMERA_DEPTH_AVAILABLE_DEPTH_STREAM_CONFIGURATIONS that contains similar tuples listed as (i.e. width, height, format, output/input stream, usecase bit field). Camera devices will be able to suggest particular depth stream configurations which are power and performance efficient for specific use cases. For more information about retrieving the suggestions see CameraCharacteristics::getRecommendedStreamConfigurationMap.

For data representation please refer to ACAMERA_SCALER_AVAILABLE_RECOMMENDED_STREAM_CONFIGURATIONS

See also: ACAMERA_DEPTH_AVAILABLE_DEPTH_STREAM_CONFIGURATIONS See also: ACAMERA_SCALER_AVAILABLE_RECOMMENDED_STREAM_CONFIGURATIONS

ACAMERA_DEPTH_DEPTH_IS_EXCLUSIVE	
Indicates whether a capture request may target both a DEPTH16 / DEPTH_POINT_CLOUD output, and normal color outputs (such as YUV_420_888, JPEG, or RAW) simultaneously.

Type: byte (acamera_metadata_enum_android_depth_depth_is_exclusive_t)

This tag may appear in:

ACameraMetadata from ACameraManager_getCameraCharacteristics
If TRUE, including both depth and color outputs in a single capture request is not supported. An application must interleave color and depth requests. If FALSE, a single request can target both types of output.

Typically, this restriction exists on camera devices that need to emit a specific pattern or wavelength of light to measure depth values, which causes the color image to be corrupted during depth measurement.

ACAMERA_DEPTH_END	
ACAMERA_DISTORTION_CORRECTION_AVAILABLE_MODES	
List of distortion correction modes for ACAMERA_DISTORTION_CORRECTION_MODE that are supported by this camera device.

See also: ACAMERA_DISTORTION_CORRECTION_MODE

Type: byte[n]

This tag may appear in:

ACameraMetadata from ACameraManager_getCameraCharacteristics
No device is required to support this API; such devices will always list only 'OFF'. All devices that support this API will list both FAST and HIGH_QUALITY.

ACAMERA_DISTORTION_CORRECTION_END	
ACAMERA_DISTORTION_CORRECTION_MODE	
Mode of operation for the lens distortion correction block.

Type: byte (acamera_metadata_enum_android_distortion_correction_mode_t)

This tag may appear in:

ACameraMetadata from ACameraCaptureSession_captureCallback_result callbacks
ACaptureRequest
The lens distortion correction block attempts to improve image quality by fixing radial, tangential, or other geometric aberrations in the camera device's optics. If available, the ACAMERA_LENS_DISTORTION field documents the lens's distortion parameters.

OFF means no distortion correction is done.

FAST/HIGH_QUALITY both mean camera device determined distortion correction will be applied. HIGH_QUALITY mode indicates that the camera device will use the highest-quality correction algorithms, even if it slows down capture rate. FAST means the camera device will not slow down capture rate when applying correction. FAST may be the same as OFF if any correction at all would slow down capture rate. Every output stream will have a similar amount of enhancement applied.

The correction only applies to processed outputs such as YUV, Y8, JPEG, or DEPTH16; it is not applied to any RAW output.

This control will be on by default on devices that support this control. Applications disabling distortion correction need to pay extra attention with the coordinate system of metering regions, crop region, and face rectangles. When distortion correction is OFF, metadata coordinates follow the coordinate system of ACAMERA_SENSOR_INFO_PRE_CORRECTION_ACTIVE_ARRAY_SIZE. When distortion is not OFF, metadata coordinates follow the coordinate system of ACAMERA_SENSOR_INFO_ACTIVE_ARRAY_SIZE. The camera device will map these metadata fields to match the corrected image produced by the camera device, for both capture requests and results. However, this mapping is not very precise, since rectangles do not generally map to rectangles when corrected. Only linear scaling between the active array and precorrection active array coordinates is performed. Applications that require precise correction of metadata need to undo that linear scaling, and apply a more complete correction that takes into the account the app's own requirements.

The full list of metadata that is affected in this way by distortion correction is:

ACAMERA_CONTROL_AF_REGIONS
ACAMERA_CONTROL_AE_REGIONS
ACAMERA_CONTROL_AWB_REGIONS
ACAMERA_SCALER_CROP_REGION
android.statistics.faces
See also: ACAMERA_CONTROL_AE_REGIONS See also: ACAMERA_CONTROL_AF_REGIONS See also: ACAMERA_CONTROL_AWB_REGIONS See also: ACAMERA_LENS_DISTORTION See also: ACAMERA_SCALER_CROP_REGION See also: ACAMERA_SENSOR_INFO_ACTIVE_ARRAY_SIZE See also: ACAMERA_SENSOR_INFO_PRE_CORRECTION_ACTIVE_ARRAY_SIZE

ACAMERA_EDGE_AVAILABLE_EDGE_MODES	
List of edge enhancement modes for ACAMERA_EDGE_MODE that are supported by this camera device.

See also: ACAMERA_EDGE_MODE

Type: byte[n]

This tag may appear in:

ACameraMetadata from ACameraManager_getCameraCharacteristics
Full-capability camera devices must always support OFF; camera devices that support YUV_REPROCESSING or PRIVATE_REPROCESSING will list ZERO_SHUTTER_LAG; all devices will list FAST.

ACAMERA_EDGE_END	
ACAMERA_EDGE_MODE	
Operation mode for edge enhancement.

Type: byte (acamera_metadata_enum_android_edge_mode_t)

This tag may appear in:

ACameraMetadata from ACameraCaptureSession_captureCallback_result callbacks
ACaptureRequest
Edge enhancement improves sharpness and details in the captured image. OFF means no enhancement will be applied by the camera device.

FAST/HIGH_QUALITY both mean camera device determined enhancement will be applied. HIGH_QUALITY mode indicates that the camera device will use the highest-quality enhancement algorithms, even if it slows down capture rate. FAST means the camera device will not slow down capture rate when applying edge enhancement. FAST may be the same as OFF if edge enhancement will slow down capture rate. Every output stream will have a similar amount of enhancement applied.

ZERO_SHUTTER_LAG is meant to be used by applications that maintain a continuous circular buffer of high-resolution images during preview and reprocess image(s) from that buffer into a final capture when triggered by the user. In this mode, the camera device applies edge enhancement to low-resolution streams (below maximum recording resolution) to maximize preview quality, but does not apply edge enhancement to high-resolution streams, since those will be reprocessed later if necessary.

For YUV_REPROCESSING, these FAST/HIGH_QUALITY modes both mean that the camera device will apply FAST/HIGH_QUALITY YUV-domain edge enhancement, respectively. The camera device may adjust its internal edge enhancement parameters for best image quality based on the android.reprocess.effectiveExposureFactor, if it is set.

ACAMERA_FLASH_END	
ACAMERA_FLASH_INFO_AVAILABLE	
Whether this camera device has a flash unit.

Type: byte (acamera_metadata_enum_android_flash_info_available_t)

This tag may appear in:

ACameraMetadata from ACameraManager_getCameraCharacteristics
Will be false if no flash is available.

If there is no flash unit, none of the flash controls do anything.

ACAMERA_FLASH_INFO_END	
ACAMERA_FLASH_INFO_STRENGTH_DEFAULT_LEVEL	
Default flashlight brightness level to be set via CameraManager::turnOnTorchWithStrengthLevel.

Type: int32

This tag may appear in:

ACameraMetadata from ACameraManager_getCameraCharacteristics
If flash unit is available this will be greater than or equal to 1 and less or equal to ACAMERA_FLASH_INFO_STRENGTH_MAXIMUM_LEVEL.

Setting flashlight brightness above the default level (i.e.ACAMERA_FLASH_INFO_STRENGTH_DEFAULT_LEVEL) may make the device more likely to reach thermal throttling conditions and slow down, or drain the battery quicker than normal. To minimize such issues, it is recommended to start the flashlight at this default brightness until a user explicitly requests a brighter level. Note that the value for this key will be null for devices with no flash unit. The default level should always be > 0.

See also: ACAMERA_FLASH_INFO_STRENGTH_DEFAULT_LEVEL See also: ACAMERA_FLASH_INFO_STRENGTH_MAXIMUM_LEVEL

ACAMERA_FLASH_INFO_STRENGTH_MAXIMUM_LEVEL	
Maximum flashlight brightness level.

Type: int32

This tag may appear in:

ACameraMetadata from ACameraManager_getCameraCharacteristics
If this value is greater than 1, then the device supports controlling the flashlight brightness level via CameraManager::turnOnTorchWithStrengthLevel. If this value is equal to 1, flashlight brightness control is not supported. The value for this key will be null for devices with no flash unit.

The maximum value is guaranteed to be safe to use for an indefinite duration in terms of device flashlight lifespan, but may be too bright for comfort for many use cases. Use the default torch brightness value to avoid problems with an over-bright flashlight.

ACAMERA_FLASH_MODE	
The desired mode for for the camera device's flash control.

Type: byte (acamera_metadata_enum_android_flash_mode_t)

This tag may appear in:

ACameraMetadata from ACameraCaptureSession_captureCallback_result callbacks
ACaptureRequest
This control is only effective when flash unit is available (ACAMERA_FLASH_INFO_AVAILABLE == true).

When this control is used, the ACAMERA_CONTROL_AE_MODE must be set to ON or OFF. Otherwise, the camera device auto-exposure related flash control (ON_AUTO_FLASH, ON_ALWAYS_FLASH, or ON_AUTO_FLASH_REDEYE) will override this control.

When set to OFF, the camera device will not fire flash for this capture.

When set to SINGLE, the camera device will fire flash regardless of the camera device's auto-exposure routine's result. When used in still capture case, this control should be used along with auto-exposure (AE) precapture metering sequence (ACAMERA_CONTROL_AE_PRECAPTURE_TRIGGER), otherwise, the image may be incorrectly exposed.

When set to TORCH, the flash will be on continuously. This mode can be used for use cases such as preview, auto-focus assist, still capture, or video recording.

The flash status will be reported by ACAMERA_FLASH_STATE in the capture result metadata.

See also: ACAMERA_CONTROL_AE_MODE See also: ACAMERA_CONTROL_AE_PRECAPTURE_TRIGGER See also: ACAMERA_FLASH_INFO_AVAILABLE See also: ACAMERA_FLASH_STATE

ACAMERA_FLASH_STATE	
Current state of the flash unit.

Type: byte (acamera_metadata_enum_android_flash_state_t)

This tag may appear in:

ACameraMetadata from ACameraCaptureSession_captureCallback_result callbacks
When the camera device doesn't have flash unit (i.e. ACAMERA_FLASH_INFO_AVAILABLE == false), this state will always be UNAVAILABLE. Other states indicate the current flash status.

In certain conditions, this will be available on LEGACY devices:

Flash-less cameras always return UNAVAILABLE.
Using ACAMERA_CONTROL_AE_MODE == ON_ALWAYS_FLASH will always return FIRED.
Using ACAMERA_FLASH_MODE == TORCH will always return FIRED.
In all other conditions the state will not be available on LEGACY devices (i.e. it will be null).

See also: ACAMERA_CONTROL_AE_MODE See also: ACAMERA_FLASH_INFO_AVAILABLE See also: ACAMERA_FLASH_MODE

ACAMERA_HEIC_AVAILABLE_HEIC_MIN_FRAME_DURATIONS	
This lists the minimum frame duration for each format/size combination for HEIC output formats.

Type: int64[4*n]

This tag may appear in:

ACameraMetadata from ACameraManager_getCameraCharacteristics
This should correspond to the frame duration when only that stream is active, with all processing (typically in android.*.mode) set to either OFF or FAST.

When multiple streams are used in a request, the minimum frame duration will be max(individual stream min durations).

See ACAMERA_SENSOR_FRAME_DURATION and ACAMERA_SCALER_AVAILABLE_STALL_DURATIONS for more details about calculating the max frame rate.

See also: ACAMERA_SCALER_AVAILABLE_STALL_DURATIONS See also: ACAMERA_SENSOR_FRAME_DURATION

ACAMERA_HEIC_AVAILABLE_HEIC_MIN_FRAME_DURATIONS_MAXIMUM_RESOLUTION	
This lists the minimum frame duration for each format/size combination for HEIC output formats for CaptureRequests where ACAMERA_SENSOR_PIXEL_MODE is set to CameraMetadata::SENSOR_PIXEL_MODE_MAXIMUM_RESOLUTION.

See also: ACAMERA_SENSOR_PIXEL_MODE

Type: int64[4*n]

This tag may appear in:

ACameraMetadata from ACameraManager_getCameraCharacteristics
Refer to ACAMERA_HEIC_AVAILABLE_HEIC_MIN_FRAME_DURATIONS for details.

See also: ACAMERA_HEIC_AVAILABLE_HEIC_MIN_FRAME_DURATIONS

ACAMERA_HEIC_AVAILABLE_HEIC_STALL_DURATIONS	
This lists the maximum stall duration for each output format/size combination for HEIC streams.

Type: int64[4*n]

This tag may appear in:

ACameraMetadata from ACameraManager_getCameraCharacteristics
A stall duration is how much extra time would get added to the normal minimum frame duration for a repeating request that has streams with non-zero stall.

This functions similarly to ACAMERA_SCALER_AVAILABLE_STALL_DURATIONS for HEIC streams.

All HEIC output stream formats may have a nonzero stall duration.

See also: ACAMERA_SCALER_AVAILABLE_STALL_DURATIONS

ACAMERA_HEIC_AVAILABLE_HEIC_STALL_DURATIONS_MAXIMUM_RESOLUTION	
This lists the maximum stall duration for each output format/size combination for HEIC streams for CaptureRequests where ACAMERA_SENSOR_PIXEL_MODE is set to CameraMetadata::SENSOR_PIXEL_MODE_MAXIMUM_RESOLUTION.

See also: ACAMERA_SENSOR_PIXEL_MODE

Type: int64[4*n]

This tag may appear in:

ACameraMetadata from ACameraManager_getCameraCharacteristics
Refer to ACAMERA_HEIC_AVAILABLE_HEIC_STALL_DURATIONS for details.

See also: ACAMERA_HEIC_AVAILABLE_HEIC_STALL_DURATIONS

ACAMERA_HEIC_AVAILABLE_HEIC_STREAM_CONFIGURATIONS	
The available HEIC (ISO/IEC 23008-12) stream configurations that this camera device supports (i.e. format, width, height, output/input stream).

Type: int32[n*4] (acamera_metadata_enum_android_heic_available_heic_stream_configurations_t)

This tag may appear in:

ACameraMetadata from ACameraManager_getCameraCharacteristics
The configurations are listed as (format, width, height, input?) tuples.

If the camera device supports HEIC image format, it will support identical set of stream combinations involving HEIC image format, compared to the combinations involving JPEG image format as required by the device's hardware level and capabilities.

All the static, control, and dynamic metadata tags related to JPEG apply to HEIC formats. Configuring JPEG and HEIC streams at the same time is not supported.

All the configuration tuples (format, width, height, input?) will contain AIMAGE_FORMAT_HEIC format as OUTPUT only.

ACAMERA_HEIC_AVAILABLE_HEIC_STREAM_CONFIGURATIONS_MAXIMUM_RESOLUTION	
The available HEIC (ISO/IEC 23008-12) stream configurations that this camera device supports (i.e. format, width, height, output/input stream).

Type: int32[n*4] (acamera_metadata_enum_android_heic_available_heic_stream_configurations_maximum_resolution_t)

This tag may appear in:

ACameraMetadata from ACameraManager_getCameraCharacteristics
Refer to ACAMERA_HEIC_AVAILABLE_HEIC_STREAM_CONFIGURATIONS for details.

All the configuration tuples (format, width, height, input?) will contain AIMAGE_FORMAT_HEIC format as OUTPUT only.

See also: ACAMERA_HEIC_AVAILABLE_HEIC_STREAM_CONFIGURATIONS

ACAMERA_HEIC_END	
ACAMERA_HOT_PIXEL_AVAILABLE_HOT_PIXEL_MODES	
List of hot pixel correction modes for ACAMERA_HOT_PIXEL_MODE that are supported by this camera device.

See also: ACAMERA_HOT_PIXEL_MODE

Type: byte[n]

This tag may appear in:

ACameraMetadata from ACameraManager_getCameraCharacteristics
FULL mode camera devices will always support FAST.

ACAMERA_HOT_PIXEL_END	
ACAMERA_HOT_PIXEL_MODE	
Operational mode for hot pixel correction.

Type: byte (acamera_metadata_enum_android_hot_pixel_mode_t)

This tag may appear in:

ACameraMetadata from ACameraCaptureSession_captureCallback_result callbacks
ACaptureRequest
Hotpixel correction interpolates out, or otherwise removes, pixels that do not accurately measure the incoming light (i.e. pixels that are stuck at an arbitrary value or are oversensitive).

ACAMERA_INFO_DEVICE_STATE_ORIENTATIONS	
Type: int64[2*n]

This tag may appear in:

ACameraMetadata from ACameraManager_getCameraCharacteristics
HAL must populate the array with (hardware::camera::provider::V2_5::DeviceState, sensorOrientation) pairs for each supported device state bitwise combination.

ACAMERA_INFO_END	
ACAMERA_INFO_SUPPORTED_HARDWARE_LEVEL	
Generally classifies the overall set of the camera device functionality.

Type: byte (acamera_metadata_enum_android_info_supported_hardware_level_t)

This tag may appear in:

ACameraMetadata from ACameraManager_getCameraCharacteristics
The supported hardware level is a high-level description of the camera device's capabilities, summarizing several capabilities into one field. Each level adds additional features to the previous one, and is always a strict superset of the previous level. The ordering is LEGACY < LIMITED < FULL < LEVEL_3.

Starting from LEVEL_3, the level enumerations are guaranteed to be in increasing numerical value as well. To check if a given device is at least at a given hardware level, the following code snippet can be used:

// Returns true if the device supports the required hardware level, or better.
boolean isHardwareLevelSupported(CameraCharacteristics c, int requiredLevel) {
    final int[] sortedHwLevels = {
        CameraCharacteristics.INFO_SUPPORTED_HARDWARE_LEVEL_LEGACY,
        CameraCharacteristics.INFO_SUPPORTED_HARDWARE_LEVEL_EXTERNAL,
        CameraCharacteristics.INFO_SUPPORTED_HARDWARE_LEVEL_LIMITED,
        CameraCharacteristics.INFO_SUPPORTED_HARDWARE_LEVEL_FULL,
        CameraCharacteristics.INFO_SUPPORTED_HARDWARE_LEVEL_3
    };
    int deviceLevel = c.get(CameraCharacteristics.INFO_SUPPORTED_HARDWARE_LEVEL);
    if (requiredLevel == deviceLevel) {
        return true;
    }
    for (int sortedlevel : sortedHwLevels) {
        if (sortedlevel == requiredLevel) {
            return true;
        } else if (sortedlevel == deviceLevel) {
            return false;
        }
    }
    return false; // Should never reach here
}
At a high level, the levels are:

LEGACY devices operate in a backwards-compatibility mode for older Android devices, and have very limited capabilities.
LIMITED devices represent the baseline feature set, and may also include additional capabilities that are subsets of FULL.
FULL devices additionally support per-frame manual control of sensor, flash, lens and post-processing settings, and image capture at a high rate.
LEVEL_3 devices additionally support YUV reprocessing and RAW image capture, along with additional output stream configurations.
EXTERNAL devices are similar to LIMITED devices with exceptions like some sensor or lens information not reported or less stable framerates.
See the individual level enums for full descriptions of the supported capabilities. The ACAMERA_REQUEST_AVAILABLE_CAPABILITIES entry describes the device's capabilities at a finer-grain level, if needed. In addition, many controls have their available settings or ranges defined in individual entries from ACameraManager_getCameraCharacteristics.

Some features are not part of any particular hardware level or capability and must be queried separately. These include:

Calibrated timestamps (ACAMERA_SENSOR_INFO_TIMESTAMP_SOURCE == REALTIME)
Precision lens control (ACAMERA_LENS_INFO_FOCUS_DISTANCE_CALIBRATION == CALIBRATED)
Face detection (ACAMERA_STATISTICS_INFO_AVAILABLE_FACE_DETECT_MODES)
Optical or electrical image stabilization (ACAMERA_LENS_INFO_AVAILABLE_OPTICAL_STABILIZATION, ACAMERA_CONTROL_AVAILABLE_VIDEO_STABILIZATION_MODES)
See also: ACAMERA_CONTROL_AVAILABLE_VIDEO_STABILIZATION_MODES See also: ACAMERA_LENS_INFO_AVAILABLE_OPTICAL_STABILIZATION See also: ACAMERA_LENS_INFO_FOCUS_DISTANCE_CALIBRATION See also: ACAMERA_REQUEST_AVAILABLE_CAPABILITIES See also: ACAMERA_SENSOR_INFO_TIMESTAMP_SOURCE See also: ACAMERA_STATISTICS_INFO_AVAILABLE_FACE_DETECT_MODES

ACAMERA_INFO_VERSION	
A short string for manufacturer version information about the camera device, such as ISP hardware, sensors, etc.

Type: byte

This tag may appear in:

ACameraMetadata from ACameraManager_getCameraCharacteristics
This can be used in TAG_IMAGE_DESCRIPTION in jpeg EXIF. This key may be absent if no version information is available on the device.

ACAMERA_JPEG_AVAILABLE_THUMBNAIL_SIZES	
List of JPEG thumbnail sizes for ACAMERA_JPEG_THUMBNAIL_SIZE supported by this camera device.

See also: ACAMERA_JPEG_THUMBNAIL_SIZE

Type: int32[2*n]

This tag may appear in:

ACameraMetadata from ACameraManager_getCameraCharacteristics
This list will include at least one non-zero resolution, plus (0,0) for indicating no thumbnail should be generated.

Below conditions will be satisfied for this size list:

The sizes will be sorted by increasing pixel area (width x height). If several resolutions have the same area, they will be sorted by increasing width.
The aspect ratio of the largest thumbnail size will be same as the aspect ratio of largest JPEG output size in ACAMERA_SCALER_AVAILABLE_STREAM_CONFIGURATIONS. The largest size is defined as the size that has the largest pixel area in a given size list.
Each output JPEG size in ACAMERA_SCALER_AVAILABLE_STREAM_CONFIGURATIONS will have at least one corresponding size that has the same aspect ratio in availableThumbnailSizes, and vice versa.
All non-(0, 0) sizes will have non-zero widths and heights.
This list is also used as supported thumbnail sizes for HEIC image format capture.

See also: ACAMERA_SCALER_AVAILABLE_STREAM_CONFIGURATIONS

ACAMERA_JPEG_END	
ACAMERA_JPEG_GPS_COORDINATES	
GPS coordinates to include in output JPEG EXIF.

Type: double[3]

This tag may appear in:

ACameraMetadata from ACameraCaptureSession_captureCallback_result callbacks
ACaptureRequest
This tag is also used for HEIC image capture.

ACAMERA_JPEG_GPS_PROCESSING_METHOD	
32 characters describing GPS algorithm to include in EXIF.

Type: byte

This tag may appear in:

ACameraMetadata from ACameraCaptureSession_captureCallback_result callbacks
ACaptureRequest
This tag is also used for HEIC image capture.

ACAMERA_JPEG_GPS_TIMESTAMP	
Time GPS fix was made to include in EXIF.

Type: int64

This tag may appear in:

ACameraMetadata from ACameraCaptureSession_captureCallback_result callbacks
ACaptureRequest
This tag is also used for HEIC image capture.

ACAMERA_JPEG_ORIENTATION	
The orientation for a JPEG image.

Type: int32

This tag may appear in:

ACameraMetadata from ACameraCaptureSession_captureCallback_result callbacks
ACaptureRequest
The clockwise rotation angle in degrees, relative to the orientation to the camera, that the JPEG picture needs to be rotated by, to be viewed upright.

Camera devices may either encode this value into the JPEG EXIF header, or rotate the image data to match this orientation. When the image data is rotated, the thumbnail data will also be rotated.

Note that this orientation is relative to the orientation of the camera sensor, given by ACAMERA_SENSOR_ORIENTATION.

To translate from the device orientation given by the Android sensor APIs for camera sensors which are not EXTERNAL, the following sample code may be used:

private int getJpegOrientation(CameraCharacteristics c, int deviceOrientation) {
    if (deviceOrientation == android.view.OrientationEventListener.ORIENTATION_UNKNOWN) return 0;
    int sensorOrientation = c.get(CameraCharacteristics.SENSOR_ORIENTATION);
    // Round device orientation to a multiple of 90
    deviceOrientation = (deviceOrientation + 45) / 90 * 90;
    // Reverse device orientation for front-facing cameras
    boolean facingFront = c.get(CameraCharacteristics.LENS_FACING) == CameraCharacteristics.LENS_FACING_FRONT;
    if (facingFront) deviceOrientation = -deviceOrientation;
    // Calculate desired JPEG orientation relative to camera orientation to make
    // the image upright relative to the device orientation
    int jpegOrientation = (sensorOrientation + deviceOrientation + 360) % 360;
    return jpegOrientation;
}
For EXTERNAL cameras the sensor orientation will always be set to 0 and the facing will also be set to EXTERNAL. The above code is not relevant in such case.

This tag is also used to describe the orientation of the HEIC image capture, in which case the rotation is reflected by EXIF orientation flag, and not by rotating the image data itself.

See also: ACAMERA_SENSOR_ORIENTATION

ACAMERA_JPEG_QUALITY	
Compression quality of the final JPEG image.

Type: byte

This tag may appear in:

ACameraMetadata from ACameraCaptureSession_captureCallback_result callbacks
ACaptureRequest
85-95 is typical usage range. This tag is also used to describe the quality of the HEIC image capture.

ACAMERA_JPEG_THUMBNAIL_QUALITY	
Compression quality of JPEG thumbnail.

Type: byte

This tag may appear in:

ACameraMetadata from ACameraCaptureSession_captureCallback_result callbacks
ACaptureRequest
This tag is also used to describe the quality of the HEIC image capture.

ACAMERA_JPEG_THUMBNAIL_SIZE	
Resolution of embedded JPEG thumbnail.

Type: int32[2]

This tag may appear in:

ACameraMetadata from ACameraCaptureSession_captureCallback_result callbacks
ACaptureRequest
When set to (0, 0) value, the JPEG EXIF will not contain thumbnail, but the captured JPEG will still be a valid image.

For best results, when issuing a request for a JPEG image, the thumbnail size selected should have the same aspect ratio as the main JPEG output.

If the thumbnail image aspect ratio differs from the JPEG primary image aspect ratio, the camera device creates the thumbnail by cropping it from the primary image. For example, if the primary image has 4:3 aspect ratio, the thumbnail image has 16:9 aspect ratio, the primary image will be cropped vertically (letterbox) to generate the thumbnail image. The thumbnail image will always have a smaller Field Of View (FOV) than the primary image when aspect ratios differ.

When an ACAMERA_JPEG_ORIENTATION of non-zero degree is requested, the camera device will handle thumbnail rotation in one of the following ways:

Set the EXIF orientation flag and keep jpeg and thumbnail image data unrotated.
Rotate the jpeg and thumbnail image data and not set EXIF orientation flag. In this case, LIMITED or FULL hardware level devices will report rotated thumbnail size in capture result, so the width and height will be interchanged if 90 or 270 degree orientation is requested. LEGACY device will always report unrotated thumbnail size.
The tag is also used as thumbnail size for HEIC image format capture, in which case the the thumbnail rotation is reflected by EXIF orientation flag, and not by rotating the thumbnail data itself.

See also: ACAMERA_JPEG_ORIENTATION

ACAMERA_LENS_APERTURE	
The desired lens aperture size, as a ratio of lens focal length to the effective aperture diameter.

Type: float

This tag may appear in:

ACameraMetadata from ACameraCaptureSession_captureCallback_result callbacks
ACaptureRequest
Setting this value is only supported on the camera devices that have a variable aperture lens.

When this is supported and ACAMERA_CONTROL_AE_MODE is OFF, this can be set along with ACAMERA_SENSOR_EXPOSURE_TIME, ACAMERA_SENSOR_SENSITIVITY, and ACAMERA_SENSOR_FRAME_DURATION to achieve manual exposure control.

The requested aperture value may take several frames to reach the requested value; the camera device will report the current (intermediate) aperture size in capture result metadata while the aperture is changing. While the aperture is still changing, ACAMERA_LENS_STATE will be set to MOVING.

When this is supported and ACAMERA_CONTROL_AE_MODE is one of the ON modes, this will be overridden by the camera device auto-exposure algorithm, the overridden values are then provided back to the user in the corresponding result.

See also: ACAMERA_CONTROL_AE_MODE See also: ACAMERA_LENS_STATE See also: ACAMERA_SENSOR_EXPOSURE_TIME See also: ACAMERA_SENSOR_FRAME_DURATION See also: ACAMERA_SENSOR_SENSITIVITY

ACAMERA_LENS_DISTORTION	
The correction coefficients to correct for this camera device's radial and tangential lens distortion.

Replaces the deprecated ACAMERA_LENS_RADIAL_DISTORTION field, which was inconsistently defined.

See also:ACAMERA_LENS_RADIAL_DISTORTION

Type: float[5]

This tag may appear in:

ACameraMetadata from ACameraManager_getCameraCharacteristics
ACameraMetadata from ACameraCaptureSession_captureCallback_result callbacks
Three radial distortion coefficients [kappa_1, kappa_2, kappa_3] and two tangential distortion coefficients [kappa_4, kappa_5] that can be used to correct the lens's geometric distortion with the mapping equations:

 x_c = x_i * ( 1 + kappa_1 * r^2 + kappa_2 * r^4 + kappa_3 * r^6 ) +
       kappa_4 * (2 * x_i * y_i) + kappa_5 * ( r^2 + 2 * x_i^2 )
 y_c = y_i * ( 1 + kappa_1 * r^2 + kappa_2 * r^4 + kappa_3 * r^6 ) +
       kappa_5 * (2 * x_i * y_i) + kappa_4 * ( r^2 + 2 * y_i^2 )
Here, [x_c, y_c] are the coordinates to sample in the input image that correspond to the pixel values in the corrected image at the coordinate [x_i, y_i]:

 correctedImage(x_i, y_i) = sample_at(x_c, y_c, inputImage)
The pixel coordinates are defined in a coordinate system related to the ACAMERA_LENS_INTRINSIC_CALIBRATION calibration fields; see that entry for details of the mapping stages. Both [x_i, y_i] and [x_c, y_c] have (0,0) at the lens optical center [c_x, c_y], and the range of the coordinates depends on the focal length terms of the intrinsic calibration.

Finally, r represents the radial distance from the optical center, r^2 = x_i^2 + y_i^2.

The distortion model used is the Brown-Conrady model.

See also: ACAMERA_LENS_INTRINSIC_CALIBRATION

ACAMERA_LENS_DISTORTION_MAXIMUM_RESOLUTION	
The correction coefficients to correct for this camera device's radial and tangential lens distortion for a CaptureRequest with ACAMERA_SENSOR_PIXEL_MODE set to CameraMetadata::SENSOR_PIXEL_MODE_MAXIMUM_RESOLUTION.

See also: ACAMERA_SENSOR_PIXEL_MODE

Type: float[5]

This tag may appear in:

ACameraMetadata from ACameraManager_getCameraCharacteristics
Analogous to ACAMERA_LENS_DISTORTION, when ACAMERA_SENSOR_PIXEL_MODE is set to CameraMetadata::SENSOR_PIXEL_MODE_MAXIMUM_RESOLUTION.

See also: ACAMERA_LENS_DISTORTION See also: ACAMERA_SENSOR_PIXEL_MODE

ACAMERA_LENS_END	
ACAMERA_LENS_FACING	
Direction the camera faces relative to device screen.

Type: byte (acamera_metadata_enum_android_lens_facing_t)

This tag may appear in:

ACameraMetadata from ACameraManager_getCameraCharacteristics
ACAMERA_LENS_FILTER_DENSITY	
The desired setting for the lens neutral density filter(s).

Type: float

This tag may appear in:

ACameraMetadata from ACameraCaptureSession_captureCallback_result callbacks
ACaptureRequest
This control will not be supported on most camera devices.

Lens filters are typically used to lower the amount of light the sensor is exposed to (measured in steps of EV). As used here, an EV step is the standard logarithmic representation, which are non-negative, and inversely proportional to the amount of light hitting the sensor. For example, setting this to 0 would result in no reduction of the incoming light, and setting this to 2 would mean that the filter is set to reduce incoming light by two stops (allowing 1/4 of the prior amount of light to the sensor).

It may take several frames before the lens filter density changes to the requested value. While the filter density is still changing, ACAMERA_LENS_STATE will be set to MOVING.

See also: ACAMERA_LENS_STATE

ACAMERA_LENS_FOCAL_LENGTH	
The desired lens focal length; used for optical zoom.

Type: float

This tag may appear in:

ACameraMetadata from ACameraCaptureSession_captureCallback_result callbacks
ACaptureRequest
This setting controls the physical focal length of the camera device's lens. Changing the focal length changes the field of view of the camera device, and is usually used for optical zoom.

Like ACAMERA_LENS_FOCUS_DISTANCE and ACAMERA_LENS_APERTURE, this setting won't be applied instantaneously, and it may take several frames before the lens can change to the requested focal length. While the focal length is still changing, ACAMERA_LENS_STATE will be set to MOVING.

Optical zoom via this control will not be supported on most devices. Starting from API level 30, the camera device may combine optical and digital zoom through the ACAMERA_CONTROL_ZOOM_RATIO control.

See also: ACAMERA_CONTROL_ZOOM_RATIO See also: ACAMERA_LENS_APERTURE See also: ACAMERA_LENS_FOCUS_DISTANCE See also: ACAMERA_LENS_STATE

ACAMERA_LENS_FOCUS_DISTANCE	
Desired distance to plane of sharpest focus, measured from frontmost surface of the lens.

Type: float

This tag may appear in:

ACameraMetadata from ACameraCaptureSession_captureCallback_result callbacks
ACaptureRequest
Should be zero for fixed-focus cameras

ACAMERA_LENS_FOCUS_RANGE	
The range of scene distances that are in sharp focus (depth of field).

Type: float[2]

This tag may appear in:

ACameraMetadata from ACameraCaptureSession_captureCallback_result callbacks
If variable focus not supported, can still report fixed depth of field range

ACAMERA_LENS_INFO_AVAILABLE_APERTURES	
List of aperture size values for ACAMERA_LENS_APERTURE that are supported by this camera device.

See also: ACAMERA_LENS_APERTURE

Type: float[n]

This tag may appear in:

ACameraMetadata from ACameraManager_getCameraCharacteristics
If the camera device doesn't support a variable lens aperture, this list will contain only one value, which is the fixed aperture size.

If the camera device supports a variable aperture, the aperture values in this list will be sorted in ascending order.

ACAMERA_LENS_INFO_AVAILABLE_FILTER_DENSITIES	
List of neutral density filter values for ACAMERA_LENS_FILTER_DENSITY that are supported by this camera device.

See also: ACAMERA_LENS_FILTER_DENSITY

Type: float[n]

This tag may appear in:

ACameraMetadata from ACameraManager_getCameraCharacteristics
If a neutral density filter is not supported by this camera device, this list will contain only 0. Otherwise, this list will include every filter density supported by the camera device, in ascending order.

ACAMERA_LENS_INFO_AVAILABLE_FOCAL_LENGTHS	
List of focal lengths for ACAMERA_LENS_FOCAL_LENGTH that are supported by this camera device.

See also: ACAMERA_LENS_FOCAL_LENGTH

Type: float[n]

This tag may appear in:

ACameraMetadata from ACameraManager_getCameraCharacteristics
If optical zoom is not supported, this list will only contain a single value corresponding to the fixed focal length of the device. Otherwise, this list will include every focal length supported by the camera device, in ascending order.

ACAMERA_LENS_INFO_AVAILABLE_OPTICAL_STABILIZATION	
List of optical image stabilization (OIS) modes for ACAMERA_LENS_OPTICAL_STABILIZATION_MODE that are supported by this camera device.

See also: ACAMERA_LENS_OPTICAL_STABILIZATION_MODE

Type: byte[n]

This tag may appear in:

ACameraMetadata from ACameraManager_getCameraCharacteristics
If OIS is not supported by a given camera device, this list will contain only OFF.

ACAMERA_LENS_INFO_END	
ACAMERA_LENS_INFO_FOCUS_DISTANCE_CALIBRATION	
The lens focus distance calibration quality.

Type: byte (acamera_metadata_enum_android_lens_info_focus_distance_calibration_t)

This tag may appear in:

ACameraMetadata from ACameraManager_getCameraCharacteristics
The lens focus distance calibration quality determines the reliability of focus related metadata entries, i.e. ACAMERA_LENS_FOCUS_DISTANCE, ACAMERA_LENS_FOCUS_RANGE, ACAMERA_LENS_INFO_HYPERFOCAL_DISTANCE, and ACAMERA_LENS_INFO_MINIMUM_FOCUS_DISTANCE.

APPROXIMATE and CALIBRATED devices report the focus metadata in units of diopters (1/meter), so 0.0f represents focusing at infinity, and increasing positive numbers represent focusing closer and closer to the camera device. The focus distance control also uses diopters on these devices.

UNCALIBRATED devices do not use units that are directly comparable to any real physical measurement, but 0.0f still represents farthest focus, and ACAMERA_LENS_INFO_MINIMUM_FOCUS_DISTANCE represents the nearest focus the device can achieve.

See also: ACAMERA_LENS_FOCUS_DISTANCE See also: ACAMERA_LENS_FOCUS_RANGE See also: ACAMERA_LENS_INFO_HYPERFOCAL_DISTANCE See also: ACAMERA_LENS_INFO_MINIMUM_FOCUS_DISTANCE

ACAMERA_LENS_INFO_HYPERFOCAL_DISTANCE	
Hyperfocal distance for this lens.

Type: float

This tag may appear in:

ACameraMetadata from ACameraManager_getCameraCharacteristics
If the lens is not fixed focus, the camera device will report this field when ACAMERA_LENS_INFO_FOCUS_DISTANCE_CALIBRATION is APPROXIMATE or CALIBRATED.

See also: ACAMERA_LENS_INFO_FOCUS_DISTANCE_CALIBRATION

ACAMERA_LENS_INFO_MINIMUM_FOCUS_DISTANCE	
Shortest distance from frontmost surface of the lens that can be brought into sharp focus.

Type: float

This tag may appear in:

ACameraMetadata from ACameraManager_getCameraCharacteristics
If the lens is fixed-focus, this will be 0.

ACAMERA_LENS_INFO_SHADING_MAP_SIZE	
Dimensions of lens shading map.

Type: int32[2]

This tag may appear in:

ACameraMetadata from ACameraManager_getCameraCharacteristics
The map should be on the order of 30-40 rows and columns, and must be smaller than 64x64.

ACAMERA_LENS_INTRINSIC_CALIBRATION	
The parameters for this camera device's intrinsic calibration.

Type: float[5]

This tag may appear in:

ACameraMetadata from ACameraManager_getCameraCharacteristics
ACameraMetadata from ACameraCaptureSession_captureCallback_result callbacks
The five calibration parameters that describe the transform from camera-centric 3D coordinates to sensor pixel coordinates:

[f_x, f_y, c_x, c_y, s]
Where f_x and f_y are the horizontal and vertical focal lengths, [c_x, c_y] is the position of the optical axis, and s is a skew parameter for the sensor plane not being aligned with the lens plane.

These are typically used within a transformation matrix K:

K = [ f_x,   s, c_x,
       0, f_y, c_y,
       0    0,   1 ]
which can then be combined with the camera pose rotation R and translation t (ACAMERA_LENS_POSE_ROTATION and ACAMERA_LENS_POSE_TRANSLATION, respectively) to calculate the complete transform from world coordinates to pixel coordinates:

P = [ K 0   * [ R -Rt
     0 1 ]      0 1 ]
(Note the negation of poseTranslation when mapping from camera to world coordinates, and multiplication by the rotation).

With p_w being a point in the world coordinate system and p_s being a point in the camera active pixel array coordinate system, and with the mapping including the homogeneous division by z:

 p_h = (x_h, y_h, z_h) = P p_w
p_s = p_h / z_h
so [x_s, y_s] is the pixel coordinates of the world point, z_s = 1, and w_s is a measurement of disparity (depth) in pixel coordinates.

Note that the coordinate system for this transform is the ACAMERA_SENSOR_INFO_PRE_CORRECTION_ACTIVE_ARRAY_SIZE system, where (0,0) is the top-left of the preCorrectionActiveArraySize rectangle. Once the pose and intrinsic calibration transforms have been applied to a world point, then the ACAMERA_LENS_DISTORTION transform needs to be applied, and the result adjusted to be in the ACAMERA_SENSOR_INFO_ACTIVE_ARRAY_SIZE coordinate system (where (0, 0) is the top-left of the activeArraySize rectangle), to determine the final pixel coordinate of the world point for processed (non-RAW) output buffers.

For camera devices, the center of pixel (x,y) is located at coordinate (x + 0.5, y + 0.5). So on a device with a precorrection active array of size (10,10), the valid pixel indices go from (0,0)-(9,9), and an perfectly-built camera would have an optical center at the exact center of the pixel grid, at coordinates (5.0, 5.0), which is the top-left corner of pixel (5,5).

See also: ACAMERA_LENS_DISTORTION See also: ACAMERA_LENS_POSE_ROTATION See also: ACAMERA_LENS_POSE_TRANSLATION See also: ACAMERA_SENSOR_INFO_ACTIVE_ARRAY_SIZE See also: ACAMERA_SENSOR_INFO_PRE_CORRECTION_ACTIVE_ARRAY_SIZE

ACAMERA_LENS_INTRINSIC_CALIBRATION_MAXIMUM_RESOLUTION	
The parameters for this camera device's intrinsic calibration when ACAMERA_SENSOR_PIXEL_MODE is set to CameraMetadata::SENSOR_PIXEL_MODE_MAXIMUM_RESOLUTION.

See also: ACAMERA_SENSOR_PIXEL_MODE

Type: float[5]

This tag may appear in:

ACameraMetadata from ACameraManager_getCameraCharacteristics
Analogous to ACAMERA_LENS_INTRINSIC_CALIBRATION, when ACAMERA_SENSOR_PIXEL_MODE is set to CameraMetadata::SENSOR_PIXEL_MODE_MAXIMUM_RESOLUTION.

See also: ACAMERA_LENS_INTRINSIC_CALIBRATION See also: ACAMERA_SENSOR_PIXEL_MODE

ACAMERA_LENS_OPTICAL_STABILIZATION_MODE	
Sets whether the camera device uses optical image stabilization (OIS) when capturing images.

Type: byte (acamera_metadata_enum_android_lens_optical_stabilization_mode_t)

This tag may appear in:

ACameraMetadata from ACameraCaptureSession_captureCallback_result callbacks
ACaptureRequest
OIS is used to compensate for motion blur due to small movements of the camera during capture. Unlike digital image stabilization (ACAMERA_CONTROL_VIDEO_STABILIZATION_MODE), OIS makes use of mechanical elements to stabilize the camera sensor, and thus allows for longer exposure times before camera shake becomes apparent.

Switching between different optical stabilization modes may take several frames to initialize, the camera device will report the current mode in capture result metadata. For example, When "ON" mode is requested, the optical stabilization modes in the first several capture results may still be "OFF", and it will become "ON" when the initialization is done.

If a camera device supports both OIS and digital image stabilization (ACAMERA_CONTROL_VIDEO_STABILIZATION_MODE), turning both modes on may produce undesirable interaction, so it is recommended not to enable both at the same time.

If ACAMERA_CONTROL_VIDEO_STABILIZATION_MODE is set to "PREVIEW_STABILIZATION", ACAMERA_LENS_OPTICAL_STABILIZATION_MODE is overridden. The camera sub-system may choose to turn on hardware based image stabilization in addition to software based stabilization if it deems that appropriate. This key's value in the capture result will reflect which OIS mode was chosen.

Not all devices will support OIS; see ACAMERA_LENS_INFO_AVAILABLE_OPTICAL_STABILIZATION for available controls.

See also: ACAMERA_CONTROL_VIDEO_STABILIZATION_MODE See also: ACAMERA_LENS_INFO_AVAILABLE_OPTICAL_STABILIZATION See also: ACAMERA_LENS_OPTICAL_STABILIZATION_MODE

ACAMERA_LENS_POSE_REFERENCE	
The origin for ACAMERA_LENS_POSE_TRANSLATION, and the accuracy of ACAMERA_LENS_POSE_TRANSLATION and ACAMERA_LENS_POSE_ROTATION.

See also: ACAMERA_LENS_POSE_ROTATION See also: ACAMERA_LENS_POSE_TRANSLATION

Type: byte (acamera_metadata_enum_android_lens_pose_reference_t)

This tag may appear in:

ACameraMetadata from ACameraManager_getCameraCharacteristics
Different calibration methods and use cases can produce better or worse results depending on the selected coordinate origin.

ACAMERA_LENS_POSE_ROTATION	
The orientation of the camera relative to the sensor coordinate system.

Type: float[4]

This tag may appear in:

ACameraMetadata from ACameraManager_getCameraCharacteristics
ACameraMetadata from ACameraCaptureSession_captureCallback_result callbacks
The four coefficients that describe the quaternion rotation from the Android sensor coordinate system to a camera-aligned coordinate system where the X-axis is aligned with the long side of the image sensor, the Y-axis is aligned with the short side of the image sensor, and the Z-axis is aligned with the optical axis of the sensor.

To convert from the quaternion coefficients (x,y,z,w) to the axis of rotation (a_x, a_y, a_z) and rotation amount theta, the following formulas can be used:

 theta = 2 * acos(w)
a_x = x / sin(theta/2)
a_y = y / sin(theta/2)
a_z = z / sin(theta/2)
To create a 3x3 rotation matrix that applies the rotation defined by this quaternion, the following matrix can be used:

R = [ 1 - 2y^2 - 2z^2,       2xy - 2zw,       2xz + 2yw,
           2xy + 2zw, 1 - 2x^2 - 2z^2,       2yz - 2xw,
           2xz - 2yw,       2yz + 2xw, 1 - 2x^2 - 2y^2 ]
This matrix can then be used to apply the rotation to a column vector point with

p' = Rp

where p is in the device sensor coordinate system, and p' is in the camera-oriented coordinate system.

If ACAMERA_LENS_POSE_REFERENCE is UNDEFINED, the quaternion rotation cannot be accurately represented by the camera device, and will be represented by default values matching its default facing.

See also: ACAMERA_LENS_POSE_REFERENCE

ACAMERA_LENS_POSE_TRANSLATION	
Position of the camera optical center.

Type: float[3]

This tag may appear in:

ACameraMetadata from ACameraManager_getCameraCharacteristics
ACameraMetadata from ACameraCaptureSession_captureCallback_result callbacks
The position of the camera device's lens optical center, as a three-dimensional vector (x,y,z).

Prior to Android P, or when ACAMERA_LENS_POSE_REFERENCE is PRIMARY_CAMERA, this position is relative to the optical center of the largest camera device facing in the same direction as this camera, in the Android sensor coordinate axes. Note that only the axis definitions are shared with the sensor coordinate system, but not the origin.

If this device is the largest or only camera device with a given facing, then this position will be (0, 0, 0); a camera device with a lens optical center located 3 cm from the main sensor along the +X axis (to the right from the user's perspective) will report (0.03, 0, 0). Note that this means that, for many computer vision applications, the position needs to be negated to convert it to a translation from the camera to the origin.

To transform a pixel coordinates between two cameras facing the same direction, first the source camera ACAMERA_LENS_DISTORTION must be corrected for. Then the source camera ACAMERA_LENS_INTRINSIC_CALIBRATION needs to be applied, followed by the ACAMERA_LENS_POSE_ROTATION of the source camera, the translation of the source camera relative to the destination camera, the ACAMERA_LENS_POSE_ROTATION of the destination camera, and finally the inverse of ACAMERA_LENS_INTRINSIC_CALIBRATION of the destination camera. This obtains a radial-distortion-free coordinate in the destination camera pixel coordinates.

To compare this against a real image from the destination camera, the destination camera image then needs to be corrected for radial distortion before comparison or sampling.

When ACAMERA_LENS_POSE_REFERENCE is GYROSCOPE, then this position is relative to the center of the primary gyroscope on the device. The axis definitions are the same as with PRIMARY_CAMERA.

When ACAMERA_LENS_POSE_REFERENCE is UNDEFINED, this position cannot be accurately represented by the camera device, and will be represented as (0, 0, 0).

When ACAMERA_LENS_POSE_REFERENCE is AUTOMOTIVE, then this position is relative to the origin of the automotive sensor coordinate system, which is at the center of the rear axle.

See also: ACAMERA_LENS_DISTORTION See also: ACAMERA_LENS_INTRINSIC_CALIBRATION See also: ACAMERA_LENS_POSE_REFERENCE See also: ACAMERA_LENS_POSE_ROTATION

ACAMERA_LENS_RADIAL_DISTORTION	
ACAMERA_LENS_STATE	
Current lens status.

Type: byte (acamera_metadata_enum_android_lens_state_t)

This tag may appear in:

ACameraMetadata from ACameraCaptureSession_captureCallback_result callbacks
For lens parameters ACAMERA_LENS_FOCAL_LENGTH, ACAMERA_LENS_FOCUS_DISTANCE, ACAMERA_LENS_FILTER_DENSITY and ACAMERA_LENS_APERTURE, when changes are requested, they may take several frames to reach the requested values. This state indicates the current status of the lens parameters.

When the state is STATIONARY, the lens parameters are not changing. This could be either because the parameters are all fixed, or because the lens has had enough time to reach the most recently-requested values. If all these lens parameters are not changeable for a camera device, as listed below:

Fixed focus (ACAMERA_LENS_INFO_MINIMUM_FOCUS_DISTANCE == 0), which means ACAMERA_LENS_FOCUS_DISTANCE parameter will always be 0.
Fixed focal length (ACAMERA_LENS_INFO_AVAILABLE_FOCAL_LENGTHS contains single value), which means the optical zoom is not supported.
No ND filter (ACAMERA_LENS_INFO_AVAILABLE_FILTER_DENSITIES contains only 0).
Fixed aperture (ACAMERA_LENS_INFO_AVAILABLE_APERTURES contains single value).
Then this state will always be STATIONARY.

When the state is MOVING, it indicates that at least one of the lens parameters is changing.

See also: ACAMERA_LENS_APERTURE See also: ACAMERA_LENS_FILTER_DENSITY See also: ACAMERA_LENS_FOCAL_LENGTH See also: ACAMERA_LENS_FOCUS_DISTANCE See also: ACAMERA_LENS_INFO_AVAILABLE_APERTURES See also: ACAMERA_LENS_INFO_AVAILABLE_FILTER_DENSITIES See also: ACAMERA_LENS_INFO_AVAILABLE_FOCAL_LENGTHS See also: ACAMERA_LENS_INFO_MINIMUM_FOCUS_DISTANCE

ACAMERA_LOGICAL_MULTI_CAMERA_ACTIVE_PHYSICAL_ID	
String containing the ID of the underlying active physical camera.

Type: byte

This tag may appear in:

ACameraMetadata from ACameraCaptureSession_captureCallback_result callbacks
The ID of the active physical camera that's backing the logical camera. All camera streams and metadata that are not physical camera specific will be originating from this physical camera.

For a logical camera made up of physical cameras where each camera's lenses have different characteristics, the camera device may choose to switch between the physical cameras when application changes FOCAL_LENGTH or SCALER_CROP_REGION. At the time of lens switch, this result metadata reflects the new active physical camera ID.

This key will be available if the camera device advertises this key via ACAMERA_REQUEST_AVAILABLE_RESULT_KEYS. When available, this must be one of valid physical IDs backing this logical multi-camera. If this key is not available for a logical multi-camera, the camera device implementation may still switch between different active physical cameras based on use case, but the current active physical camera information won't be available to the application.

ACAMERA_LOGICAL_MULTI_CAMERA_END	
ACAMERA_LOGICAL_MULTI_CAMERA_PHYSICAL_IDS	
String containing the ids of the underlying physical cameras.

Type: byte[n]

This tag may appear in:

ACameraMetadata from ACameraManager_getCameraCharacteristics
For a logical camera, this is concatenation of all underlying physical camera IDs. The null terminator for physical camera ID must be preserved so that the whole string can be tokenized using '\0' to generate list of physical camera IDs.

For example, if the physical camera IDs of the logical camera are "2" and "3", the value of this tag will be ['2', '\0', '3', '\0'].

The number of physical camera IDs must be no less than 2.

ACAMERA_LOGICAL_MULTI_CAMERA_SENSOR_SYNC_TYPE	
The accuracy of frame timestamp synchronization between physical cameras

Type: byte (acamera_metadata_enum_android_logical_multi_camera_sensor_sync_type_t)

This tag may appear in:

ACameraMetadata from ACameraManager_getCameraCharacteristics
The accuracy of the frame timestamp synchronization determines the physical cameras' ability to start exposure at the same time. If the sensorSyncType is CALIBRATED, the physical camera sensors usually run in leader/follower mode where one sensor generates a timing signal for the other, so that their shutter time is synchronized. For APPROXIMATE sensorSyncType, the camera sensors usually run in leader/leader mode, where both sensors use their own timing generator, and there could be offset between their start of exposure.

In both cases, all images generated for a particular capture request still carry the same timestamps, so that they can be used to look up the matching frame number and onCaptureStarted callback.

This tag is only applicable if the logical camera device supports concurrent physical streams from different physical cameras.

ACAMERA_NOISE_REDUCTION_AVAILABLE_NOISE_REDUCTION_MODES	
List of noise reduction modes for ACAMERA_NOISE_REDUCTION_MODE that are supported by this camera device.

See also: ACAMERA_NOISE_REDUCTION_MODE

Type: byte[n]

This tag may appear in:

ACameraMetadata from ACameraManager_getCameraCharacteristics
Full-capability camera devices will always support OFF and FAST.

Camera devices that support YUV_REPROCESSING or PRIVATE_REPROCESSING will support ZERO_SHUTTER_LAG.

Legacy-capability camera devices will only support FAST mode.

ACAMERA_NOISE_REDUCTION_END	
ACAMERA_NOISE_REDUCTION_MODE	
Mode of operation for the noise reduction algorithm.

Type: byte (acamera_metadata_enum_android_noise_reduction_mode_t)

This tag may appear in:

ACameraMetadata from ACameraCaptureSession_captureCallback_result callbacks
ACaptureRequest
The noise reduction algorithm attempts to improve image quality by removing excessive noise added by the capture process, especially in dark conditions.

OFF means no noise reduction will be applied by the camera device, for both raw and YUV domain.

MINIMAL means that only sensor raw domain basic noise reduction is enabled ,to remove demosaicing or other processing artifacts. For YUV_REPROCESSING, MINIMAL is same as OFF. This mode is optional, may not be support by all devices. The application should check ACAMERA_NOISE_REDUCTION_AVAILABLE_NOISE_REDUCTION_MODES before using it.

FAST/HIGH_QUALITY both mean camera device determined noise filtering will be applied. HIGH_QUALITY mode indicates that the camera device will use the highest-quality noise filtering algorithms, even if it slows down capture rate. FAST means the camera device will not slow down capture rate when applying noise filtering. FAST may be the same as MINIMAL if MINIMAL is listed, or the same as OFF if any noise filtering will slow down capture rate. Every output stream will have a similar amount of enhancement applied.

ZERO_SHUTTER_LAG is meant to be used by applications that maintain a continuous circular buffer of high-resolution images during preview and reprocess image(s) from that buffer into a final capture when triggered by the user. In this mode, the camera device applies noise reduction to low-resolution streams (below maximum recording resolution) to maximize preview quality, but does not apply noise reduction to high-resolution streams, since those will be reprocessed later if necessary.

For YUV_REPROCESSING, these FAST/HIGH_QUALITY modes both mean that the camera device will apply FAST/HIGH_QUALITY YUV domain noise reduction, respectively. The camera device may adjust the noise reduction parameters for best image quality based on the android.reprocess.effectiveExposureFactor if it is set.

See also: ACAMERA_NOISE_REDUCTION_AVAILABLE_NOISE_REDUCTION_MODES

ACAMERA_REQUEST_AVAILABLE_CAPABILITIES	
List of capabilities that this camera device advertises as fully supporting.

Type: byte[n] (acamera_metadata_enum_android_request_available_capabilities_t)

This tag may appear in:

ACameraMetadata from ACameraManager_getCameraCharacteristics
A capability is a contract that the camera device makes in order to be able to satisfy one or more use cases.

Listing a capability guarantees that the whole set of features required to support a common use will all be available.

Using a subset of the functionality provided by an unsupported capability may be possible on a specific camera device implementation; to do this query each of ACAMERA_REQUEST_AVAILABLE_REQUEST_KEYS, ACAMERA_REQUEST_AVAILABLE_RESULT_KEYS, ACAMERA_REQUEST_AVAILABLE_CHARACTERISTICS_KEYS.

The following capabilities are guaranteed to be available on ACAMERA_INFO_SUPPORTED_HARDWARE_LEVEL == FULL devices:

MANUAL_SENSOR
MANUAL_POST_PROCESSING
Other capabilities may be available on either FULL or LIMITED devices, but the application should query this key to be sure.

See also: ACAMERA_INFO_SUPPORTED_HARDWARE_LEVEL See also: ACAMERA_REQUEST_AVAILABLE_CHARACTERISTICS_KEYS See also: ACAMERA_REQUEST_AVAILABLE_REQUEST_KEYS See also: ACAMERA_REQUEST_AVAILABLE_RESULT_KEYS

ACAMERA_REQUEST_AVAILABLE_CHARACTERISTICS_KEYS	
A list of all keys that the camera device has available to use with ACameraManager_getCameraCharacteristics.

Type: int32[n]

This tag may appear in:

ACameraMetadata from ACameraManager_getCameraCharacteristics
This entry follows the same rules as ACAMERA_REQUEST_AVAILABLE_RESULT_KEYS (except that it applies for CameraCharacteristics instead of CaptureResult). See above for more details.

See also: ACAMERA_REQUEST_AVAILABLE_RESULT_KEYS

ACAMERA_REQUEST_AVAILABLE_DYNAMIC_RANGE_PROFILES_MAP	
A map of all available 10-bit dynamic range profiles along with their capture request constraints.

Type: int64[n*3] (acamera_metadata_enum_android_request_available_dynamic_range_profiles_map_t)

This tag may appear in:

ACameraMetadata from ACameraManager_getCameraCharacteristics
Devices supporting the 10-bit output capability CameraCharacteristics::REQUEST_AVAILABLE_CAPABILITIES_DYNAMIC_RANGE_TEN_BIT must list their supported dynamic range profiles. In case the camera is not able to support every possible profile combination within a single capture request, then the constraints must be listed here as well.

ACAMERA_REQUEST_AVAILABLE_PHYSICAL_CAMERA_REQUEST_KEYS	
A subset of the available request keys that can be overridden for physical devices backing a logical multi-camera.

Type: int32[n]

This tag may appear in:

ACameraMetadata from ACameraManager_getCameraCharacteristics
This is a subset of ACAMERA_REQUEST_AVAILABLE_REQUEST_KEYS which contains a list of keys that can be overridden using Builder::setPhysicalCameraKey. The respective value of such request key can be obtained by calling Builder::getPhysicalCameraKey. Capture requests that contain individual physical device requests must be built via Set).

See also: ACAMERA_REQUEST_AVAILABLE_REQUEST_KEYS

ACAMERA_REQUEST_AVAILABLE_REQUEST_KEYS	
A list of all keys that the camera device has available to use with ACaptureRequest.

Type: int32[n]

This tag may appear in:

ACameraMetadata from ACameraManager_getCameraCharacteristics
Attempting to set a key into a CaptureRequest that is not listed here will result in an invalid request and will be rejected by the camera device.

This field can be used to query the feature set of a camera device at a more granular level than capabilities. This is especially important for optional keys that are not listed under any capability in ACAMERA_REQUEST_AVAILABLE_CAPABILITIES.

See also: ACAMERA_REQUEST_AVAILABLE_CAPABILITIES

ACAMERA_REQUEST_AVAILABLE_RESULT_KEYS	
A list of all keys that the camera device has available to use with ACameraCaptureSession_captureCallback_result.

Type: int32[n]

This tag may appear in:

ACameraMetadata from ACameraManager_getCameraCharacteristics
Attempting to get a key from a CaptureResult that is not listed here will always return a null value. Getting a key from a CaptureResult that is listed here will generally never return a null value.

The following keys may return null unless they are enabled:

ACAMERA_STATISTICS_LENS_SHADING_MAP (non-null iff ACAMERA_STATISTICS_LENS_SHADING_MAP_MODE == ON)
(Those sometimes-null keys will nevertheless be listed here if they are available.)

This field can be used to query the feature set of a camera device at a more granular level than capabilities. This is especially important for optional keys that are not listed under any capability in ACAMERA_REQUEST_AVAILABLE_CAPABILITIES.

See also: ACAMERA_REQUEST_AVAILABLE_CAPABILITIES See also: ACAMERA_STATISTICS_LENS_SHADING_MAP See also: ACAMERA_STATISTICS_LENS_SHADING_MAP_MODE

ACAMERA_REQUEST_AVAILABLE_SESSION_KEYS	
A subset of the available request keys that the camera device can pass as part of the capture session initialization.

Type: int32[n]

This tag may appear in:

ACameraMetadata from ACameraManager_getCameraCharacteristics
This is a subset of ACAMERA_REQUEST_AVAILABLE_REQUEST_KEYS which contains a list of keys that are difficult to apply per-frame and can result in unexpected delays when modified during the capture session lifetime. Typical examples include parameters that require a time-consuming hardware re-configuration or internal camera pipeline change. For performance reasons we advise clients to pass their initial values as part of ACameraDevice_createCaptureSessionWithSessionParameters. Once the camera capture session is enabled it is also recommended to avoid changing them from their initial values set in ACameraDevice_createCaptureSessionWithSessionParameters. Control over session parameters can still be exerted in capture requests but clients should be aware and expect delays during their application. An example usage scenario could look like this:

The camera client starts by querying the session parameter key list via ACameraManager_getCameraCharacteristics.
Before triggering the capture session create sequence, a capture request must be built via ACameraDevice_createCaptureRequest using an appropriate template matching the particular use case.
The client should go over the list of session parameters and check whether some of the keys listed matches with the parameters that they intend to modify as part of the first capture request.
If there is no such match, the capture request can be passed unmodified to ACameraDevice_createCaptureSessionWithSessionParameters.
If matches do exist, the client should update the respective values and pass the request to ACameraDevice_createCaptureSessionWithSessionParameters.
After the capture session initialization completes the session parameter key list can continue to serve as reference when posting or updating further requests. As mentioned above further changes to session parameters should ideally be avoided, if updates are necessary however clients could expect a delay/glitch during the parameter switch.
See also: ACAMERA_REQUEST_AVAILABLE_REQUEST_KEYS

ACAMERA_REQUEST_END	
ACAMERA_REQUEST_MAX_NUM_OUTPUT_STREAMS	
The maximum numbers of different types of output streams that can be configured and used simultaneously by a camera device.

Type: int32[3]

This tag may appear in:

ACameraMetadata from ACameraManager_getCameraCharacteristics
This is a 3 element tuple that contains the max number of output simultaneous streams for raw sensor, processed (but not stalling), and processed (and stalling) formats respectively. For example, assuming that JPEG is typically a processed and stalling stream, if max raw sensor format output stream number is 1, max YUV streams number is 3, and max JPEG stream number is 2, then this tuple should be (1, 3, 2).

This lists the upper bound of the number of output streams supported by the camera device. Using more streams simultaneously may require more hardware and CPU resources that will consume more power. The image format for an output stream can be any supported format provided by ACAMERA_SCALER_AVAILABLE_STREAM_CONFIGURATIONS. The formats defined in ACAMERA_SCALER_AVAILABLE_STREAM_CONFIGURATIONS can be categorized into the 3 stream types as below:

Processed (but stalling): any non-RAW format with a stallDurations > 0. Typically JPEG format.
Raw formats: RAW_SENSOR, RAW10, or RAW12.
Processed (but not-stalling): any non-RAW format without a stall duration. Typically YUV_420_888, NV21, YV12, or Y8 .
See also: ACAMERA_SCALER_AVAILABLE_STREAM_CONFIGURATIONS

ACAMERA_REQUEST_PARTIAL_RESULT_COUNT	
Defines how many sub-components a result will be composed of.

Type: int32

This tag may appear in:

ACameraMetadata from ACameraManager_getCameraCharacteristics
In order to combat the pipeline latency, partial results may be delivered to the application layer from the camera device as soon as they are available.

Optional; defaults to 1. A value of 1 means that partial results are not supported, and only the final TotalCaptureResult will be produced by the camera device.

A typical use case for this might be: after requesting an auto-focus (AF) lock the new AF state might be available 50% of the way through the pipeline. The camera device could then immediately dispatch this state via a partial result to the application, and the rest of the metadata via later partial results.

ACAMERA_REQUEST_PIPELINE_DEPTH	
Specifies the number of pipeline stages the frame went through from when it was exposed to when the final completed result was available to the framework.

Type: byte

This tag may appear in:

ACameraMetadata from ACameraCaptureSession_captureCallback_result callbacks
Depending on what settings are used in the request, and what streams are configured, the data may undergo less processing, and some pipeline stages skipped.

See ACAMERA_REQUEST_PIPELINE_MAX_DEPTH for more details.

See also: ACAMERA_REQUEST_PIPELINE_MAX_DEPTH

ACAMERA_REQUEST_PIPELINE_MAX_DEPTH	
Specifies the number of maximum pipeline stages a frame has to go through from when it's exposed to when it's available to the framework.

Type: byte

This tag may appear in:

ACameraMetadata from ACameraManager_getCameraCharacteristics
A typical minimum value for this is 2 (one stage to expose, one stage to readout) from the sensor. The ISP then usually adds its own stages to do custom HW processing. Further stages may be added by SW processing.

Depending on what settings are used (e.g. YUV, JPEG) and what processing is enabled (e.g. face detection), the actual pipeline depth (specified by ACAMERA_REQUEST_PIPELINE_DEPTH) may be less than the max pipeline depth.

A pipeline depth of X stages is equivalent to a pipeline latency of X frame intervals.

This value will normally be 8 or less, however, for high speed capture session, the max pipeline depth will be up to 8 x size of high speed capture request list.

See also: ACAMERA_REQUEST_PIPELINE_DEPTH

ACAMERA_SCALER_AVAILABLE_MAX_DIGITAL_ZOOM	
The maximum ratio between both active area width and crop region width, and active area height and crop region height, for ACAMERA_SCALER_CROP_REGION.

See also: ACAMERA_SCALER_CROP_REGION

Type: float

This tag may appear in:

ACameraMetadata from ACameraManager_getCameraCharacteristics
This represents the maximum amount of zooming possible by the camera device, or equivalently, the minimum cropping window size.

Crop regions that have a width or height that is smaller than this ratio allows will be rounded up to the minimum allowed size by the camera device.

Starting from API level 30, when using ACAMERA_CONTROL_ZOOM_RATIO to zoom in or out, the application must use ACAMERA_CONTROL_ZOOM_RATIO_RANGE to query both the minimum and maximum zoom ratio.

See also: ACAMERA_CONTROL_ZOOM_RATIO See also: ACAMERA_CONTROL_ZOOM_RATIO_RANGE

ACAMERA_SCALER_AVAILABLE_MIN_FRAME_DURATIONS	
This lists the minimum frame duration for each format/size combination.

Type: int64[4*n]

This tag may appear in:

ACameraMetadata from ACameraManager_getCameraCharacteristics
This should correspond to the frame duration when only that stream is active, with all processing (typically in android.*.mode) set to either OFF or FAST.

When multiple streams are used in a request, the minimum frame duration will be max(individual stream min durations).

See ACAMERA_SENSOR_FRAME_DURATION and ACAMERA_SCALER_AVAILABLE_STALL_DURATIONS for more details about calculating the max frame rate.

See also: ACAMERA_SCALER_AVAILABLE_STALL_DURATIONS See also: ACAMERA_SENSOR_FRAME_DURATION

ACAMERA_SCALER_AVAILABLE_MIN_FRAME_DURATIONS_MAXIMUM_RESOLUTION	
This lists the minimum frame duration for each format/size combination when the camera device is sent a CaptureRequest with ACAMERA_SENSOR_PIXEL_MODE set to CameraMetadata::SENSOR_PIXEL_MODE_MAXIMUM_RESOLUTION.

See also: ACAMERA_SENSOR_PIXEL_MODE

Type: int64[4*n]

This tag may appear in:

ACameraMetadata from ACameraManager_getCameraCharacteristics
Analogous to ACAMERA_SCALER_AVAILABLE_MIN_FRAME_DURATIONS, for configurations which are applicable when ACAMERA_SENSOR_PIXEL_MODE is set to CameraMetadata::SENSOR_PIXEL_MODE_MAXIMUM_RESOLUTION.

When multiple streams are used in a request (if supported, when ACAMERA_SENSOR_PIXEL_MODE is set to CameraMetadata::SENSOR_PIXEL_MODE_MAXIMUM_RESOLUTION), the minimum frame duration will be max(individual stream min durations).

See ACAMERA_SENSOR_FRAME_DURATION and ACAMERA_SCALER_AVAILABLE_STALL_DURATIONS_MAXIMUM_RESOLUTION for more details about calculating the max frame rate.

See also: ACAMERA_SCALER_AVAILABLE_MIN_FRAME_DURATIONS See also: ACAMERA_SCALER_AVAILABLE_STALL_DURATIONS_MAXIMUM_RESOLUTION See also: ACAMERA_SENSOR_FRAME_DURATION See also: ACAMERA_SENSOR_PIXEL_MODE

ACAMERA_SCALER_AVAILABLE_RECOMMENDED_INPUT_OUTPUT_FORMATS_MAP	
Recommended mappings of image formats that are supported by this camera device for input streams, to their corresponding output formats.

Type: int32

This tag may appear in:

ACameraMetadata from ACameraManager_getCameraCharacteristics
This is a recommended subset of the complete list of mappings found in android.scaler.availableInputOutputFormatsMap. The same requirements apply here as well. The list however doesn't need to contain all available and supported mappings. Instead of this developers must list only recommended and efficient entries. If set, the information will be available in the ZERO_SHUTTER_LAG recommended stream configuration see CameraCharacteristics::getRecommendedStreamConfigurationMap.

ACAMERA_SCALER_AVAILABLE_RECOMMENDED_STREAM_CONFIGURATIONS	
Recommended stream configurations for common client use cases.

Type: int32[n*5] (acamera_metadata_enum_android_scaler_available_recommended_stream_configurations_t)

This tag may appear in:

ACameraMetadata from ACameraManager_getCameraCharacteristics
Optional subset of the ACAMERA_SCALER_AVAILABLE_STREAM_CONFIGURATIONS that contains similar tuples listed as (i.e. width, height, format, output/input stream, usecase bit field). Camera devices will be able to suggest particular stream configurations which are power and performance efficient for specific use cases. For more information about retrieving the suggestions see CameraCharacteristics::getRecommendedStreamConfigurationMap.

The data representation is int[5], which maps to (width, height, format, output/input stream, usecase bit field). The array can be parsed using the following pseudo code:

struct StreamConfiguration { int32_t format; int32_t width; int32_t height; int32_t isInput; };

void getPreferredStreamConfigurations( int32_t *array, size_t count, int32_t usecaseId, Vector < StreamConfiguration > * scs) { const size_t STREAM_CONFIGURATION_SIZE = 5; const size_t STREAM_WIDTH_OFFSET = 0; const size_t STREAM_HEIGHT_OFFSET = 1; const size_t STREAM_FORMAT_OFFSET = 2; const size_t STREAM_IS_INPUT_OFFSET = 3; const size_t STREAM_USECASE_BITMAP_OFFSET = 4;

for (size_t i = 0; i < count; i+= STREAM_CONFIGURATION_SIZE) {
    int32_t width = array[i + STREAM_WIDTH_OFFSET];
    int32_t height = array[i + STREAM_HEIGHT_OFFSET];
    int32_t format = array[i + STREAM_FORMAT_OFFSET];
    int32_t isInput = array[i + STREAM_IS_INPUT_OFFSET];
    int32_t supportedUsecases = array[i + STREAM_USECASE_BITMAP_OFFSET];
    if (supportedUsecases & (1 << usecaseId)) {
        StreamConfiguration sc = {format, width, height, isInput};
        scs->add(sc);
    }
}
}

See also: ACAMERA_SCALER_AVAILABLE_STREAM_CONFIGURATIONS

ACAMERA_SCALER_AVAILABLE_ROTATE_AND_CROP_MODES	
List of rotate-and-crop modes for ACAMERA_SCALER_ROTATE_AND_CROP that are supported by this camera device.

See also: ACAMERA_SCALER_ROTATE_AND_CROP

Type: byte[n]

This tag may appear in:

ACameraMetadata from ACameraManager_getCameraCharacteristics
This entry lists the valid modes for ACAMERA_SCALER_ROTATE_AND_CROP for this camera device.

Starting with API level 30, all devices will list at least ROTATE_AND_CROP_NONE. Devices with support for rotate-and-crop will additionally list at least ROTATE_AND_CROP_AUTO and ROTATE_AND_CROP_90.

See also: ACAMERA_SCALER_ROTATE_AND_CROP

ACAMERA_SCALER_AVAILABLE_STALL_DURATIONS	
This lists the maximum stall duration for each output format/size combination.

Type: int64[4*n]

This tag may appear in:

ACameraMetadata from ACameraManager_getCameraCharacteristics
A stall duration is how much extra time would get added to the normal minimum frame duration for a repeating request that has streams with non-zero stall.

For example, consider JPEG captures which have the following characteristics:

JPEG streams act like processed YUV streams in requests for which they are not included; in requests in which they are directly referenced, they act as JPEG streams. This is because supporting a JPEG stream requires the underlying YUV data to always be ready for use by a JPEG encoder, but the encoder will only be used (and impact frame duration) on requests that actually reference a JPEG stream.
The JPEG processor can run concurrently to the rest of the camera pipeline, but cannot process more than 1 capture at a time.
In other words, using a repeating YUV request would result in a steady frame rate (let's say it's 30 FPS). If a single JPEG request is submitted periodically, the frame rate will stay at 30 FPS (as long as we wait for the previous JPEG to return each time). If we try to submit a repeating YUV + JPEG request, then the frame rate will drop from 30 FPS.

In general, submitting a new request with a non-0 stall time stream will not cause a frame rate drop unless there are still outstanding buffers for that stream from previous requests.

Submitting a repeating request with streams (call this S) is the same as setting the minimum frame duration from the normal minimum frame duration corresponding to S, added with the maximum stall duration for S.

If interleaving requests with and without a stall duration, a request will stall by the maximum of the remaining times for each can-stall stream with outstanding buffers.

This means that a stalling request will not have an exposure start until the stall has completed.

This should correspond to the stall duration when only that stream is active, with all processing (typically in android.*.mode) set to FAST or OFF. Setting any of the processing modes to HIGH_QUALITY effectively results in an indeterminate stall duration for all streams in a request (the regular stall calculation rules are ignored).

The following formats may always have a stall duration:

AIMAGE_FORMAT_JPEG
AIMAGE_FORMAT_RAW16
The following formats will never have a stall duration:

AIMAGE_FORMAT_YUV_420_888
AIMAGE_FORMAT_RAW10
AIMAGE_FORMAT_RAW12
AIMAGE_FORMAT_Y8
All other formats may or may not have an allowed stall duration on a per-capability basis; refer to ACAMERA_REQUEST_AVAILABLE_CAPABILITIES for more details.

See ACAMERA_SENSOR_FRAME_DURATION for more information about calculating the max frame rate (absent stalls).

See also: ACAMERA_REQUEST_AVAILABLE_CAPABILITIES See also: ACAMERA_SENSOR_FRAME_DURATION

ACAMERA_SCALER_AVAILABLE_STALL_DURATIONS_MAXIMUM_RESOLUTION	
This lists the maximum stall duration for each output format/size combination when CaptureRequests are submitted with ACAMERA_SENSOR_PIXEL_MODE set to CameraMetadata::SENSOR_PIXEL_MODE_MAXIMUM_RESOLUTION

See also: ACAMERA_SENSOR_PIXEL_MODE

Type: int64[4*n]

This tag may appear in:

ACameraMetadata from ACameraManager_getCameraCharacteristics
Analogous to ACAMERA_SCALER_AVAILABLE_MIN_FRAME_DURATIONS, for configurations which are applicable when ACAMERA_SENSOR_PIXEL_MODE is set to CameraMetadata::SENSOR_PIXEL_MODE_MAXIMUM_RESOLUTION.

See also: ACAMERA_SCALER_AVAILABLE_MIN_FRAME_DURATIONS See also: ACAMERA_SENSOR_PIXEL_MODE

ACAMERA_SCALER_AVAILABLE_STREAM_CONFIGURATIONS	
The available stream configurations that this camera device supports (i.e. format, width, height, output/input stream).

Type: int32[n*4] (acamera_metadata_enum_android_scaler_available_stream_configurations_t)

This tag may appear in:

ACameraMetadata from ACameraManager_getCameraCharacteristics
The configurations are listed as (format, width, height, input?) tuples.

For a given use case, the actual maximum supported resolution may be lower than what is listed here, depending on the destination Surface for the image data. For example, for recording video, the video encoder chosen may have a maximum size limit (e.g. 1080p) smaller than what the camera (e.g. maximum resolution is 3264x2448) can provide.

Please reference the documentation for the image data destination to check if it limits the maximum size for image data.

Not all output formats may be supported in a configuration with an input stream of a particular format. For more details, see android.scaler.availableInputOutputFormatsMap.

For applications targeting SDK version older than 31, the following table describes the minimum required output stream configurations based on the hardware level (ACAMERA_INFO_SUPPORTED_HARDWARE_LEVEL):

Format | Size | Hardware Level | Notes :----------:|:-----------------------------------------:|:-----------:|:-----------: JPEG | ACAMERA_SENSOR_INFO_ACTIVE_ARRAY_SIZE | Any | JPEG | 1920x1080 (1080p) | Any | if 1080p <= activeArraySize JPEG | 1280x720 (720) | Any | if 720p <= activeArraySize JPEG | 640x480 (480p) | Any | if 480p <= activeArraySize JPEG | 320x240 (240p) | Any | if 240p <= activeArraySize YUV_420_888 | all output sizes available for JPEG | FULL | YUV_420_888 | all output sizes available for JPEG, up to the maximum video size | LIMITED | IMPLEMENTATION_DEFINED | same as YUV_420_888 | Any |

For applications targeting SDK version 31 or newer, if the mobile device declares to be media performance class 12 or higher by setting VERSION::MEDIA_PERFORMANCE_CLASS to be 31 or larger, the primary camera devices (first rear/front camera in the camera ID list) will not support JPEG sizes smaller than 1080p. If the application configures a JPEG stream smaller than 1080p, the camera device will round up the JPEG image size to at least 1080p. The requirements for IMPLEMENTATION_DEFINED and YUV_420_888 stay the same. This new minimum required output stream configurations are illustrated by the table below:

Format | Size | Hardware Level | Notes :----------:|:-----------------------------------------:|:-----------:|:-----------: JPEG | ACAMERA_SENSOR_INFO_ACTIVE_ARRAY_SIZE | Any | JPEG | 1920x1080 (1080p) | Any | if 1080p <= activeArraySize YUV_420_888 | ACAMERA_SENSOR_INFO_ACTIVE_ARRAY_SIZE | FULL | YUV_420_888 | 1920x1080 (1080p) | FULL | if 1080p <= activeArraySize YUV_420_888 | 1280x720 (720) | FULL | if 720p <= activeArraySize YUV_420_888 | 640x480 (480p) | FULL | if 480p <= activeArraySize YUV_420_888 | 320x240 (240p) | FULL | if 240p <= activeArraySize YUV_420_888 | all output sizes available for FULL hardware level, up to the maximum video size | LIMITED | IMPLEMENTATION_DEFINED | same as YUV_420_888 | Any |

For applications targeting SDK version 31 or newer, if the mobile device doesn't declare to be media performance class 12 or better by setting VERSION::MEDIA_PERFORMANCE_CLASS to be 31 or larger, or if the camera device isn't a primary rear/front camera, the minimum required output stream configurations are the same as for applications targeting SDK version older than 31.

Refer to ACAMERA_REQUEST_AVAILABLE_CAPABILITIES for additional mandatory stream configurations on a per-capability basis.

Exception on 176x144 (QCIF) resolution: camera devices usually have a fixed capability for downscaling from larger resolution to smaller, and the QCIF resolution sometimes is not fully supported due to this limitation on devices with high-resolution image sensors. Therefore, trying to configure a QCIF resolution stream together with any other stream larger than 1920x1080 resolution (either width or height) might not be supported, and capture session creation will fail if it is not.

See also: ACAMERA_INFO_SUPPORTED_HARDWARE_LEVEL See also: ACAMERA_REQUEST_AVAILABLE_CAPABILITIES See also: ACAMERA_SENSOR_INFO_ACTIVE_ARRAY_SIZE

ACAMERA_SCALER_AVAILABLE_STREAM_CONFIGURATIONS_MAXIMUM_RESOLUTION	
The available stream configurations that this camera device supports (i.e. format, width, height, output/input stream) for a CaptureRequest with ACAMERA_SENSOR_PIXEL_MODE set to CameraMetadata::SENSOR_PIXEL_MODE_MAXIMUM_RESOLUTION.

See also: ACAMERA_SENSOR_PIXEL_MODE

Type: int32[n*4] (acamera_metadata_enum_android_scaler_available_stream_configurations_maximum_resolution_t)

This tag may appear in:

ACameraMetadata from ACameraManager_getCameraCharacteristics
Analogous to ACAMERA_SCALER_AVAILABLE_STREAM_CONFIGURATIONS, for configurations which are applicable when ACAMERA_SENSOR_PIXEL_MODE is set to CameraMetadata::SENSOR_PIXEL_MODE_MAXIMUM_RESOLUTION.

Not all output formats may be supported in a configuration with an input stream of a particular format. For more details, see android.scaler.availableInputOutputFormatsMapMaximumResolution.

See also: ACAMERA_SCALER_AVAILABLE_STREAM_CONFIGURATIONS See also: ACAMERA_SENSOR_PIXEL_MODE

ACAMERA_SCALER_AVAILABLE_STREAM_USE_CASES	
The stream use cases supported by this camera device.

Type: int64[n] (acamera_metadata_enum_android_scaler_available_stream_use_cases_t)

This tag may appear in:

ACameraMetadata from ACameraManager_getCameraCharacteristics
The stream use case indicates the purpose of a particular camera stream from the end-user perspective. Some examples of camera use cases are: preview stream for live viewfinder shown to the user, still capture for generating high quality photo capture, video record for encoding the camera output for the purpose of future playback, and video call for live realtime video conferencing.

With this flag, the camera device can optimize the image processing pipeline parameters, such as tuning, sensor mode, and ISP settings, independent of the properties of the immediate camera output surface. For example, if the output surface is a SurfaceTexture, the stream use case flag can be used to indicate whether the camera frames eventually go to display, video encoder, still image capture, or all of them combined.

The application sets the use case of a camera stream by calling OutputConfiguration::setStreamUseCase.

A camera device with CameraCharacteristics::REQUEST_AVAILABLE_CAPABILITIES_STREAM_USE_CASE capability must support the following stream use cases:

DEFAULT
PREVIEW
STILL_CAPTURE
VIDEO_RECORD
PREVIEW_VIDEO_STILL
VIDEO_CALL
The guaranteed stream combinations related to stream use case for a camera device with CameraCharacteristics::REQUEST_AVAILABLE_CAPABILITIES_STREAM_USE_CASE capability is documented in the camera device guideline. The application is strongly recommended to use one of the guaranteed stream combinations. If the application creates a session with a stream combination not in the guaranteed list, or with mixed DEFAULT and non-DEFAULT use cases within the same session, the camera device may ignore some stream use cases due to hardware constraints and implementation details.

For stream combinations not covered by the stream use case mandatory lists, such as reprocessable session, constrained high speed session, or RAW stream combinations, the application should leave stream use cases within the session as DEFAULT.

ACAMERA_SCALER_CROPPING_TYPE	
The crop type that this camera device supports.

Type: byte (acamera_metadata_enum_android_scaler_cropping_type_t)

This tag may appear in:

ACameraMetadata from ACameraManager_getCameraCharacteristics
When passing a non-centered crop region (ACAMERA_SCALER_CROP_REGION) to a camera device that only supports CENTER_ONLY cropping, the camera device will move the crop region to the center of the sensor active array (ACAMERA_SENSOR_INFO_ACTIVE_ARRAY_SIZE) and keep the crop region width and height unchanged. The camera device will return the final used crop region in metadata result ACAMERA_SCALER_CROP_REGION.

Camera devices that support FREEFORM cropping will support any crop region that is inside of the active array. The camera device will apply the same crop region and return the final used crop region in capture result metadata ACAMERA_SCALER_CROP_REGION.

Starting from API level 30,

If the camera device supports FREEFORM cropping, in order to do FREEFORM cropping, the application must set ACAMERA_CONTROL_ZOOM_RATIO to 1.0, and use ACAMERA_SCALER_CROP_REGION for zoom.
To do CENTER_ONLY zoom, the application has below 2 options:
Set ACAMERA_CONTROL_ZOOM_RATIO to 1.0; adjust zoom by ACAMERA_SCALER_CROP_REGION.
Adjust zoom by ACAMERA_CONTROL_ZOOM_RATIO; use ACAMERA_SCALER_CROP_REGION to crop the field of view vertically (letterboxing) or horizontally (pillarboxing), but not windowboxing.
Setting ACAMERA_CONTROL_ZOOM_RATIO to values different than 1.0 and ACAMERA_SCALER_CROP_REGION to be windowboxing at the same time are not supported. In this case, the camera framework will override the ACAMERA_SCALER_CROP_REGION to be the active array.
LEGACY capability devices will only support CENTER_ONLY cropping.

See also: ACAMERA_CONTROL_ZOOM_RATIO See also: ACAMERA_SCALER_CROP_REGION See also: ACAMERA_SENSOR_INFO_ACTIVE_ARRAY_SIZE

ACAMERA_SCALER_CROP_REGION	
The desired region of the sensor to read out for this capture.

Type: int32[4]

This tag may appear in:

ACameraMetadata from ACameraCaptureSession_captureCallback_result callbacks
ACaptureRequest
This control can be used to implement digital zoom.

For devices not supporting ACAMERA_DISTORTION_CORRECTION_MODE control, the coordinate system always follows that of ACAMERA_SENSOR_INFO_ACTIVE_ARRAY_SIZE, with (0, 0) being the top-left pixel of the active array.

For devices supporting ACAMERA_DISTORTION_CORRECTION_MODE control, the coordinate system depends on the mode being set. When the distortion correction mode is OFF, the coordinate system follows ACAMERA_SENSOR_INFO_PRE_CORRECTION_ACTIVE_ARRAY_SIZE, with (0, 0) being the top-left pixel of the pre-correction active array. When the distortion correction mode is not OFF, the coordinate system follows ACAMERA_SENSOR_INFO_ACTIVE_ARRAY_SIZE, with (0, 0) being the top-left pixel of the active array.

Output streams use this rectangle to produce their output, cropping to a smaller region if necessary to maintain the stream's aspect ratio, then scaling the sensor input to match the output's configured resolution.

The crop region is applied after the RAW to other color space (e.g. YUV) conversion. Since raw streams (e.g. RAW16) don't have the conversion stage, they are not croppable. The crop region will be ignored by raw streams.

For non-raw streams, any additional per-stream cropping will be done to maximize the final pixel area of the stream.

For example, if the crop region is set to a 4:3 aspect ratio, then 4:3 streams will use the exact crop region. 16:9 streams will further crop vertically (letterbox).

Conversely, if the crop region is set to a 16:9, then 4:3 outputs will crop horizontally (pillarbox), and 16:9 streams will match exactly. These additional crops will be centered within the crop region.

To illustrate, here are several scenarios of different crop regions and output streams, for a hypothetical camera device with an active array of size (2000,1500). Note that several of these examples use non-centered crop regions for ease of illustration; such regions are only supported on devices with FREEFORM capability (ACAMERA_SCALER_CROPPING_TYPE == FREEFORM), but this does not affect the way the crop rules work otherwise.

Camera Configuration:
Active array size: 2000x1500 (3 MP, 4:3 aspect ratio)
Output stream #1: 640x480 (VGA, 4:3 aspect ratio)
Output stream #2: 1280x720 (720p, 16:9 aspect ratio)
Case #1: 4:3 crop region with 2x digital zoom
Crop region: Rect(500, 375, 1500, 1125) // (left, top, right, bottom)

640x480 stream source area: (500, 375, 1500, 1125) (equal to crop region)
1280x720 stream source area: (500, 469, 1500, 1031) (letterboxed)
Case #2: 16:9 crop region with ~1.5x digital zoom.
Crop region: Rect(500, 375, 1833, 1125)

640x480 stream source area: (666, 375, 1666, 1125) (pillarboxed)
1280x720 stream source area: (500, 375, 1833, 1125) (equal to crop region)
Case #3: 1:1 crop region with ~2.6x digital zoom.
Crop region: Rect(500, 375, 1250, 1125)

640x480 stream source area: (500, 469, 1250, 1031) (letterboxed)
1280x720 stream source area: (500, 543, 1250, 957) (letterboxed)
Case #4: Replace 640x480 stream with 1024x1024 stream, with 4:3 crop region:
Crop region: Rect(500, 375, 1500, 1125)

1024x1024 stream source area: (625, 375, 1375, 1125) (pillarboxed)
1280x720 stream source area: (500, 469, 1500, 1031) (letterboxed)
Note that in this case, neither of the two outputs is a subset of the other, with each containing image data the other doesn't have.
If the coordinate system is ACAMERA_SENSOR_INFO_ACTIVE_ARRAY_SIZE, the width and height of the crop region cannot be set to be smaller than floor( activeArraySize.width / ACAMERA_SCALER_AVAILABLE_MAX_DIGITAL_ZOOM ) and floor( activeArraySize.height / ACAMERA_SCALER_AVAILABLE_MAX_DIGITAL_ZOOM ), respectively.

If the coordinate system is ACAMERA_SENSOR_INFO_PRE_CORRECTION_ACTIVE_ARRAY_SIZE, the width and height of the crop region cannot be set to be smaller than floor( preCorrectionActiveArraySize.width / ACAMERA_SCALER_AVAILABLE_MAX_DIGITAL_ZOOM ) and floor( preCorrectionActiveArraySize.height / ACAMERA_SCALER_AVAILABLE_MAX_DIGITAL_ZOOM ), respectively.

The camera device may adjust the crop region to account for rounding and other hardware requirements; the final crop region used will be included in the output capture result.

The camera sensor output aspect ratio depends on factors such as output stream combination and ACAMERA_CONTROL_AE_TARGET_FPS_RANGE, and shouldn't be adjusted by using this control. And the camera device will treat different camera sensor output sizes (potentially with in-sensor crop) as the same crop of ACAMERA_SENSOR_INFO_ACTIVE_ARRAY_SIZE. As a result, the application shouldn't assume the maximum crop region always maps to the same aspect ratio or field of view for the sensor output.

Starting from API level 30, it's strongly recommended to use ACAMERA_CONTROL_ZOOM_RATIO to take advantage of better support for zoom with logical multi-camera. The benefits include better precision with optical-digital zoom combination, and ability to do zoom-out from 1.0x. When using ACAMERA_CONTROL_ZOOM_RATIO for zoom, the crop region in the capture request should be left as the default activeArray size. The coordinate system is post-zoom, meaning that the activeArraySize or preCorrectionActiveArraySize covers the camera device's field of view "after" zoom. See ACAMERA_CONTROL_ZOOM_RATIO for details.

For camera devices with the CameraMetadata::REQUEST_AVAILABLE_CAPABILITIES_ULTRA_HIGH_RESOLUTION_SENSOR capability, ACAMERA_SENSOR_INFO_ACTIVE_ARRAY_SIZE_MAXIMUM_RESOLUTION / ACAMERA_SENSOR_INFO_PRE_CORRECTION_ACTIVE_ARRAY_SIZE_MAXIMUM_RESOLUTION must be used as the coordinate system for requests where ACAMERA_SENSOR_PIXEL_MODE is set to CameraMetadata::SENSOR_PIXEL_MODE_MAXIMUM_RESOLUTION.

The data representation is int[4], which maps to (left, top, width, height).

See also: ACAMERA_CONTROL_AE_TARGET_FPS_RANGE See also: ACAMERA_CONTROL_ZOOM_RATIO See also: ACAMERA_DISTORTION_CORRECTION_MODE See also: ACAMERA_SCALER_AVAILABLE_MAX_DIGITAL_ZOOM See also: ACAMERA_SCALER_CROPPING_TYPE See also: ACAMERA_SENSOR_INFO_ACTIVE_ARRAY_SIZE See also: ACAMERA_SENSOR_INFO_ACTIVE_ARRAY_SIZE_MAXIMUM_RESOLUTION See also: ACAMERA_SENSOR_INFO_PRE_CORRECTION_ACTIVE_ARRAY_SIZE See also: ACAMERA_SENSOR_INFO_PRE_CORRECTION_ACTIVE_ARRAY_SIZE_MAXIMUM_RESOLUTION See also: ACAMERA_SENSOR_PIXEL_MODE

ACAMERA_SCALER_DEFAULT_SECURE_IMAGE_SIZE	
Default YUV/PRIVATE size to use for requesting secure image buffers.

Type: int32[2]

This tag may appear in:

ACameraMetadata from ACameraManager_getCameraCharacteristics
This entry lists the default size supported in the secure camera mode. This entry is optional on devices support the SECURE_IMAGE_DATA capability. This entry will be null if the camera device does not list SECURE_IMAGE_DATA capability.

When the key is present, only a PRIVATE/YUV output of the specified size is guaranteed to be supported by the camera HAL in the secure camera mode. Any other format or resolutions might not be supported. Use ACameraDevice_isSessionConfigurationSupported API to query if a secure session configuration is supported if the device supports this API.

If this key returns null on a device with SECURE_IMAGE_DATA capability, the application can assume all output sizes listed in the ACAMERA_SCALER_AVAILABLE_MIN_FRAME_DURATIONS are supported.

ACAMERA_SCALER_END	
ACAMERA_SCALER_MULTI_RESOLUTION_STREAM_SUPPORTED	
Whether the camera device supports multi-resolution input or output streams

Type: byte (acamera_metadata_enum_android_scaler_multi_resolution_stream_supported_t)

This tag may appear in:

ACameraMetadata from ACameraManager_getCameraCharacteristics
A logical multi-camera or an ultra high resolution camera may support multi-resolution input or output streams. With multi-resolution output streams, the camera device is able to output different resolution images depending on the current active physical camera or pixel mode. With multi-resolution input streams, the camera device can reprocess images of different resolutions from different physical cameras or sensor pixel modes.

When set to TRUE:

For a logical multi-camera, the camera framework derives android.scaler.multiResolutionStreamConfigurationMap by combining the ACAMERA_SCALER_PHYSICAL_CAMERA_MULTI_RESOLUTION_STREAM_CONFIGURATIONS from its physical cameras.
For an ultra-high resolution sensor camera, the camera framework directly copies the value of ACAMERA_SCALER_PHYSICAL_CAMERA_MULTI_RESOLUTION_STREAM_CONFIGURATIONS to android.scaler.multiResolutionStreamConfigurationMap.
See also: ACAMERA_SCALER_PHYSICAL_CAMERA_MULTI_RESOLUTION_STREAM_CONFIGURATIONS

ACAMERA_SCALER_PHYSICAL_CAMERA_MULTI_RESOLUTION_STREAM_CONFIGURATIONS	
The available multi-resolution stream configurations that this physical camera device supports (i.e. format, width, height, output/input stream).

Type: int32[n*4] (acamera_metadata_enum_android_scaler_physical_camera_multi_resolution_stream_configurations_t)

This tag may appear in:

ACameraMetadata from ACameraManager_getCameraCharacteristics
This list contains a subset of the parent logical camera's multi-resolution stream configurations which belong to this physical camera, and it will advertise and will only advertise the maximum supported resolutions for a particular format.

If this camera device isn't a physical camera device constituting a logical camera, but a standalone CameraMetadata::REQUEST_AVAILABLE_CAPABILITIES_ULTRA_HIGH_RESOLUTION_SENSOR camera, this field represents the multi-resolution input/output stream configurations of default mode and max resolution modes. The sizes will be the maximum resolution of a particular format for default mode and max resolution mode.

This field will only be advertised if the device is a physical camera of a logical multi-camera device or an ultra high resolution sensor camera. For a logical multi-camera, the camera API will derive the logical camera’s multi-resolution stream configurations from all physical cameras. For an ultra high resolution sensor camera, this is used directly as the camera’s multi-resolution stream configurations.

ACAMERA_SCALER_ROTATE_AND_CROP	
Whether a rotation-and-crop operation is applied to processed outputs from the camera.

Type: byte (acamera_metadata_enum_android_scaler_rotate_and_crop_t)

This tag may appear in:

ACameraMetadata from ACameraCaptureSession_captureCallback_result callbacks
ACaptureRequest
This control is primarily intended to help camera applications with no support for multi-window modes to work correctly on devices where multi-window scenarios are unavoidable, such as foldables or other devices with variable display geometry or more free-form window placement (such as laptops, which often place portrait-orientation apps in landscape with pillarboxing).

If supported, the default value is ROTATE_AND_CROP_AUTO, which allows the camera API to enable backwards-compatibility support for applications that do not support resizing / multi-window modes, when the device is in fact in a multi-window mode (such as inset portrait on laptops, or on a foldable device in some fold states). In addition, ROTATE_AND_CROP_NONE and ROTATE_AND_CROP_90 will always be available if this control is supported by the device. If not supported, devices API level 30 or higher will always list only ROTATE_AND_CROP_NONE.

When CROP_AUTO is in use, and the camera API activates backward-compatibility mode, several metadata fields will also be parsed differently to ensure that coordinates are correctly handled for features like drawing face detection boxes or passing in tap-to-focus coordinates. The camera API will convert positions in the active array coordinate system to/from the cropped-and-rotated coordinate system to make the operation transparent for applications. The following controls are affected:

ACAMERA_CONTROL_AE_REGIONS
ACAMERA_CONTROL_AF_REGIONS
ACAMERA_CONTROL_AWB_REGIONS
android.statistics.faces
Capture results will contain the actual value selected by the API; ROTATE_AND_CROP_AUTO will never be seen in a capture result.

Applications can also select their preferred cropping mode, either to opt out of the backwards-compatibility treatment, or to use the cropping feature themselves as needed. In this case, no coordinate translation will be done automatically, and all controls will continue to use the normal active array coordinates.

Cropping and rotating is done after the application of digital zoom (via either ACAMERA_SCALER_CROP_REGION or ACAMERA_CONTROL_ZOOM_RATIO), but before each individual output is further cropped and scaled. It only affects processed outputs such as YUV, PRIVATE, and JPEG. It has no effect on RAW outputs.

When CROP_90 or CROP_270 are selected, there is a significant loss to the field of view. For example, with a 4:3 aspect ratio output of 1600x1200, CROP_90 will still produce 1600x1200 output, but these buffers are cropped from a vertical 3:4 slice at the center of the 4:3 area, then rotated to be 4:3, and then upscaled to 1600x1200. Only 56.25% of the original FOV is still visible. In general, for an aspect ratio of w:h, the crop and rotate operation leaves (h/w)^2 of the field of view visible. For 16:9, this is ~31.6%.

As a visual example, the figure below shows the effect of ROTATE_AND_CROP_90 on the outputs for the following parameters:

Sensor active array: 2000x1500
Crop region: top-left: (500, 375), size: (1000, 750) (4:3 aspect ratio)
Output streams: YUV 640x480 and YUV 1280x720
ROTATE_AND_CROP_90

With these settings, the regions of the active array covered by the output streams are:

640x480 stream crop: top-left: (219, 375), size: (562, 750)
1280x720 stream crop: top-left: (289, 375), size: (422, 750)
Since the buffers are rotated, the buffers as seen by the application are:

640x480 stream: top-left: (781, 375) on active array, size: (640, 480), downscaled 1.17x from sensor pixels
1280x720 stream: top-left: (711, 375) on active array, size: (1280, 720), upscaled 1.71x from sensor pixels
See also: ACAMERA_CONTROL_AE_REGIONS See also: ACAMERA_CONTROL_AF_REGIONS See also: ACAMERA_CONTROL_AWB_REGIONS See also: ACAMERA_CONTROL_ZOOM_RATIO See also: ACAMERA_SCALER_CROP_REGION

ACAMERA_SENSOR_AVAILABLE_TEST_PATTERN_MODES	
List of sensor test pattern modes for ACAMERA_SENSOR_TEST_PATTERN_MODE supported by this camera device.

See also: ACAMERA_SENSOR_TEST_PATTERN_MODE

Type: int32[n]

This tag may appear in:

ACameraMetadata from ACameraManager_getCameraCharacteristics
Defaults to OFF, and always includes OFF if defined.

ACAMERA_SENSOR_BLACK_LEVEL_PATTERN	
A fixed black level offset for each of the color filter arrangement (CFA) mosaic channels.

Type: int32[4]

This tag may appear in:

ACameraMetadata from ACameraManager_getCameraCharacteristics
This key specifies the zero light value for each of the CFA mosaic channels in the camera sensor. The maximal value output by the sensor is represented by the value in ACAMERA_SENSOR_INFO_WHITE_LEVEL.

The values are given in the same order as channels listed for the CFA layout key (see ACAMERA_SENSOR_INFO_COLOR_FILTER_ARRANGEMENT), i.e. the nth value given corresponds to the black level offset for the nth color channel listed in the CFA.

The black level values of captured images may vary for different capture settings (e.g., ACAMERA_SENSOR_SENSITIVITY). This key represents a coarse approximation for such case. It is recommended to use ACAMERA_SENSOR_DYNAMIC_BLACK_LEVEL or use pixels from ACAMERA_SENSOR_OPTICAL_BLACK_REGIONS directly for captures when supported by the camera device, which provides more accurate black level values. For raw capture in particular, it is recommended to use pixels from ACAMERA_SENSOR_OPTICAL_BLACK_REGIONS to calculate black level values for each frame.

For a MONOCHROME camera device, all of the 2x2 channels must have the same values.

See also: ACAMERA_SENSOR_DYNAMIC_BLACK_LEVEL See also: ACAMERA_SENSOR_INFO_COLOR_FILTER_ARRANGEMENT See also: ACAMERA_SENSOR_INFO_WHITE_LEVEL See also: ACAMERA_SENSOR_OPTICAL_BLACK_REGIONS See also: ACAMERA_SENSOR_SENSITIVITY

ACAMERA_SENSOR_CALIBRATION_TRANSFORM1	
A per-device calibration transform matrix that maps from the reference sensor colorspace to the actual device sensor colorspace.

Type: rational[3*3]

This tag may appear in:

ACameraMetadata from ACameraManager_getCameraCharacteristics
This matrix is used to correct for per-device variations in the sensor colorspace, and is used for processing raw buffer data.

The matrix is expressed as a 3x3 matrix in row-major-order, and contains a per-device calibration transform that maps colors from reference sensor color space (i.e. the "golden module" colorspace) into this camera device's native sensor color space under the first reference illuminant (ACAMERA_SENSOR_REFERENCE_ILLUMINANT1).

Starting from Android Q, this key will not be present for a MONOCHROME camera, even if the camera device has RAW capability.

See also: ACAMERA_SENSOR_REFERENCE_ILLUMINANT1

ACAMERA_SENSOR_CALIBRATION_TRANSFORM2	
A per-device calibration transform matrix that maps from the reference sensor colorspace to the actual device sensor colorspace (this is the colorspace of the raw buffer data).

Type: rational[3*3]

This tag may appear in:

ACameraMetadata from ACameraManager_getCameraCharacteristics
This matrix is used to correct for per-device variations in the sensor colorspace, and is used for processing raw buffer data.

The matrix is expressed as a 3x3 matrix in row-major-order, and contains a per-device calibration transform that maps colors from reference sensor color space (i.e. the "golden module" colorspace) into this camera device's native sensor color space under the second reference illuminant (ACAMERA_SENSOR_REFERENCE_ILLUMINANT2).

This matrix will only be present if the second reference illuminant is present.

Starting from Android Q, this key will not be present for a MONOCHROME camera, even if the camera device has RAW capability.

See also: ACAMERA_SENSOR_REFERENCE_ILLUMINANT2

ACAMERA_SENSOR_COLOR_TRANSFORM1	
A matrix that transforms color values from CIE XYZ color space to reference sensor color space.

Type: rational[3*3]

This tag may appear in:

ACameraMetadata from ACameraManager_getCameraCharacteristics
This matrix is used to convert from the standard CIE XYZ color space to the reference sensor colorspace, and is used when processing raw buffer data.

The matrix is expressed as a 3x3 matrix in row-major-order, and contains a color transform matrix that maps colors from the CIE XYZ color space to the reference sensor color space (i.e. the "golden module" colorspace) under the first reference illuminant (ACAMERA_SENSOR_REFERENCE_ILLUMINANT1).

The white points chosen in both the reference sensor color space and the CIE XYZ colorspace when calculating this transform will match the standard white point for the first reference illuminant (i.e. no chromatic adaptation will be applied by this transform).

Starting from Android Q, this key will not be present for a MONOCHROME camera, even if the camera device has RAW capability.

See also: ACAMERA_SENSOR_REFERENCE_ILLUMINANT1

ACAMERA_SENSOR_COLOR_TRANSFORM2	
A matrix that transforms color values from CIE XYZ color space to reference sensor color space.

Type: rational[3*3]

This tag may appear in:

ACameraMetadata from ACameraManager_getCameraCharacteristics
This matrix is used to convert from the standard CIE XYZ color space to the reference sensor colorspace, and is used when processing raw buffer data.

The matrix is expressed as a 3x3 matrix in row-major-order, and contains a color transform matrix that maps colors from the CIE XYZ color space to the reference sensor color space (i.e. the "golden module" colorspace) under the second reference illuminant (ACAMERA_SENSOR_REFERENCE_ILLUMINANT2).

The white points chosen in both the reference sensor color space and the CIE XYZ colorspace when calculating this transform will match the standard white point for the second reference illuminant (i.e. no chromatic adaptation will be applied by this transform).

This matrix will only be present if the second reference illuminant is present.

Starting from Android Q, this key will not be present for a MONOCHROME camera, even if the camera device has RAW capability.

See also: ACAMERA_SENSOR_REFERENCE_ILLUMINANT2

ACAMERA_SENSOR_DYNAMIC_BLACK_LEVEL	
A per-frame dynamic black level offset for each of the color filter arrangement (CFA) mosaic channels.

Type: float[4]

This tag may appear in:

ACameraMetadata from ACameraCaptureSession_captureCallback_result callbacks
Camera sensor black levels may vary dramatically for different capture settings (e.g. ACAMERA_SENSOR_SENSITIVITY). The fixed black level reported by ACAMERA_SENSOR_BLACK_LEVEL_PATTERN may be too inaccurate to represent the actual value on a per-frame basis. The camera device internal pipeline relies on reliable black level values to process the raw images appropriately. To get the best image quality, the camera device may choose to estimate the per frame black level values either based on optically shielded black regions (ACAMERA_SENSOR_OPTICAL_BLACK_REGIONS) or its internal model.

This key reports the camera device estimated per-frame zero light value for each of the CFA mosaic channels in the camera sensor. The ACAMERA_SENSOR_BLACK_LEVEL_PATTERN may only represent a coarse approximation of the actual black level values. This value is the black level used in camera device internal image processing pipeline and generally more accurate than the fixed black level values. However, since they are estimated values by the camera device, they may not be as accurate as the black level values calculated from the optical black pixels reported by ACAMERA_SENSOR_OPTICAL_BLACK_REGIONS.

The values are given in the same order as channels listed for the CFA layout key (see ACAMERA_SENSOR_INFO_COLOR_FILTER_ARRANGEMENT), i.e. the nth value given corresponds to the black level offset for the nth color channel listed in the CFA.

For a MONOCHROME camera, all of the 2x2 channels must have the same values.

This key will be available if ACAMERA_SENSOR_OPTICAL_BLACK_REGIONS is available or the camera device advertises this key via ACAMERA_REQUEST_AVAILABLE_RESULT_KEYS.

See also: ACAMERA_SENSOR_BLACK_LEVEL_PATTERN See also: ACAMERA_SENSOR_INFO_COLOR_FILTER_ARRANGEMENT See also: ACAMERA_SENSOR_OPTICAL_BLACK_REGIONS See also: ACAMERA_SENSOR_SENSITIVITY

ACAMERA_SENSOR_DYNAMIC_WHITE_LEVEL	
Maximum raw value output by sensor for this frame.

Type: int32

This tag may appear in:

ACameraMetadata from ACameraCaptureSession_captureCallback_result callbacks
Since the ACAMERA_SENSOR_BLACK_LEVEL_PATTERN may change for different capture settings (e.g., ACAMERA_SENSOR_SENSITIVITY), the white level will change accordingly. This key is similar to ACAMERA_SENSOR_INFO_WHITE_LEVEL, but specifies the camera device estimated white level for each frame.

This key will be available if ACAMERA_SENSOR_OPTICAL_BLACK_REGIONS is available or the camera device advertises this key via ACAMERA_REQUEST_AVAILABLE_RESULT_KEYS.

See also: ACAMERA_SENSOR_BLACK_LEVEL_PATTERN See also: ACAMERA_SENSOR_INFO_WHITE_LEVEL See also: ACAMERA_SENSOR_OPTICAL_BLACK_REGIONS See also: ACAMERA_SENSOR_SENSITIVITY

ACAMERA_SENSOR_END	
ACAMERA_SENSOR_EXPOSURE_TIME	
Duration each pixel is exposed to light.

Type: int64

This tag may appear in:

ACameraMetadata from ACameraCaptureSession_captureCallback_result callbacks
ACaptureRequest
If the sensor can't expose this exact duration, it will shorten the duration exposed to the nearest possible value (rather than expose longer). The final exposure time used will be available in the output capture result.

This control is only effective if ACAMERA_CONTROL_AE_MODE or ACAMERA_CONTROL_MODE is set to OFF; otherwise the auto-exposure algorithm will override this value.

See also: ACAMERA_CONTROL_AE_MODE See also: ACAMERA_CONTROL_MODE

ACAMERA_SENSOR_FORWARD_MATRIX1	
A matrix that transforms white balanced camera colors from the reference sensor colorspace to the CIE XYZ colorspace with a D50 whitepoint.

Type: rational[3*3]

This tag may appear in:

ACameraMetadata from ACameraManager_getCameraCharacteristics
This matrix is used to convert to the standard CIE XYZ colorspace, and is used when processing raw buffer data.

This matrix is expressed as a 3x3 matrix in row-major-order, and contains a color transform matrix that maps white balanced colors from the reference sensor color space to the CIE XYZ color space with a D50 white point.

Under the first reference illuminant (ACAMERA_SENSOR_REFERENCE_ILLUMINANT1) this matrix is chosen so that the standard white point for this reference illuminant in the reference sensor colorspace is mapped to D50 in the CIE XYZ colorspace.

Starting from Android Q, this key will not be present for a MONOCHROME camera, even if the camera device has RAW capability.

See also: ACAMERA_SENSOR_REFERENCE_ILLUMINANT1

ACAMERA_SENSOR_FORWARD_MATRIX2	
A matrix that transforms white balanced camera colors from the reference sensor colorspace to the CIE XYZ colorspace with a D50 whitepoint.

Type: rational[3*3]

This tag may appear in:

ACameraMetadata from ACameraManager_getCameraCharacteristics
This matrix is used to convert to the standard CIE XYZ colorspace, and is used when processing raw buffer data.

This matrix is expressed as a 3x3 matrix in row-major-order, and contains a color transform matrix that maps white balanced colors from the reference sensor color space to the CIE XYZ color space with a D50 white point.

Under the second reference illuminant (ACAMERA_SENSOR_REFERENCE_ILLUMINANT2) this matrix is chosen so that the standard white point for this reference illuminant in the reference sensor colorspace is mapped to D50 in the CIE XYZ colorspace.

This matrix will only be present if the second reference illuminant is present.

Starting from Android Q, this key will not be present for a MONOCHROME camera, even if the camera device has RAW capability.

See also: ACAMERA_SENSOR_REFERENCE_ILLUMINANT2

ACAMERA_SENSOR_FRAME_DURATION	
Duration from start of frame exposure to start of next frame exposure.

Type: int64

This tag may appear in:

ACameraMetadata from ACameraCaptureSession_captureCallback_result callbacks
ACaptureRequest
The maximum frame rate that can be supported by a camera subsystem is a function of many factors:

Requested resolutions of output image streams
Availability of binning / skipping modes on the imager
The bandwidth of the imager interface
The bandwidth of the various ISP processing blocks
Since these factors can vary greatly between different ISPs and sensors, the camera abstraction tries to represent the bandwidth restrictions with as simple a model as possible.

The model presented has the following characteristics:

The image sensor is always configured to output the smallest resolution possible given the application's requested output stream sizes. The smallest resolution is defined as being at least as large as the largest requested output stream size; the camera pipeline must never digitally upsample sensor data when the crop region covers the whole sensor. In general, this means that if only small output stream resolutions are configured, the sensor can provide a higher frame rate.
Since any request may use any or all the currently configured output streams, the sensor and ISP must be configured to support scaling a single capture to all the streams at the same time. This means the camera pipeline must be ready to produce the largest requested output size without any delay. Therefore, the overall frame rate of a given configured stream set is governed only by the largest requested stream resolution.
Using more than one output stream in a request does not affect the frame duration.
Certain format-streams may need to do additional background processing before data is consumed/produced by that stream. These processors can run concurrently to the rest of the camera pipeline, but cannot process more than 1 capture at a time.
The necessary information for the application, given the model above, is provided via ACAMERA_SCALER_AVAILABLE_MIN_FRAME_DURATIONS. These are used to determine the maximum frame rate / minimum frame duration that is possible for a given stream configuration.

Specifically, the application can use the following rules to determine the minimum frame duration it can request from the camera device:

Let the set of currently configured input/output streams be called S.
Find the minimum frame durations for each stream in S, by looking it up in ACAMERA_SCALER_AVAILABLE_MIN_FRAME_DURATIONS (with its respective size/format). Let this set of frame durations be called F.
For any given request R, the minimum frame duration allowed for R is the maximum out of all values in F. Let the streams used in R be called S_r.
If none of the streams in S_r have a stall time (listed in ACAMERA_SCALER_AVAILABLE_STALL_DURATIONS using its respective size/format), then the frame duration in F determines the steady state frame rate that the application will get if it uses R as a repeating request. Let this special kind of request be called Rsimple.

A repeating request Rsimple can be occasionally interleaved by a single capture of a new request Rstall (which has at least one in-use stream with a non-0 stall time) and if Rstall has the same minimum frame duration this will not cause a frame rate loss if all buffers from the previous Rstall have already been delivered.

For more details about stalling, see ACAMERA_SCALER_AVAILABLE_STALL_DURATIONS.

This control is only effective if ACAMERA_CONTROL_AE_MODE or ACAMERA_CONTROL_MODE is set to OFF; otherwise the auto-exposure algorithm will override this value.

See also: ACAMERA_CONTROL_AE_MODE See also: ACAMERA_CONTROL_MODE

ACAMERA_SENSOR_GREEN_SPLIT	
The worst-case divergence between Bayer green channels.

Type: float

This tag may appear in:

ACameraMetadata from ACameraCaptureSession_captureCallback_result callbacks
This value is an estimate of the worst case split between the Bayer green channels in the red and blue rows in the sensor color filter array.

The green split is calculated as follows:

A 5x5 pixel (or larger) window W within the active sensor array is chosen. The term 'pixel' here is taken to mean a group of 4 Bayer mosaic channels (R, Gr, Gb, B). The location and size of the window chosen is implementation defined, and should be chosen to provide a green split estimate that is both representative of the entire image for this camera sensor, and can be calculated quickly.
The arithmetic mean of the green channels from the red rows (mean_Gr) within W is computed.
The arithmetic mean of the green channels from the blue rows (mean_Gb) within W is computed.
The maximum ratio R of the two means is computed as follows: R = max((mean_Gr + 1)/(mean_Gb + 1), (mean_Gb + 1)/(mean_Gr + 1))
The ratio R is the green split divergence reported for this property, which represents how much the green channels differ in the mosaic pattern. This value is typically used to determine the treatment of the green mosaic channels when demosaicing.

The green split value can be roughly interpreted as follows:

R < 1.03 is a negligible split (<3% divergence).
1.20 <= R >= 1.03 will require some software correction to avoid demosaic errors (3-20% divergence).
R > 1.20 will require strong software correction to produce a usable image (>20% divergence).
Starting from Android Q, this key will not be present for a MONOCHROME camera, even if the camera device has RAW capability.

ACAMERA_SENSOR_INFO_ACTIVE_ARRAY_SIZE	
The area of the image sensor which corresponds to active pixels after any geometric distortion correction has been applied.

Type: int32[4]

This tag may appear in:

ACameraMetadata from ACameraManager_getCameraCharacteristics
This is the rectangle representing the size of the active region of the sensor (i.e. the region that actually receives light from the scene) after any geometric correction has been applied, and should be treated as the maximum size in pixels of any of the image output formats aside from the raw formats.

This rectangle is defined relative to the full pixel array; (0,0) is the top-left of the full pixel array, and the size of the full pixel array is given by ACAMERA_SENSOR_INFO_PIXEL_ARRAY_SIZE.

The coordinate system for most other keys that list pixel coordinates, including ACAMERA_SCALER_CROP_REGION, is defined relative to the active array rectangle given in this field, with (0, 0) being the top-left of this rectangle.

The active array may be smaller than the full pixel array, since the full array may include black calibration pixels or other inactive regions.

For devices that do not support ACAMERA_DISTORTION_CORRECTION_MODE control, the active array must be the same as ACAMERA_SENSOR_INFO_PRE_CORRECTION_ACTIVE_ARRAY_SIZE.

For devices that support ACAMERA_DISTORTION_CORRECTION_MODE control, the active array must be enclosed by ACAMERA_SENSOR_INFO_PRE_CORRECTION_ACTIVE_ARRAY_SIZE. The difference between pre-correction active array and active array accounts for scaling or cropping caused by lens geometric distortion correction.

In general, application should always refer to active array size for controls like metering regions or crop region. Two exceptions are when the application is dealing with RAW image buffers (RAW_SENSOR, RAW10, RAW12 etc), or when application explicitly set ACAMERA_DISTORTION_CORRECTION_MODE to OFF. In these cases, application should refer to ACAMERA_SENSOR_INFO_PRE_CORRECTION_ACTIVE_ARRAY_SIZE.

The data representation is int[4], which maps to (left, top, width, height).

See also: ACAMERA_DISTORTION_CORRECTION_MODE See also: ACAMERA_SCALER_CROP_REGION See also: ACAMERA_SENSOR_INFO_PIXEL_ARRAY_SIZE See also: ACAMERA_SENSOR_INFO_PRE_CORRECTION_ACTIVE_ARRAY_SIZE

ACAMERA_SENSOR_INFO_ACTIVE_ARRAY_SIZE_MAXIMUM_RESOLUTION	
The area of the image sensor which corresponds to active pixels after any geometric distortion correction has been applied, when the sensor runs in maximum resolution mode.

Type: int32[4]

This tag may appear in:

ACameraMetadata from ACameraManager_getCameraCharacteristics
Analogous to ACAMERA_SENSOR_INFO_ACTIVE_ARRAY_SIZE, when ACAMERA_SENSOR_PIXEL_MODE is set to CameraMetadata::SENSOR_PIXEL_MODE_MAXIMUM_RESOLUTION. Refer to ACAMERA_SENSOR_INFO_ACTIVE_ARRAY_SIZE for details, with sensor array related keys replaced with their CameraMetadata::SENSOR_PIXEL_MODE_MAXIMUM_RESOLUTION counterparts. This key will only be present for devices which advertise the CameraMetadata::REQUEST_AVAILABLE_CAPABILITIES_ULTRA_HIGH_RESOLUTION_SENSOR capability.

The data representation is int[4], which maps to (left, top, width, height).

See also: ACAMERA_SENSOR_INFO_ACTIVE_ARRAY_SIZE See also: ACAMERA_SENSOR_PIXEL_MODE

ACAMERA_SENSOR_INFO_BINNING_FACTOR	
Dimensions of the group of pixels which are under the same color filter. This specifies the width and height (pair of integers) of the group of pixels which fall under the same color filter for ULTRA_HIGH_RESOLUTION sensors.

Type: int32[2]

This tag may appear in:

ACameraMetadata from ACameraManager_getCameraCharacteristics
Sensors can have pixels grouped together under the same color filter in order to improve various aspects of imaging such as noise reduction, low light performance etc. These groups can be of various sizes such as 2X2 (quad bayer), 3X3 (nona-bayer). This key specifies the length and width of the pixels grouped under the same color filter.

This key will not be present if REMOSAIC_REPROCESSING is not supported, since RAW images will have a regular bayer pattern.

This key will not be present for sensors which don't have the CameraMetadata::REQUEST_AVAILABLE_CAPABILITIES_ULTRA_HIGH_RESOLUTION_SENSOR capability.

ACAMERA_SENSOR_INFO_COLOR_FILTER_ARRANGEMENT	
The arrangement of color filters on sensor; represents the colors in the top-left 2x2 section of the sensor, in reading order, for a Bayer camera, or the light spectrum it captures for MONOCHROME camera.

Type: byte (acamera_metadata_enum_android_sensor_info_color_filter_arrangement_t)

This tag may appear in:

ACameraMetadata from ACameraManager_getCameraCharacteristics
ACAMERA_SENSOR_INFO_END	
ACAMERA_SENSOR_INFO_EXPOSURE_TIME_RANGE	
The range of image exposure times for ACAMERA_SENSOR_EXPOSURE_TIME supported by this camera device.

See also: ACAMERA_SENSOR_EXPOSURE_TIME

Type: int64[2]

This tag may appear in:

ACameraMetadata from ACameraManager_getCameraCharacteristics
ACAMERA_SENSOR_INFO_LENS_SHADING_APPLIED	
Whether the RAW images output from this camera device are subject to lens shading correction.

Type: byte (acamera_metadata_enum_android_sensor_info_lens_shading_applied_t)

This tag may appear in:

ACameraMetadata from ACameraManager_getCameraCharacteristics
If TRUE, all images produced by the camera device in the RAW image formats will have lens shading correction already applied to it. If FALSE, the images will not be adjusted for lens shading correction. See android.request.maxNumOutputRaw for a list of RAW image formats.

This key will be null for all devices do not report this information. Devices with RAW capability will always report this information in this key.

ACAMERA_SENSOR_INFO_MAX_FRAME_DURATION	
The maximum possible frame duration (minimum frame rate) for ACAMERA_SENSOR_FRAME_DURATION that is supported this camera device.

See also: ACAMERA_SENSOR_FRAME_DURATION

Type: int64

This tag may appear in:

ACameraMetadata from ACameraManager_getCameraCharacteristics
Attempting to use frame durations beyond the maximum will result in the frame duration being clipped to the maximum. See that control for a full definition of frame durations.

Refer to ACAMERA_SCALER_AVAILABLE_MIN_FRAME_DURATIONS for the minimum frame duration values.

ACAMERA_SENSOR_INFO_PHYSICAL_SIZE	
The physical dimensions of the full pixel array.

Type: float[2]

This tag may appear in:

ACameraMetadata from ACameraManager_getCameraCharacteristics
This is the physical size of the sensor pixel array defined by ACAMERA_SENSOR_INFO_PIXEL_ARRAY_SIZE.

See also: ACAMERA_SENSOR_INFO_PIXEL_ARRAY_SIZE

ACAMERA_SENSOR_INFO_PIXEL_ARRAY_SIZE	
Dimensions of the full pixel array, possibly including black calibration pixels.

Type: int32[2]

This tag may appear in:

ACameraMetadata from ACameraManager_getCameraCharacteristics
The pixel count of the full pixel array of the image sensor, which covers ACAMERA_SENSOR_INFO_PHYSICAL_SIZE area. This represents the full pixel dimensions of the raw buffers produced by this sensor.

If a camera device supports raw sensor formats, either this or ACAMERA_SENSOR_INFO_PRE_CORRECTION_ACTIVE_ARRAY_SIZE is the maximum dimensions for the raw output formats listed in ACAMERA_SCALER_AVAILABLE_STREAM_CONFIGURATIONS (this depends on whether or not the image sensor returns buffers containing pixels that are not part of the active array region for blacklevel calibration or other purposes).

Some parts of the full pixel array may not receive light from the scene, or be otherwise inactive. The ACAMERA_SENSOR_INFO_PRE_CORRECTION_ACTIVE_ARRAY_SIZE key defines the rectangle of active pixels that will be included in processed image formats.

See also: ACAMERA_SENSOR_INFO_PHYSICAL_SIZE See also: ACAMERA_SENSOR_INFO_PRE_CORRECTION_ACTIVE_ARRAY_SIZE

ACAMERA_SENSOR_INFO_PIXEL_ARRAY_SIZE_MAXIMUM_RESOLUTION	
Dimensions of the full pixel array, possibly including black calibration pixels, when the sensor runs in maximum resolution mode. Analogous to ACAMERA_SENSOR_INFO_PIXEL_ARRAY_SIZE, when ACAMERA_SENSOR_PIXEL_MODE is set to CameraMetadata::SENSOR_PIXEL_MODE_MAXIMUM_RESOLUTION.

See also: ACAMERA_SENSOR_INFO_PIXEL_ARRAY_SIZE See also: ACAMERA_SENSOR_PIXEL_MODE

Type: int32[2]

This tag may appear in:

ACameraMetadata from ACameraManager_getCameraCharacteristics
The pixel count of the full pixel array of the image sensor, which covers ACAMERA_SENSOR_INFO_PHYSICAL_SIZE area. This represents the full pixel dimensions of the raw buffers produced by this sensor, when it runs in maximum resolution mode. That is, when ACAMERA_SENSOR_PIXEL_MODE is set to CameraMetadata::SENSOR_PIXEL_MODE_MAXIMUM_RESOLUTION. This key will only be present for devices which advertise the CameraMetadata::REQUEST_AVAILABLE_CAPABILITIES_ULTRA_HIGH_RESOLUTION_SENSOR capability.

See also: ACAMERA_SENSOR_INFO_PHYSICAL_SIZE See also: ACAMERA_SENSOR_PIXEL_MODE

ACAMERA_SENSOR_INFO_PRE_CORRECTION_ACTIVE_ARRAY_SIZE	
The area of the image sensor which corresponds to active pixels prior to the application of any geometric distortion correction.

Type: int32[4]

This tag may appear in:

ACameraMetadata from ACameraManager_getCameraCharacteristics
This is the rectangle representing the size of the active region of the sensor (i.e. the region that actually receives light from the scene) before any geometric correction has been applied, and should be treated as the active region rectangle for any of the raw formats. All metadata associated with raw processing (e.g. the lens shading correction map, and radial distortion fields) treats the top, left of this rectangle as the origin, (0,0).

The size of this region determines the maximum field of view and the maximum number of pixels that an image from this sensor can contain, prior to the application of geometric distortion correction. The effective maximum pixel dimensions of a post-distortion-corrected image is given by the ACAMERA_SENSOR_INFO_ACTIVE_ARRAY_SIZE field, and the effective maximum field of view for a post-distortion-corrected image can be calculated by applying the geometric distortion correction fields to this rectangle, and cropping to the rectangle given in ACAMERA_SENSOR_INFO_ACTIVE_ARRAY_SIZE.

E.g. to calculate position of a pixel, (x,y), in a processed YUV output image with the dimensions in ACAMERA_SENSOR_INFO_ACTIVE_ARRAY_SIZE given the position of a pixel, (x', y'), in the raw pixel array with dimensions given in ACAMERA_SENSOR_INFO_PIXEL_ARRAY_SIZE:

Choose a pixel (x', y') within the active array region of the raw buffer given in ACAMERA_SENSOR_INFO_PRE_CORRECTION_ACTIVE_ARRAY_SIZE, otherwise this pixel is considered to be outside of the FOV, and will not be shown in the processed output image.
Apply geometric distortion correction to get the post-distortion pixel coordinate, (x_i, y_i). When applying geometric correction metadata, note that metadata for raw buffers is defined relative to the top, left of the ACAMERA_SENSOR_INFO_PRE_CORRECTION_ACTIVE_ARRAY_SIZE rectangle.
If the resulting corrected pixel coordinate is within the region given in ACAMERA_SENSOR_INFO_ACTIVE_ARRAY_SIZE, then the position of this pixel in the processed output image buffer is (x_i - activeArray.left, y_i - activeArray.top), when the top, left coordinate of that buffer is treated as (0, 0).
Thus, for pixel x',y' = (25, 25) on a sensor where ACAMERA_SENSOR_INFO_PIXEL_ARRAY_SIZE is (100,100), ACAMERA_SENSOR_INFO_PRE_CORRECTION_ACTIVE_ARRAY_SIZE is (10, 10, 100, 100), ACAMERA_SENSOR_INFO_ACTIVE_ARRAY_SIZE is (20, 20, 80, 80), and the geometric distortion correction doesn't change the pixel coordinate, the resulting pixel selected in pixel coordinates would be x,y = (25, 25) relative to the top,left of the raw buffer with dimensions given in ACAMERA_SENSOR_INFO_PIXEL_ARRAY_SIZE, and would be (5, 5) relative to the top,left of post-processed YUV output buffer with dimensions given in ACAMERA_SENSOR_INFO_ACTIVE_ARRAY_SIZE.

The currently supported fields that correct for geometric distortion are:

ACAMERA_LENS_DISTORTION.
If the camera device doesn't support geometric distortion correction, or all of the geometric distortion fields are no-ops, this rectangle will be the same as the post-distortion-corrected rectangle given in ACAMERA_SENSOR_INFO_ACTIVE_ARRAY_SIZE.

This rectangle is defined relative to the full pixel array; (0,0) is the top-left of the full pixel array, and the size of the full pixel array is given by ACAMERA_SENSOR_INFO_PIXEL_ARRAY_SIZE.

The pre-correction active array may be smaller than the full pixel array, since the full array may include black calibration pixels or other inactive regions.

The data representation is int[4], which maps to (left, top, width, height).

See also: ACAMERA_LENS_DISTORTION See also: ACAMERA_SENSOR_INFO_ACTIVE_ARRAY_SIZE See also: ACAMERA_SENSOR_INFO_PIXEL_ARRAY_SIZE See also: ACAMERA_SENSOR_INFO_PRE_CORRECTION_ACTIVE_ARRAY_SIZE

ACAMERA_SENSOR_INFO_PRE_CORRECTION_ACTIVE_ARRAY_SIZE_MAXIMUM_RESOLUTION	
The area of the image sensor which corresponds to active pixels prior to the application of any geometric distortion correction, when the sensor runs in maximum resolution mode. This key must be used for crop / metering regions, only when ACAMERA_SENSOR_PIXEL_MODE is set to CameraMetadata::SENSOR_PIXEL_MODE_MAXIMUM_RESOLUTION.

See also: ACAMERA_SENSOR_PIXEL_MODE

Type: int32[4]

This tag may appear in:

ACameraMetadata from ACameraManager_getCameraCharacteristics
Analogous to ACAMERA_SENSOR_INFO_PRE_CORRECTION_ACTIVE_ARRAY_SIZE, when ACAMERA_SENSOR_PIXEL_MODE is set to CameraMetadata::SENSOR_PIXEL_MODE_MAXIMUM_RESOLUTION. This key will only be present for devices which advertise the CameraMetadata::REQUEST_AVAILABLE_CAPABILITIES_ULTRA_HIGH_RESOLUTION_SENSOR capability.

The data representation is int[4], which maps to (left, top, width, height).

See also: ACAMERA_SENSOR_INFO_PRE_CORRECTION_ACTIVE_ARRAY_SIZE See also: ACAMERA_SENSOR_PIXEL_MODE

ACAMERA_SENSOR_INFO_SENSITIVITY_RANGE	
Range of sensitivities for ACAMERA_SENSOR_SENSITIVITY supported by this camera device.

See also: ACAMERA_SENSOR_SENSITIVITY

Type: int32[2]

This tag may appear in:

ACameraMetadata from ACameraManager_getCameraCharacteristics
The values are the standard ISO sensitivity values, as defined in ISO 12232:2006.

ACAMERA_SENSOR_INFO_TIMESTAMP_SOURCE	
The time base source for sensor capture start timestamps.

Type: byte (acamera_metadata_enum_android_sensor_info_timestamp_source_t)

This tag may appear in:

ACameraMetadata from ACameraManager_getCameraCharacteristics
The timestamps provided for captures are always in nanoseconds and monotonic, but may not based on a time source that can be compared to other system time sources.

This characteristic defines the source for the timestamps, and therefore whether they can be compared against other system time sources/timestamps.

ACAMERA_SENSOR_INFO_WHITE_LEVEL	
Maximum raw value output by sensor.

Type: int32

This tag may appear in:

ACameraMetadata from ACameraManager_getCameraCharacteristics
This specifies the fully-saturated encoding level for the raw sample values from the sensor. This is typically caused by the sensor becoming highly non-linear or clipping. The minimum for each channel is specified by the offset in the ACAMERA_SENSOR_BLACK_LEVEL_PATTERN key.

The white level is typically determined either by sensor bit depth (8-14 bits is expected), or by the point where the sensor response becomes too non-linear to be useful. The default value for this is maximum representable value for a 16-bit raw sample (2^16 - 1).

The white level values of captured images may vary for different capture settings (e.g., ACAMERA_SENSOR_SENSITIVITY). This key represents a coarse approximation for such case. It is recommended to use ACAMERA_SENSOR_DYNAMIC_WHITE_LEVEL for captures when supported by the camera device, which provides more accurate white level values.

See also: ACAMERA_SENSOR_BLACK_LEVEL_PATTERN See also: ACAMERA_SENSOR_DYNAMIC_WHITE_LEVEL See also: ACAMERA_SENSOR_SENSITIVITY

ACAMERA_SENSOR_MAX_ANALOG_SENSITIVITY	
Maximum sensitivity that is implemented purely through analog gain.

Type: int32

This tag may appear in:

ACameraMetadata from ACameraManager_getCameraCharacteristics
For ACAMERA_SENSOR_SENSITIVITY values less than or equal to this, all applied gain must be analog. For values above this, the gain applied can be a mix of analog and digital.

See also: ACAMERA_SENSOR_SENSITIVITY

ACAMERA_SENSOR_NEUTRAL_COLOR_POINT	
The estimated camera neutral color in the native sensor colorspace at the time of capture.

Type: rational[3]

This tag may appear in:

ACameraMetadata from ACameraCaptureSession_captureCallback_result callbacks
This value gives the neutral color point encoded as an RGB value in the native sensor color space. The neutral color point indicates the currently estimated white point of the scene illumination. It can be used to interpolate between the provided color transforms when processing raw sensor data.

The order of the values is R, G, B; where R is in the lowest index.

Starting from Android Q, this key will not be present for a MONOCHROME camera, even if the camera device has RAW capability.

ACAMERA_SENSOR_NOISE_PROFILE	
Noise model coefficients for each CFA mosaic channel.

Type: double[2*CFA Channels]

This tag may appear in:

ACameraMetadata from ACameraCaptureSession_captureCallback_result callbacks
This key contains two noise model coefficients for each CFA channel corresponding to the sensor amplification (S) and sensor readout noise (O). These are given as pairs of coefficients for each channel in the same order as channels listed for the CFA layout key (see ACAMERA_SENSOR_INFO_COLOR_FILTER_ARRANGEMENT). This is represented as an array of Pair, where the first member of the Pair at index n is the S coefficient and the second member is the O coefficient for the nth color channel in the CFA.

These coefficients are used in a two parameter noise model to describe the amount of noise present in the image for each CFA channel. The noise model used here is:

N(x) = sqrt(Sx + O)

Where x represents the recorded signal of a CFA channel normalized to the range [0, 1], and S and O are the noise model coefficients for that channel.

A more detailed description of the noise model can be found in the Adobe DNG specification for the NoiseProfile tag.

For a MONOCHROME camera, there is only one color channel. So the noise model coefficients will only contain one S and one O.

See also: ACAMERA_SENSOR_INFO_COLOR_FILTER_ARRANGEMENT

ACAMERA_SENSOR_OPTICAL_BLACK_REGIONS	
List of disjoint rectangles indicating the sensor optically shielded black pixel regions.

Type: int32[4*num_regions]

This tag may appear in:

ACameraMetadata from ACameraManager_getCameraCharacteristics
In most camera sensors, the active array is surrounded by some optically shielded pixel areas. By blocking light, these pixels provides a reliable black reference for black level compensation in active array region.

This key provides a list of disjoint rectangles specifying the regions of optically shielded (with metal shield) black pixel regions if the camera device is capable of reading out these black pixels in the output raw images. In comparison to the fixed black level values reported by ACAMERA_SENSOR_BLACK_LEVEL_PATTERN, this key may provide a more accurate way for the application to calculate black level of each captured raw images.

When this key is reported, the ACAMERA_SENSOR_DYNAMIC_BLACK_LEVEL and ACAMERA_SENSOR_DYNAMIC_WHITE_LEVEL will also be reported.

The data representation is int[4], which maps to (left, top, width, height).

See also: ACAMERA_SENSOR_BLACK_LEVEL_PATTERN See also: ACAMERA_SENSOR_DYNAMIC_BLACK_LEVEL See also: ACAMERA_SENSOR_DYNAMIC_WHITE_LEVEL

ACAMERA_SENSOR_ORIENTATION	
Clockwise angle through which the output image needs to be rotated to be upright on the device screen in its native orientation.

Type: int32

This tag may appear in:

ACameraMetadata from ACameraManager_getCameraCharacteristics
Also defines the direction of rolling shutter readout, which is from top to bottom in the sensor's coordinate system.

Starting with Android API level 32, camera clients that query the orientation via CameraCharacteristics::get on foldable devices which include logical cameras can receive a value that can dynamically change depending on the device/fold state. Clients are advised to not cache or store the orientation value of such logical sensors. In case repeated queries to CameraCharacteristics are not preferred, then clients can also access the entire mapping from device state to sensor orientation in DeviceStateSensorOrientationMap. Do note that a dynamically changing sensor orientation value in camera characteristics will not be the best way to establish the orientation per frame. Clients that want to know the sensor orientation of a particular captured frame should query the ACAMERA_LOGICAL_MULTI_CAMERA_ACTIVE_PHYSICAL_ID from the corresponding capture result and check the respective physical camera orientation.

Native camera clients must query ACAMERA_INFO_DEVICE_STATE_ORIENTATIONS for the mapping between device state and camera sensor orientation. Dynamic updates to the sensor orientation are not supported in this code path.

See also: ACAMERA_INFO_DEVICE_STATE_ORIENTATIONS See also: ACAMERA_LOGICAL_MULTI_CAMERA_ACTIVE_PHYSICAL_ID

ACAMERA_SENSOR_PIXEL_MODE	
Switches sensor pixel mode between maximum resolution mode and default mode.

Type: byte (acamera_metadata_enum_android_sensor_pixel_mode_t)

This tag may appear in:

ACameraMetadata from ACameraCaptureSession_captureCallback_result callbacks
ACaptureRequest
This key controls whether the camera sensor operates in CameraMetadata::SENSOR_PIXEL_MODE_MAXIMUM_RESOLUTION mode or not. By default, all camera devices operate in CameraMetadata::SENSOR_PIXEL_MODE_DEFAULT mode. When operating in CameraMetadata::SENSOR_PIXEL_MODE_DEFAULT mode, sensors with CameraMetadata::REQUEST_AVAILABLE_CAPABILITIES_ULTRA_HIGH_RESOLUTION_SENSOR capability would typically perform pixel binning in order to improve low light performance, noise reduction etc. However, in CameraMetadata::SENSOR_PIXEL_MODE_MAXIMUM_RESOLUTION mode (supported only by CameraMetadata::REQUEST_AVAILABLE_CAPABILITIES_ULTRA_HIGH_RESOLUTION_SENSOR sensors), sensors typically operate in unbinned mode allowing for a larger image size. The stream configurations supported in CameraMetadata::SENSOR_PIXEL_MODE_MAXIMUM_RESOLUTION mode are also different from those of CameraMetadata::SENSOR_PIXEL_MODE_DEFAULT mode. They can be queried through CameraCharacteristics::get with CameraCharacteristics::SCALER_STREAM_CONFIGURATION_MAP_MAXIMUM_RESOLUTION). Unless reported by both StreamConfigurationMaps, the outputs from android.scaler.streamConfigurationMapMaximumResolution and android.scaler.streamConfigurationMap must not be mixed in the same CaptureRequest. In other words, these outputs are exclusive to each other. This key does not need to be set for reprocess requests.

ACAMERA_SENSOR_RAW_BINNING_FACTOR_USED	
Whether RAW images requested have their bayer pattern as described by ACAMERA_SENSOR_INFO_BINNING_FACTOR.

See also: ACAMERA_SENSOR_INFO_BINNING_FACTOR

Type: byte (acamera_metadata_enum_android_sensor_raw_binning_factor_used_t)

This tag may appear in:

ACameraMetadata from ACameraCaptureSession_captureCallback_result callbacks
This key will only be present in devices advertising the CameraMetadata::REQUEST_AVAILABLE_CAPABILITIES_ULTRA_HIGH_RESOLUTION_SENSOR capability which also advertise REMOSAIC_REPROCESSING capability. On all other devices RAW targets will have a regular bayer pattern.

ACAMERA_SENSOR_REFERENCE_ILLUMINANT1	
The standard reference illuminant used as the scene light source when calculating the ACAMERA_SENSOR_COLOR_TRANSFORM1, ACAMERA_SENSOR_CALIBRATION_TRANSFORM1, and ACAMERA_SENSOR_FORWARD_MATRIX1 matrices.

See also: ACAMERA_SENSOR_CALIBRATION_TRANSFORM1 See also: ACAMERA_SENSOR_COLOR_TRANSFORM1 See also: ACAMERA_SENSOR_FORWARD_MATRIX1

Type: byte (acamera_metadata_enum_android_sensor_reference_illuminant1_t)

This tag may appear in:

ACameraMetadata from ACameraManager_getCameraCharacteristics
The values in this key correspond to the values defined for the EXIF LightSource tag. These illuminants are standard light sources that are often used calibrating camera devices.

If this key is present, then ACAMERA_SENSOR_COLOR_TRANSFORM1, ACAMERA_SENSOR_CALIBRATION_TRANSFORM1, and ACAMERA_SENSOR_FORWARD_MATRIX1 will also be present.

Some devices may choose to provide a second set of calibration information for improved quality, including ACAMERA_SENSOR_REFERENCE_ILLUMINANT2 and its corresponding matrices.

Starting from Android Q, this key will not be present for a MONOCHROME camera, even if the camera device has RAW capability.

See also: ACAMERA_SENSOR_CALIBRATION_TRANSFORM1 See also: ACAMERA_SENSOR_COLOR_TRANSFORM1 See also: ACAMERA_SENSOR_FORWARD_MATRIX1 See also: ACAMERA_SENSOR_REFERENCE_ILLUMINANT2

ACAMERA_SENSOR_REFERENCE_ILLUMINANT2	
The standard reference illuminant used as the scene light source when calculating the ACAMERA_SENSOR_COLOR_TRANSFORM2, ACAMERA_SENSOR_CALIBRATION_TRANSFORM2, and ACAMERA_SENSOR_FORWARD_MATRIX2 matrices.

See also: ACAMERA_SENSOR_CALIBRATION_TRANSFORM2 See also: ACAMERA_SENSOR_COLOR_TRANSFORM2 See also: ACAMERA_SENSOR_FORWARD_MATRIX2

Type: byte

This tag may appear in:

ACameraMetadata from ACameraManager_getCameraCharacteristics
See ACAMERA_SENSOR_REFERENCE_ILLUMINANT1 for more details.

If this key is present, then ACAMERA_SENSOR_COLOR_TRANSFORM2, ACAMERA_SENSOR_CALIBRATION_TRANSFORM2, and ACAMERA_SENSOR_FORWARD_MATRIX2 will also be present.

Starting from Android Q, this key will not be present for a MONOCHROME camera, even if the camera device has RAW capability.

See also: ACAMERA_SENSOR_CALIBRATION_TRANSFORM2 See also: ACAMERA_SENSOR_COLOR_TRANSFORM2 See also: ACAMERA_SENSOR_FORWARD_MATRIX2 See also: ACAMERA_SENSOR_REFERENCE_ILLUMINANT1

ACAMERA_SENSOR_ROLLING_SHUTTER_SKEW	
Duration between the start of exposure for the first row of the image sensor, and the start of exposure for one past the last row of the image sensor.

Type: int64

This tag may appear in:

ACameraMetadata from ACameraCaptureSession_captureCallback_result callbacks
This is the exposure time skew between the first and (last+1) row exposure start times. The first row and the last row are the first and last rows inside of the ACAMERA_SENSOR_INFO_ACTIVE_ARRAY_SIZE.

For typical camera sensors that use rolling shutters, this is also equivalent to the frame readout time.

If the image sensor is operating in a binned or cropped mode due to the current output target resolutions, it's possible this skew is reported to be larger than the exposure time, for example, since it is based on the full array even if a partial array is read out. Be sure to scale the number to cover the section of the sensor actually being used for the outputs you care about. So if your output covers N rows of the active array of height H, scale this value by N/H to get the total skew for that viewport.

Note: Prior to Android 11, this field was described as measuring duration from first to last row of the image sensor, which is not equal to the frame readout time for a rolling shutter sensor. Implementations generally reported the latter value, so to resolve the inconsistency, the description has been updated to range from (first, last+1) row exposure start, instead.

See also: ACAMERA_SENSOR_INFO_ACTIVE_ARRAY_SIZE

ACAMERA_SENSOR_SENSITIVITY	
The amount of gain applied to sensor data before processing.

Type: int32

This tag may appear in:

ACameraMetadata from ACameraCaptureSession_captureCallback_result callbacks
ACaptureRequest
The sensitivity is the standard ISO sensitivity value, as defined in ISO 12232:2006.

The sensitivity must be within ACAMERA_SENSOR_INFO_SENSITIVITY_RANGE, and if if it less than ACAMERA_SENSOR_MAX_ANALOG_SENSITIVITY, the camera device is guaranteed to use only analog amplification for applying the gain.

If the camera device cannot apply the exact sensitivity requested, it will reduce the gain to the nearest supported value. The final sensitivity used will be available in the output capture result.

This control is only effective if ACAMERA_CONTROL_AE_MODE or ACAMERA_CONTROL_MODE is set to OFF; otherwise the auto-exposure algorithm will override this value.

Note that for devices supporting postRawSensitivityBoost, the total sensitivity applied to the final processed image is the combination of ACAMERA_SENSOR_SENSITIVITY and ACAMERA_CONTROL_POST_RAW_SENSITIVITY_BOOST. In case the application uses the sensor sensitivity from last capture result of an auto request for a manual request, in order to achieve the same brightness in the output image, the application should also set postRawSensitivityBoost.

See also: ACAMERA_CONTROL_AE_MODE See also: ACAMERA_CONTROL_MODE See also: ACAMERA_CONTROL_POST_RAW_SENSITIVITY_BOOST See also: ACAMERA_SENSOR_INFO_SENSITIVITY_RANGE See also: ACAMERA_SENSOR_MAX_ANALOG_SENSITIVITY See also: ACAMERA_SENSOR_SENSITIVITY

ACAMERA_SENSOR_TEST_PATTERN_DATA	
A pixel [R, G_even, G_odd, B] that supplies the test pattern when ACAMERA_SENSOR_TEST_PATTERN_MODE is SOLID_COLOR.

See also: ACAMERA_SENSOR_TEST_PATTERN_MODE

Type: int32[4]

This tag may appear in:

ACameraMetadata from ACameraCaptureSession_captureCallback_result callbacks
ACaptureRequest
Each color channel is treated as an unsigned 32-bit integer. The camera device then uses the most significant X bits that correspond to how many bits are in its Bayer raw sensor output.

For example, a sensor with RAW10 Bayer output would use the 10 most significant bits from each color channel.

ACAMERA_SENSOR_TEST_PATTERN_MODE	
When enabled, the sensor sends a test pattern instead of doing a real exposure from the camera.

Type: int32 (acamera_metadata_enum_android_sensor_test_pattern_mode_t)

This tag may appear in:

ACameraMetadata from ACameraCaptureSession_captureCallback_result callbacks
ACaptureRequest
When a test pattern is enabled, all manual sensor controls specified by ACAMERA_SENSOR_* will be ignored. All other controls should work as normal.

For example, if manual flash is enabled, flash firing should still occur (and that the test pattern remain unmodified, since the flash would not actually affect it).

Defaults to OFF.

ACAMERA_SENSOR_TIMESTAMP	
Time at start of exposure of first row of the image sensor active array, in nanoseconds.

Type: int64

This tag may appear in:

ACameraMetadata from ACameraCaptureSession_captureCallback_result callbacks
The timestamps are also included in all image buffers produced for the same capture, and will be identical on all the outputs.

When ACAMERA_SENSOR_INFO_TIMESTAMP_SOURCE == UNKNOWN, the timestamps measure time since an unspecified starting point, and are monotonically increasing. They can be compared with the timestamps for other captures from the same camera device, but are not guaranteed to be comparable to any other time source.

When ACAMERA_SENSOR_INFO_TIMESTAMP_SOURCE == REALTIME, the timestamps measure time in the same timebase as SystemClock::elapsedRealtimeNanos, and they can be compared to other timestamps from other subsystems that are using that base.

For reprocessing, the timestamp will match the start of exposure of the input image, i.e. the timestamp in the TotalCaptureResult that was used to create the reprocess capture request.

See also: ACAMERA_SENSOR_INFO_TIMESTAMP_SOURCE

ACAMERA_SHADING_AVAILABLE_MODES	
List of lens shading modes for ACAMERA_SHADING_MODE that are supported by this camera device.

See also: ACAMERA_SHADING_MODE

Type: byte[n]

This tag may appear in:

ACameraMetadata from ACameraManager_getCameraCharacteristics
This list contains lens shading modes that can be set for the camera device. Camera devices that support the MANUAL_POST_PROCESSING capability will always list OFF and FAST mode. This includes all FULL level devices. LEGACY devices will always only support FAST mode.

ACAMERA_SHADING_END	
ACAMERA_SHADING_MODE	
Quality of lens shading correction applied to the image data.

Type: byte (acamera_metadata_enum_android_shading_mode_t)

This tag may appear in:

ACameraMetadata from ACameraCaptureSession_captureCallback_result callbacks
ACaptureRequest
When set to OFF mode, no lens shading correction will be applied by the camera device, and an identity lens shading map data will be provided if ACAMERA_STATISTICS_LENS_SHADING_MAP_MODE == ON. For example, for lens shading map with size of [ 4, 3 ], the output android.statistics.lensShadingCorrectionMap for this case will be an identity map shown below:

[ 1.0, 1.0, 1.0, 1.0,  1.0, 1.0, 1.0, 1.0,
 1.0, 1.0, 1.0, 1.0,  1.0, 1.0, 1.0, 1.0,
 1.0, 1.0, 1.0, 1.0,  1.0, 1.0, 1.0, 1.0,
 1.0, 1.0, 1.0, 1.0,  1.0, 1.0, 1.0, 1.0,
 1.0, 1.0, 1.0, 1.0,  1.0, 1.0, 1.0, 1.0,
 1.0, 1.0, 1.0, 1.0,  1.0, 1.0, 1.0, 1.0 ]
When set to other modes, lens shading correction will be applied by the camera device. Applications can request lens shading map data by setting ACAMERA_STATISTICS_LENS_SHADING_MAP_MODE to ON, and then the camera device will provide lens shading map data in android.statistics.lensShadingCorrectionMap; the returned shading map data will be the one applied by the camera device for this capture request.

The shading map data may depend on the auto-exposure (AE) and AWB statistics, therefore the reliability of the map data may be affected by the AE and AWB algorithms. When AE and AWB are in AUTO modes(ACAMERA_CONTROL_AE_MODE != OFF and ACAMERA_CONTROL_AWB_MODE != OFF), to get best results, it is recommended that the applications wait for the AE and AWB to be converged before using the returned shading map data.

See also: ACAMERA_CONTROL_AE_MODE See also: ACAMERA_CONTROL_AWB_MODE See also: ACAMERA_STATISTICS_LENS_SHADING_MAP_MODE

ACAMERA_STATISTICS_END	
ACAMERA_STATISTICS_FACE_DETECT_MODE	
Operating mode for the face detector unit.

Type: byte (acamera_metadata_enum_android_statistics_face_detect_mode_t)

This tag may appear in:

ACameraMetadata from ACameraCaptureSession_captureCallback_result callbacks
ACaptureRequest
Whether face detection is enabled, and whether it should output just the basic fields or the full set of fields.

ACAMERA_STATISTICS_FACE_IDS	
List of unique IDs for detected faces.

Type: int32[n]

This tag may appear in:

ACameraMetadata from ACameraCaptureSession_captureCallback_result callbacks
Each detected face is given a unique ID that is valid for as long as the face is visible to the camera device. A face that leaves the field of view and later returns may be assigned a new ID.

Only available if ACAMERA_STATISTICS_FACE_DETECT_MODE == FULL

See also: ACAMERA_STATISTICS_FACE_DETECT_MODE

ACAMERA_STATISTICS_FACE_LANDMARKS	
List of landmarks for detected faces.

Type: int32[n*6]

This tag may appear in:

ACameraMetadata from ACameraCaptureSession_captureCallback_result callbacks
For devices not supporting ACAMERA_DISTORTION_CORRECTION_MODE control, the coordinate system always follows that of ACAMERA_SENSOR_INFO_ACTIVE_ARRAY_SIZE, with (0, 0) being the top-left pixel of the active array.

For devices supporting ACAMERA_DISTORTION_CORRECTION_MODE control, the coordinate system depends on the mode being set. When the distortion correction mode is OFF, the coordinate system follows ACAMERA_SENSOR_INFO_PRE_CORRECTION_ACTIVE_ARRAY_SIZE, with (0, 0) being the top-left pixel of the pre-correction active array. When the distortion correction mode is not OFF, the coordinate system follows ACAMERA_SENSOR_INFO_ACTIVE_ARRAY_SIZE, with (0, 0) being the top-left pixel of the active array.

Only available if ACAMERA_STATISTICS_FACE_DETECT_MODE == FULL.

Starting from API level 30, the coordinate system of activeArraySize or preCorrectionActiveArraySize is used to represent post-zoomRatio field of view, not pre-zoomRatio field of view. This means that if the relative position of faces and the camera device doesn't change, when zooming in by increasing ACAMERA_CONTROL_ZOOM_RATIO, the face landmarks move farther away from the center of the activeArray or preCorrectionActiveArray. If ACAMERA_CONTROL_ZOOM_RATIO is set to 1.0 (default), the face landmarks coordinates won't change as ACAMERA_SCALER_CROP_REGION changes. See ACAMERA_CONTROL_ZOOM_RATIO for details. Whether to use activeArraySize or preCorrectionActiveArraySize still depends on distortion correction mode.

See also: ACAMERA_CONTROL_ZOOM_RATIO See also: ACAMERA_DISTORTION_CORRECTION_MODE See also: ACAMERA_SCALER_CROP_REGION See also: ACAMERA_SENSOR_INFO_ACTIVE_ARRAY_SIZE See also: ACAMERA_SENSOR_INFO_PRE_CORRECTION_ACTIVE_ARRAY_SIZE See also: ACAMERA_STATISTICS_FACE_DETECT_MODE

ACAMERA_STATISTICS_FACE_RECTANGLES	
List of the bounding rectangles for detected faces.

Type: int32[n*4]

This tag may appear in:

ACameraMetadata from ACameraCaptureSession_captureCallback_result callbacks
For devices not supporting ACAMERA_DISTORTION_CORRECTION_MODE control, the coordinate system always follows that of ACAMERA_SENSOR_INFO_ACTIVE_ARRAY_SIZE, with (0, 0) being the top-left pixel of the active array.

For devices supporting ACAMERA_DISTORTION_CORRECTION_MODE control, the coordinate system depends on the mode being set. When the distortion correction mode is OFF, the coordinate system follows ACAMERA_SENSOR_INFO_PRE_CORRECTION_ACTIVE_ARRAY_SIZE, with (0, 0) being the top-left pixel of the pre-correction active array. When the distortion correction mode is not OFF, the coordinate system follows ACAMERA_SENSOR_INFO_ACTIVE_ARRAY_SIZE, with (0, 0) being the top-left pixel of the active array.

Only available if ACAMERA_STATISTICS_FACE_DETECT_MODE != OFF.

Starting from API level 30, the coordinate system of activeArraySize or preCorrectionActiveArraySize is used to represent post-zoomRatio field of view, not pre-zoomRatio field of view. This means that if the relative position of faces and the camera device doesn't change, when zooming in by increasing ACAMERA_CONTROL_ZOOM_RATIO, the face rectangles grow larger and move farther away from the center of the activeArray or preCorrectionActiveArray. If ACAMERA_CONTROL_ZOOM_RATIO is set to 1.0 (default), the face rectangles won't change as ACAMERA_SCALER_CROP_REGION changes. See ACAMERA_CONTROL_ZOOM_RATIO for details. Whether to use activeArraySize or preCorrectionActiveArraySize still depends on distortion correction mode.

The data representation is int[4], which maps to (left, top, right, bottom).

See also: ACAMERA_CONTROL_ZOOM_RATIO See also: ACAMERA_DISTORTION_CORRECTION_MODE See also: ACAMERA_SCALER_CROP_REGION See also: ACAMERA_SENSOR_INFO_ACTIVE_ARRAY_SIZE See also: ACAMERA_SENSOR_INFO_PRE_CORRECTION_ACTIVE_ARRAY_SIZE See also: ACAMERA_STATISTICS_FACE_DETECT_MODE

ACAMERA_STATISTICS_FACE_SCORES	
List of the face confidence scores for detected faces

Type: byte[n]

This tag may appear in:

ACameraMetadata from ACameraCaptureSession_captureCallback_result callbacks
Only available if ACAMERA_STATISTICS_FACE_DETECT_MODE != OFF.

See also: ACAMERA_STATISTICS_FACE_DETECT_MODE

ACAMERA_STATISTICS_HOT_PIXEL_MAP	
List of (x, y) coordinates of hot/defective pixels on the sensor.

Type: int32[2*n]

This tag may appear in:

ACameraMetadata from ACameraCaptureSession_captureCallback_result callbacks
A coordinate (x, y) must lie between (0, 0), and (width - 1, height - 1) (inclusive), which are the top-left and bottom-right of the pixel array, respectively. The width and height dimensions are given in ACAMERA_SENSOR_INFO_PIXEL_ARRAY_SIZE. This may include hot pixels that lie outside of the active array bounds given by ACAMERA_SENSOR_INFO_ACTIVE_ARRAY_SIZE.

See also: ACAMERA_SENSOR_INFO_ACTIVE_ARRAY_SIZE See also: ACAMERA_SENSOR_INFO_PIXEL_ARRAY_SIZE

ACAMERA_STATISTICS_HOT_PIXEL_MAP_MODE	
Operating mode for hot pixel map generation.

Type: byte (acamera_metadata_enum_android_statistics_hot_pixel_map_mode_t)

This tag may appear in:

ACameraMetadata from ACameraCaptureSession_captureCallback_result callbacks
ACaptureRequest
If set to true, a hot pixel map is returned in ACAMERA_STATISTICS_HOT_PIXEL_MAP. If set to false, no hot pixel map will be returned.

See also: ACAMERA_STATISTICS_HOT_PIXEL_MAP

ACAMERA_STATISTICS_INFO_AVAILABLE_FACE_DETECT_MODES	
List of face detection modes for ACAMERA_STATISTICS_FACE_DETECT_MODE that are supported by this camera device.

See also: ACAMERA_STATISTICS_FACE_DETECT_MODE

Type: byte[n]

This tag may appear in:

ACameraMetadata from ACameraManager_getCameraCharacteristics
OFF is always supported.

ACAMERA_STATISTICS_INFO_AVAILABLE_HOT_PIXEL_MAP_MODES	
List of hot pixel map output modes for ACAMERA_STATISTICS_HOT_PIXEL_MAP_MODE that are supported by this camera device.

See also: ACAMERA_STATISTICS_HOT_PIXEL_MAP_MODE

Type: byte[n]

This tag may appear in:

ACameraMetadata from ACameraManager_getCameraCharacteristics
If no hotpixel map output is available for this camera device, this will contain only false.

ON is always supported on devices with the RAW capability.

ACAMERA_STATISTICS_INFO_AVAILABLE_LENS_SHADING_MAP_MODES	
List of lens shading map output modes for ACAMERA_STATISTICS_LENS_SHADING_MAP_MODE that are supported by this camera device.

See also: ACAMERA_STATISTICS_LENS_SHADING_MAP_MODE

Type: byte[n]

This tag may appear in:

ACameraMetadata from ACameraManager_getCameraCharacteristics
If no lens shading map output is available for this camera device, this key will contain only OFF.

ON is always supported on devices with the RAW capability. LEGACY mode devices will always only support OFF.

ACAMERA_STATISTICS_INFO_AVAILABLE_OIS_DATA_MODES	
List of OIS data output modes for ACAMERA_STATISTICS_OIS_DATA_MODE that are supported by this camera device.

See also: ACAMERA_STATISTICS_OIS_DATA_MODE

Type: byte[n]

This tag may appear in:

ACameraMetadata from ACameraManager_getCameraCharacteristics
If no OIS data output is available for this camera device, this key will contain only OFF.

ACAMERA_STATISTICS_INFO_END	
ACAMERA_STATISTICS_INFO_MAX_FACE_COUNT	
The maximum number of simultaneously detectable faces.

Type: int32

This tag may appear in:

ACameraMetadata from ACameraManager_getCameraCharacteristics
ACAMERA_STATISTICS_LENS_SHADING_MAP	
The shading map is a low-resolution floating-point map that lists the coefficients used to correct for vignetting and color shading, for each Bayer color channel of RAW image data.

Type: float[4*n*m]

This tag may appear in:

ACameraMetadata from ACameraCaptureSession_captureCallback_result callbacks
The map provided here is the same map that is used by the camera device to correct both color shading and vignetting for output non-RAW images.

When there is no lens shading correction applied to RAW output images (ACAMERA_SENSOR_INFO_LENS_SHADING_APPLIED == false), this map is the complete lens shading correction map; when there is some lens shading correction applied to the RAW output image (ACAMERA_SENSOR_INFO_LENS_SHADING_APPLIED== true), this map reports the remaining lens shading correction map that needs to be applied to get shading corrected images that match the camera device's output for non-RAW formats.

For a complete shading correction map, the least shaded section of the image will have a gain factor of 1; all other sections will have gains above 1.

When ACAMERA_COLOR_CORRECTION_MODE = TRANSFORM_MATRIX, the map will take into account the colorCorrection settings.

The shading map is for the entire active pixel array, and is not affected by the crop region specified in the request. Each shading map entry is the value of the shading compensation map over a specific pixel on the sensor. Specifically, with a (N x M) resolution shading map, and an active pixel array size (W x H), shading map entry (x,y) ϵ (0 ... N-1, 0 ... M-1) is the value of the shading map at pixel ( ((W-1)/(N-1)) * x, ((H-1)/(M-1)) * y) for the four color channels. The map is assumed to be bilinearly interpolated between the sample points.

For a Bayer camera, the channel order is [R, Geven, Godd, B], where Geven is the green channel for the even rows of a Bayer pattern, and Godd is the odd rows. The shading map is stored in a fully interleaved format, and its size is provided in the camera static metadata by ACAMERA_LENS_INFO_SHADING_MAP_SIZE.

The shading map will generally have on the order of 30-40 rows and columns, and will be smaller than 64x64.

As an example, given a very small map for a Bayer camera defined as:

ACAMERA_LENS_INFO_SHADING_MAP_SIZE = [ 4, 3 ]
ACAMERA_STATISTICS_LENS_SHADING_MAP =
[ 1.3, 1.2, 1.15, 1.2,  1.2, 1.2, 1.15, 1.2,
    1.1, 1.2, 1.2, 1.2,  1.3, 1.2, 1.3, 1.3,
  1.2, 1.2, 1.25, 1.1,  1.1, 1.1, 1.1, 1.0,
    1.0, 1.0, 1.0, 1.0,  1.2, 1.3, 1.25, 1.2,
  1.3, 1.2, 1.2, 1.3,   1.2, 1.15, 1.1, 1.2,
    1.2, 1.1, 1.0, 1.2,  1.3, 1.15, 1.2, 1.3 ]
The low-resolution scaling map images for each channel are (displayed using nearest-neighbor interpolation):





As a visualization only, inverting the full-color map to recover an image of a gray wall (using bicubic interpolation for visual quality) as captured by the sensor gives:


For a MONOCHROME camera, all of the 2x2 channels must have the same values. An example shading map for such a camera is defined as:

ACAMERA_LENS_INFO_SHADING_MAP_SIZE = [ 4, 3 ]
ACAMERA_STATISTICS_LENS_SHADING_MAP =
[ 1.3, 1.3, 1.3, 1.3,  1.2, 1.2, 1.2, 1.2,
    1.1, 1.1, 1.1, 1.1,  1.3, 1.3, 1.3, 1.3,
  1.2, 1.2, 1.2, 1.2,  1.1, 1.1, 1.1, 1.1,
    1.0, 1.0, 1.0, 1.0,  1.2, 1.2, 1.2, 1.2,
  1.3, 1.3, 1.3, 1.3,   1.2, 1.2, 1.2, 1.2,
    1.2, 1.2, 1.2, 1.2,  1.3, 1.3, 1.3, 1.3 ]
Note that the RAW image data might be subject to lens shading correction not reported on this map. Query ACAMERA_SENSOR_INFO_LENS_SHADING_APPLIED to see if RAW image data has subject to lens shading correction. If ACAMERA_SENSOR_INFO_LENS_SHADING_APPLIED is TRUE, the RAW image data is subject to partial or full lens shading correction. In the case full lens shading correction is applied to RAW images, the gain factor map reported in this key will contain all 1.0 gains. In other words, the map reported in this key is the remaining lens shading that needs to be applied on the RAW image to get images without lens shading artifacts. See android.request.maxNumOutputRaw for a list of RAW image formats.

See also: ACAMERA_COLOR_CORRECTION_MODE See also: ACAMERA_LENS_INFO_SHADING_MAP_SIZE See also: ACAMERA_SENSOR_INFO_LENS_SHADING_APPLIED See also: ACAMERA_STATISTICS_LENS_SHADING_MAP

ACAMERA_STATISTICS_LENS_SHADING_MAP_MODE	
Whether the camera device will output the lens shading map in output result metadata.

Type: byte (acamera_metadata_enum_android_statistics_lens_shading_map_mode_t)

This tag may appear in:

ACameraMetadata from ACameraCaptureSession_captureCallback_result callbacks
ACaptureRequest
When set to ON, ACAMERA_STATISTICS_LENS_SHADING_MAP will be provided in the output result metadata.

ON is always supported on devices with the RAW capability.

See also: ACAMERA_STATISTICS_LENS_SHADING_MAP

ACAMERA_STATISTICS_OIS_DATA_MODE	
A control for selecting whether optical stabilization (OIS) position information is included in output result metadata.

Type: byte (acamera_metadata_enum_android_statistics_ois_data_mode_t)

This tag may appear in:

ACameraMetadata from ACameraCaptureSession_captureCallback_result callbacks
ACaptureRequest
Since optical image stabilization generally involves motion much faster than the duration of individual image exposure, multiple OIS samples can be included for a single capture result. For example, if the OIS reporting operates at 200 Hz, a typical camera operating at 30fps may have 6-7 OIS samples per capture result. This information can be combined with the rolling shutter skew to account for lens motion during image exposure in post-processing algorithms.

ACAMERA_STATISTICS_OIS_TIMESTAMPS	
An array of timestamps of OIS samples, in nanoseconds.

Type: int64[n]

This tag may appear in:

ACameraMetadata from ACameraCaptureSession_captureCallback_result callbacks
The array contains the timestamps of OIS samples. The timestamps are in the same timebase as and comparable to ACAMERA_SENSOR_TIMESTAMP.

See also: ACAMERA_SENSOR_TIMESTAMP

ACAMERA_STATISTICS_OIS_X_SHIFTS	
An array of shifts of OIS samples, in x direction.

Type: float[n]

This tag may appear in:

ACameraMetadata from ACameraCaptureSession_captureCallback_result callbacks
The array contains the amount of shifts in x direction, in pixels, based on OIS samples. A positive value is a shift from left to right in the pre-correction active array coordinate system. For example, if the optical center is (1000, 500) in pre-correction active array coordinates, a shift of (3, 0) puts the new optical center at (1003, 500).

The number of shifts must match the number of timestamps in ACAMERA_STATISTICS_OIS_TIMESTAMPS.

The OIS samples are not affected by whether lens distortion correction is enabled (on supporting devices). They are always reported in pre-correction active array coordinates, since the scaling of OIS shifts would depend on the specific spot on the sensor the shift is needed.

See also: ACAMERA_STATISTICS_OIS_TIMESTAMPS

ACAMERA_STATISTICS_OIS_Y_SHIFTS	
An array of shifts of OIS samples, in y direction.

Type: float[n]

This tag may appear in:

ACameraMetadata from ACameraCaptureSession_captureCallback_result callbacks
The array contains the amount of shifts in y direction, in pixels, based on OIS samples. A positive value is a shift from top to bottom in pre-correction active array coordinate system. For example, if the optical center is (1000, 500) in active array coordinates, a shift of (0, 5) puts the new optical center at (1000, 505).

The number of shifts must match the number of timestamps in ACAMERA_STATISTICS_OIS_TIMESTAMPS.

The OIS samples are not affected by whether lens distortion correction is enabled (on supporting devices). They are always reported in pre-correction active array coordinates, since the scaling of OIS shifts would depend on the specific spot on the sensor the shift is needed.

See also: ACAMERA_STATISTICS_OIS_TIMESTAMPS

ACAMERA_STATISTICS_SCENE_FLICKER	
The camera device estimated scene illumination lighting frequency.

Type: byte (acamera_metadata_enum_android_statistics_scene_flicker_t)

This tag may appear in:

ACameraMetadata from ACameraCaptureSession_captureCallback_result callbacks
Many light sources, such as most fluorescent lights, flicker at a rate that depends on the local utility power standards. This flicker must be accounted for by auto-exposure routines to avoid artifacts in captured images. The camera device uses this entry to tell the application what the scene illuminant frequency is.

When manual exposure control is enabled (ACAMERA_CONTROL_AE_MODE == OFF or ACAMERA_CONTROL_MODE == OFF), the ACAMERA_CONTROL_AE_ANTIBANDING_MODE doesn't perform antibanding, and the application can ensure it selects exposure times that do not cause banding issues by looking into this metadata field. See ACAMERA_CONTROL_AE_ANTIBANDING_MODE for more details.

Reports NONE if there doesn't appear to be flickering illumination.

See also: ACAMERA_CONTROL_AE_ANTIBANDING_MODE See also: ACAMERA_CONTROL_AE_MODE See also: ACAMERA_CONTROL_MODE

ACAMERA_SYNC_END	
ACAMERA_SYNC_FRAME_NUMBER	
The frame number corresponding to the last request with which the output result (metadata + buffers) has been fully synchronized.

Type: int64 (acamera_metadata_enum_android_sync_frame_number_t)

This tag may appear in:

ACameraMetadata from ACameraCaptureSession_captureCallback_result callbacks
When a request is submitted to the camera device, there is usually a delay of several frames before the controls get applied. A camera device may either choose to account for this delay by implementing a pipeline and carefully submit well-timed atomic control updates, or it may start streaming control changes that span over several frame boundaries.

In the latter case, whenever a request's settings change relative to the previous submitted request, the full set of changes may take multiple frame durations to fully take effect. Some settings may take effect sooner (in less frame durations) than others.

While a set of control changes are being propagated, this value will be CONVERGING.

Once it is fully known that a set of control changes have been finished propagating, and the resulting updated control settings have been read back by the camera device, this value will be set to a non-negative frame number (corresponding to the request to which the results have synchronized to).

Older camera device implementations may not have a way to detect when all camera controls have been applied, and will always set this value to UNKNOWN.

FULL capability devices will always have this value set to the frame number of the request corresponding to this result.

Further details:

Whenever a request differs from the last request, any future results not yet returned may have this value set to CONVERGING (this could include any in-progress captures not yet returned by the camera device, for more details see pipeline considerations below).
Submitting a series of multiple requests that differ from the previous request (e.g. r1, r2, r3 s.t. r1 != r2 != r3) moves the new synchronization frame to the last non-repeating request (using the smallest frame number from the contiguous list of repeating requests).
Submitting the same request repeatedly will not change this value to CONVERGING, if it was already a non-negative value.
When this value changes to non-negative, that means that all of the metadata controls from the request have been applied, all of the metadata controls from the camera device have been read to the updated values (into the result), and all of the graphics buffers corresponding to this result are also synchronized to the request.
Pipeline considerations:

Submitting a request with updated controls relative to the previously submitted requests may also invalidate the synchronization state of all the results corresponding to currently in-flight requests.

In other words, results for this current request and up to ACAMERA_REQUEST_PIPELINE_MAX_DEPTH prior requests may have their ACAMERA_SYNC_FRAME_NUMBER change to CONVERGING.

See also: ACAMERA_REQUEST_PIPELINE_MAX_DEPTH See also: ACAMERA_SYNC_FRAME_NUMBER

ACAMERA_SYNC_MAX_LATENCY	
The maximum number of frames that can occur after a request (different than the previous) has been submitted, and before the result's state becomes synchronized.

Type: int32 (acamera_metadata_enum_android_sync_max_latency_t)

This tag may appear in:

ACameraMetadata from ACameraManager_getCameraCharacteristics
This defines the maximum distance (in number of metadata results), between the frame number of the request that has new controls to apply and the frame number of the result that has all the controls applied.

In other words this acts as an upper boundary for how many frames must occur before the camera device knows for a fact that the new submitted camera settings have been applied in outgoing frames.

ACAMERA_TONEMAP_AVAILABLE_TONE_MAP_MODES	
List of tonemapping modes for ACAMERA_TONEMAP_MODE that are supported by this camera device.

See also: ACAMERA_TONEMAP_MODE

Type: byte[n]

This tag may appear in:

ACameraMetadata from ACameraManager_getCameraCharacteristics
Camera devices that support the MANUAL_POST_PROCESSING capability will always contain at least one of below mode combinations:

CONTRAST_CURVE, FAST and HIGH_QUALITY
GAMMA_VALUE, PRESET_CURVE, FAST and HIGH_QUALITY
This includes all FULL level devices.

ACAMERA_TONEMAP_CURVE_BLUE	
Tonemapping / contrast / gamma curve for the blue channel, to use when ACAMERA_TONEMAP_MODE is CONTRAST_CURVE.

See also: ACAMERA_TONEMAP_MODE

Type: float[n*2]

This tag may appear in:

ACameraMetadata from ACameraCaptureSession_captureCallback_result callbacks
ACaptureRequest
See ACAMERA_TONEMAP_CURVE_RED for more details.

See also: ACAMERA_TONEMAP_CURVE_RED

ACAMERA_TONEMAP_CURVE_GREEN	
Tonemapping / contrast / gamma curve for the green channel, to use when ACAMERA_TONEMAP_MODE is CONTRAST_CURVE.

See also: ACAMERA_TONEMAP_MODE

Type: float[n*2]

This tag may appear in:

ACameraMetadata from ACameraCaptureSession_captureCallback_result callbacks
ACaptureRequest
See ACAMERA_TONEMAP_CURVE_RED for more details.

See also: ACAMERA_TONEMAP_CURVE_RED

ACAMERA_TONEMAP_CURVE_RED	
Tonemapping / contrast / gamma curve for the red channel, to use when ACAMERA_TONEMAP_MODE is CONTRAST_CURVE.

See also: ACAMERA_TONEMAP_MODE

Type: float[n*2]

This tag may appear in:

ACameraMetadata from ACameraCaptureSession_captureCallback_result callbacks
ACaptureRequest
Each channel's curve is defined by an array of control points:

ACAMERA_TONEMAP_CURVE_RED =
  [ P0in, P0out, P1in, P1out, P2in, P2out, P3in, P3out, ..., PNin, PNout ]
2 <= N <= ACAMERA_TONEMAP_MAX_CURVE_POINTS
These are sorted in order of increasing Pin; it is required that input values 0.0 and 1.0 are included in the list to define a complete mapping. For input values between control points, the camera device must linearly interpolate between the control points.

Each curve can have an independent number of points, and the number of points can be less than max (that is, the request doesn't have to always provide a curve with number of points equivalent to ACAMERA_TONEMAP_MAX_CURVE_POINTS).

For devices with MONOCHROME capability, all three channels must have the same set of control points.

A few examples, and their corresponding graphical mappings; these only specify the red channel and the precision is limited to 4 digits, for conciseness.

Linear mapping:

ACAMERA_TONEMAP_CURVE_RED = [ 0, 0, 1.0, 1.0 ]

Invert mapping:

ACAMERA_TONEMAP_CURVE_RED = [ 0, 1.0, 1.0, 0 ]

Gamma 1/2.2 mapping, with 16 control points:

ACAMERA_TONEMAP_CURVE_RED = [
  0.0000, 0.0000, 0.0667, 0.2920, 0.1333, 0.4002, 0.2000, 0.4812,
  0.2667, 0.5484, 0.3333, 0.6069, 0.4000, 0.6594, 0.4667, 0.7072,
  0.5333, 0.7515, 0.6000, 0.7928, 0.6667, 0.8317, 0.7333, 0.8685,
  0.8000, 0.9035, 0.8667, 0.9370, 0.9333, 0.9691, 1.0000, 1.0000 ]

Standard sRGB gamma mapping, per IEC 61966-2-1:1999, with 16 control points:

ACAMERA_TONEMAP_CURVE_RED = [
  0.0000, 0.0000, 0.0667, 0.2864, 0.1333, 0.4007, 0.2000, 0.4845,
  0.2667, 0.5532, 0.3333, 0.6125, 0.4000, 0.6652, 0.4667, 0.7130,
  0.5333, 0.7569, 0.6000, 0.7977, 0.6667, 0.8360, 0.7333, 0.8721,
  0.8000, 0.9063, 0.8667, 0.9389, 0.9333, 0.9701, 1.0000, 1.0000 ]

See also: ACAMERA_TONEMAP_CURVE_RED See also: ACAMERA_TONEMAP_MAX_CURVE_POINTS

ACAMERA_TONEMAP_END	
ACAMERA_TONEMAP_GAMMA	
Tonemapping curve to use when ACAMERA_TONEMAP_MODE is GAMMA_VALUE

See also: ACAMERA_TONEMAP_MODE

Type: float

This tag may appear in:

ACameraMetadata from ACameraCaptureSession_captureCallback_result callbacks
ACaptureRequest
The tonemap curve will be defined the following formula:

OUT = pow(IN, 1.0 / gamma)
where IN and OUT is the input pixel value scaled to range [0.0, 1.0], pow is the power function and gamma is the gamma value specified by this key.

The same curve will be applied to all color channels. The camera device may clip the input gamma value to its supported range. The actual applied value will be returned in capture result.

The valid range of gamma value varies on different devices, but values within [1.0, 5.0] are guaranteed not to be clipped.

ACAMERA_TONEMAP_MAX_CURVE_POINTS	
Maximum number of supported points in the tonemap curve that can be used for android.tonemap.curve.

Type: int32

This tag may appear in:

ACameraMetadata from ACameraManager_getCameraCharacteristics
If the actual number of points provided by the application (in ACAMERA_TONEMAPCURVE_*) is less than this maximum, the camera device will resample the curve to its internal representation, using linear interpolation.

The output curves in the result metadata may have a different number of points than the input curves, and will represent the actual hardware curves used as closely as possible when linearly interpolated.

ACAMERA_TONEMAP_MODE	
High-level global contrast/gamma/tonemapping control.

Type: byte (acamera_metadata_enum_android_tonemap_mode_t)

This tag may appear in:

ACameraMetadata from ACameraCaptureSession_captureCallback_result callbacks
ACaptureRequest
When switching to an application-defined contrast curve by setting ACAMERA_TONEMAP_MODE to CONTRAST_CURVE, the curve is defined per-channel with a set of (in, out) points that specify the mapping from input high-bit-depth pixel value to the output low-bit-depth value. Since the actual pixel ranges of both input and output may change depending on the camera pipeline, the values are specified by normalized floating-point numbers.

More-complex color mapping operations such as 3D color look-up tables, selective chroma enhancement, or other non-linear color transforms will be disabled when ACAMERA_TONEMAP_MODE is CONTRAST_CURVE.

When using either FAST or HIGH_QUALITY, the camera device will emit its own tonemap curve in android.tonemap.curve. These values are always available, and as close as possible to the actually used nonlinear/nonglobal transforms.

If a request is sent with CONTRAST_CURVE with the camera device's provided curve in FAST or HIGH_QUALITY, the image's tonemap will be roughly the same.

See also: ACAMERA_TONEMAP_MODE

ACAMERA_TONEMAP_PRESET_CURVE	
Tonemapping curve to use when ACAMERA_TONEMAP_MODE is PRESET_CURVE

See also: ACAMERA_TONEMAP_MODE

Type: byte (acamera_metadata_enum_android_tonemap_preset_curve_t)

This tag may appear in:

ACameraMetadata from ACameraCaptureSession_captureCallback_result callbacks
ACaptureRequest
The tonemap curve will be defined by specified standard.

sRGB (approximated by 16 control points):


Rec. 709 (approximated by 16 control points):


Note that above figures show a 16 control points approximation of preset curves. Camera devices may apply a different approximation to the curve.

camera_status_t
 camera_status_t
Camera status enum types.

Properties
ACAMERA_ERROR_BASE	
ACAMERA_ERROR_CAMERA_DEVICE	
Camera operation has failed and the camera device has encountered a fatal error and needs to be re-opened before it can be used again.

ACAMERA_ERROR_CAMERA_DISABLED	
The camera is disabled due to a device policy, and cannot be opened.

ACAMERA_ERROR_CAMERA_DISCONNECTED	
Camera operation has failed because the camera device has been closed, possibly because a higher-priority client has taken ownership of the camera device.

ACAMERA_ERROR_CAMERA_IN_USE	
Camera device is being used by another higher priority camera API client.

ACAMERA_ERROR_CAMERA_SERVICE	
Camera operation has failed and the camera service has encountered a fatal error.

The Android device may need to be shut down and restarted to restore camera function, or there may be a persistent hardware problem.

An attempt at recovery may be possible by closing the ACameraDevice and the ACameraManager, and trying to acquire all resources again from scratch.

ACAMERA_ERROR_INVALID_OPERATION	
Camera operation has failed due to an invalid internal operation.

Usually this is due to a low-level problem that may resolve itself on retry

ACAMERA_ERROR_INVALID_PARAMETER	
Camera operation has failed due to an invalid parameter being passed to the method.

ACAMERA_ERROR_MAX_CAMERA_IN_USE	
The system-wide limit for number of open cameras or camera resources has been reached, and more camera devices cannot be opened until previous instances are closed.

ACAMERA_ERROR_METADATA_NOT_FOUND	
Camera operation has failed due to the requested metadata tag cannot be found in input ACameraMetadata or ACaptureRequest.

ACAMERA_ERROR_NOT_ENOUGH_MEMORY	
Camera operation has failed due to insufficient memory.

ACAMERA_ERROR_PERMISSION_DENIED	
The application does not have permission to open camera.

ACAMERA_ERROR_SESSION_CLOSED	
The ACameraCaptureSession has been closed and cannnot perform any operation other than ACameraCaptureSession_close.

ACAMERA_ERROR_STREAM_CONFIGURE_FAIL	
Camera device does not support the stream configuration provided by application in ACameraDevice_createCaptureSession or ACameraDevice_isSessionConfigurationSupported.

ACAMERA_ERROR_UNKNOWN	
Camera operation has failed due to an unspecified cause.

ACAMERA_ERROR_UNSUPPORTED_OPERATION	
The operation is not supported by the camera device.

ACAMERA_OK	
Camera operation has succeeded.

Typedefs
ACameraCaptureFailure
struct ACameraCaptureFailure ACameraCaptureFailure
Struct to describe a capture failure.

ACameraCaptureSession
struct ACameraCaptureSession ACameraCaptureSession
ACameraCaptureSession is an opaque type that manages frame captures of a camera device.

A pointer can be obtained using ACameraDevice_createCaptureSession method.

ACameraCaptureSession_captureCallback_bufferLost
void(* ACameraCaptureSession_captureCallback_bufferLost)(void *context, ACameraCaptureSession *session, ACaptureRequest *request, ACameraWindowType *window, int64_t frameNumber)
The definition of camera buffer lost callback.

Details
Parameters	
context	
The optional application context provided by user in ACameraCaptureSession_captureCallbacks.
session	
The camera capture session of interest.
request	
The capture request of interest. Note that this pointer points to a copy of capture request sent by application, so the address is different to what application sent but the content will match. This request will be freed by framework immediately after this callback returns.
window	
The ANativeWindow that the lost buffer would have been sent to.
frameNumber	
The frame number of the lost buffer.
ACameraCaptureSession_captureCallback_failed
void(* ACameraCaptureSession_captureCallback_failed)(void *context, ACameraCaptureSession *session, ACaptureRequest *request, ACameraCaptureFailure *failure)
The definition of camera capture failure callback.

Details
Parameters	
context	
The optional application context provided by user in ACameraCaptureSession_captureCallbacks.
session	
The camera capture session of interest.
request	
The capture request of interest. Note that this pointer points to a copy of capture request sent by application, so the address is different to what application sent but the content will match. This request will be freed by framework immediately after this callback returns.
failure	
The ACameraCaptureFailure desribes the capture failure. The memory is managed by camera framework. Do not access this pointer after this callback returns.
ACameraCaptureSession_captureCallback_result
void(* ACameraCaptureSession_captureCallback_result)(void *context, ACameraCaptureSession *session, ACaptureRequest *request, const ACameraMetadata *result)
The definition of camera capture progress/result callback.

Details
Parameters	
context	
The optional application context provided by user in ACameraCaptureSession_captureCallbacks.
session	
The camera capture session of interest.
request	
The capture request of interest. Note that this pointer points to a copy of capture request sent by application, so the address is different to what application sent but the content will match. This request will be freed by framework immediately after this callback returns.
result	
The capture result metadata reported by camera device. The memory is managed by camera framework. Do not access this pointer after this callback returns.
ACameraCaptureSession_captureCallback_sequenceAbort
void(* ACameraCaptureSession_captureCallback_sequenceAbort)(void *context, ACameraCaptureSession *session, int sequenceId)
The definition of camera sequence aborted callback.

Details
Parameters	
context	
The optional application context provided by user in ACameraCaptureSession_captureCallbacks.
session	
The camera capture session of interest.
sequenceId	
The capture sequence ID of the aborted sequence.
ACameraCaptureSession_captureCallback_sequenceEnd
void(* ACameraCaptureSession_captureCallback_sequenceEnd)(void *context, ACameraCaptureSession *session, int sequenceId, int64_t frameNumber)
The definition of camera sequence end callback.

Details
Parameters	
context	
The optional application context provided by user in ACameraCaptureSession_captureCallbacks.
session	
The camera capture session of interest.
sequenceId	
The capture sequence ID of the finished sequence.
frameNumber	
The frame number of the last frame of this sequence.
ACameraCaptureSession_captureCallback_start
void(* ACameraCaptureSession_captureCallback_start)(void *context, ACameraCaptureSession *session, const ACaptureRequest *request, int64_t timestamp)
The definition of camera capture start callback.

Details
Parameters	
context	
The optional application context provided by user in ACameraCaptureSession_captureCallbacks.
session	
The camera capture session of interest.
request	
The capture request that is starting. Note that this pointer points to a copy of capture request sent by application, so the address is different to what application sent but the content will match. This request will be freed by framework immediately after this callback returns.
timestamp	
The timestamp when the capture is started. This timestmap will match ACAMERA_SENSOR_TIMESTAMP of the ACameraMetadata in ACameraCaptureSession_captureCallbacks#onCaptureCompleted callback.
ACameraCaptureSession_captureCallback_startV2
void(* ACameraCaptureSession_captureCallback_startV2)(void *context, ACameraCaptureSession *session, const ACaptureRequest *request, int64_t timestamp, int64_t frameNumber)
The definition of camera capture start callback.

The same as ACameraCaptureSession_captureCallbacks#onCaptureStarted, except that it has the frame number of the capture as well.

Details
Parameters	
context	
The optional application context provided by user in ACameraCaptureSession_captureCallbacks.
session	
The camera capture session of interest.
request	
The capture request that is starting. Note that this pointer points to a copy of capture request sent by application, so the address is different to what application sent but the content will match. This request will be freed by framework immediately after this callback returns.
timestamp	
The timestamp when the capture is started. This timestamp will match ACAMERA_SENSOR_TIMESTAMP of the ACameraMetadata in ACameraCaptureSession_captureCallbacks#onCaptureCompleted callback.
frameNumber	
the frame number of the capture started
ACameraCaptureSession_captureCallbacks
struct ACameraCaptureSession_captureCallbacks ACameraCaptureSession_captureCallbacks
ACaptureCaptureSession_captureCallbacks structure used in ACameraCaptureSession_capture and ACameraCaptureSession_setRepeatingRequest.

ACameraCaptureSession_captureCallbacksV2
struct ACameraCaptureSession_captureCallbacksV2 ACameraCaptureSession_captureCallbacksV2
This has the same functionality as ACameraCaptureSession_captureCallbacks, with the exception that captureCallback_startV2 callback is used, instead of captureCallback_start, to support retrieving the frame number.

ACameraCaptureSession_logicalCamera_captureCallback_failed
void(* ACameraCaptureSession_logicalCamera_captureCallback_failed)(void *context, ACameraCaptureSession *session, ACaptureRequest *request, ALogicalCameraCaptureFailure *failure)
The definition of logical camera capture failure callback.

Details
Parameters	
context	
The optional application context provided by user in ACameraCaptureSession_captureCallbacks.
session	
The camera capture session of interest.
request	
The capture request of interest. Note that this pointer points to a copy of capture request sent by application, so the address is different to what application sent but the content will match. This request will be freed by framework immediately after this callback returns.
failure	
The ALogicalCameraCaptureFailure desribes the capture failure. The memory is managed by camera framework. Do not access this pointer after this callback returns.
ACameraCaptureSession_logicalCamera_captureCallback_result
void(* ACameraCaptureSession_logicalCamera_captureCallback_result)(void *context, ACameraCaptureSession *session, ACaptureRequest *request, const ACameraMetadata *result, size_t physicalResultCount, const char **physicalCameraIds, const ACameraMetadata **physicalResults)
The definition of final capture result callback with logical multi-camera support.

This has the same functionality as final ACameraCaptureSession_captureCallback_result, with added ability to return physical camera result metadata within a logical multi-camera.

For a logical multi-camera, this function will be called with the Id and result metadata of the underlying physical cameras, which the corresponding capture request contains targets for. If the capture request doesn't contain targets specific to any physical camera, or the current camera device isn't a logical multi-camera, physicalResultCount will be 0.

Details
Parameters	
context	
The optional application context provided by user in ACameraCaptureSession_captureCallbacks.
session	
The camera capture session of interest.
request	
The capture request of interest. Note that this pointer points to a copy of capture request sent by application, so the address is different to what application sent but the content will match. This request will be freed by framework immediately after this callback returns.
result	
The capture result metadata reported by camera device. The memory is managed by camera framework. Do not access this pointer after this callback returns.
physicalResultCount	
The number of physical camera result metadata
physicalCameraIds	
The array of physical camera IDs on which the physical result metadata are reported.
physicalResults	
The array of capture result metadata reported by the physical camera devices.
ACameraCaptureSession_logicalCamera_captureCallbacks
struct ACameraCaptureSession_logicalCamera_captureCallbacks ACameraCaptureSession_logicalCamera_captureCallbacks
This has the same functionality as ACameraCaptureSession_captureCallbacks, with the exception that an onLogicalCameraCaptureCompleted callback is used, instead of onCaptureCompleted, to support logical multi-camera.

ACameraCaptureSession_logicalCamera_captureCallbacksV2
struct ACameraCaptureSession_logicalCamera_captureCallbacksV2 ACameraCaptureSession_logicalCamera_captureCallbacksV2
This has the same functionality as ACameraCaptureSession_logicalCamera_captureCallbacks, with the exception that an captureCallback_startV2 callback is used, instead of captureCallback_start, to support retrieving frame number.

ACameraCaptureSession_stateCallback
void(* ACameraCaptureSession_stateCallback)(void *context, ACameraCaptureSession *session)
The definition of camera capture session state callback.

Details
Parameters	
context	
The optional application context provided by user in ACameraCaptureSession_stateCallbacks.
session	
The camera capture session whose state is changing.
ACameraCaptureSession_stateCallbacks
struct ACameraCaptureSession_stateCallbacks ACameraCaptureSession_stateCallbacks
Capture session state callbacks used in ACameraDevice_createCaptureSession and ACameraDevice_createCaptureSessionWithSessionParameters.

ACameraDevice
struct ACameraDevice ACameraDevice
ACameraDevice is opaque type that provides access to a camera device.

A pointer can be obtained using ACameraManager_openCamera method.

ACameraDevice
struct ACameraDevice ACameraDevice
ACameraDevice is opaque type that provides access to a camera device.

A pointer can be obtained using ACameraManager_openCamera method.

ACameraDevice_ErrorStateCallback
void(* ACameraDevice_ErrorStateCallback)(void *context, ACameraDevice *device, int error)
Camera device error state callbacks to be used in ACameraDevice_StateCallbacks.

See also: ERROR_CAMERA_IN_USE See also: ERROR_MAX_CAMERAS_IN_USE See also: ERROR_CAMERA_DISABLED See also: ERROR_CAMERA_DEVICE See also: ERROR_CAMERA_SERVICE

Details
Parameters	
context	
The optional context in ACameraDevice_StateCallbacks will be passed to this callback.
device	
The ACameraDevice that is being disconnected.
error	
The error code describes the cause of this error callback. See the folowing links for more detail.
ACameraDevice_StateCallback
void(* ACameraDevice_StateCallback)(void *context, ACameraDevice *device)
Camera device state callbacks to be used in ACameraDevice_StateCallbacks.

Details
Parameters	
context	
The optional context in ACameraDevice_StateCallbacks will be passed to this callback.
device	
The ACameraDevice that is being disconnected.
ACameraDevice_StateCallbacks
struct ACameraDevice_StateCallbacks ACameraDevice_StateCallbacks
Applications' callbacks for camera device state changes, register with ACameraManager_openCamera.

ACameraDevice_stateCallbacks
ACameraDevice_StateCallbacks ACameraDevice_stateCallbacks
For backward compatiblity.

ACameraIdList
struct ACameraIdList ACameraIdList
Struct to hold list of camera device Ids.

This can refer to either the Ids of connected camera devices returned from ACameraManager_getCameraIdList, or the physical camera Ids passed into ACameraDevice_createCaptureRequest_withPhysicalIds.

ACameraManager
struct ACameraManager ACameraManager
ACameraManager is opaque type that provides access to camera service.

A pointer can be obtained using ACameraManager_create method.

ACameraManager_AccessPrioritiesChangedCallback
void(* ACameraManager_AccessPrioritiesChangedCallback)(void *context)
Definition of camera access permission change callback.

Notification that camera access priorities have changed and the camera may now be openable. An application that was previously denied camera access due to a higher-priority user already using the camera, or that was disconnected from an active camera session due to a higher-priority user trying to open the camera, should try to open the camera again if it still wants to use it. Note that multiple applications may receive this callback at the same time, and only one of them will succeed in opening the camera in practice, depending on exact access priority levels and timing. This method is useful in cases where multiple applications may be in the resumed state at the same time, and the user switches focus between them, or if the current camera-using application moves between full-screen and Picture-in-Picture (PiP) states. In such cases, the camera available/unavailable callbacks will not be invoked, but another application may now have higher priority for camera access than the current camera-using application.

Details
Parameters	
context	
The optional application context provided by user in ACameraManager_AvailabilityListener.
ACameraManager_AvailabilityCallback
void(* ACameraManager_AvailabilityCallback)(void *context, const char *cameraId)
Definition of camera availability callbacks.

Details
Parameters	
context	
The optional application context provided by user in ACameraManager_AvailabilityCallbacks.
cameraId	
The ID of the camera device whose availability is changing. The memory of this argument is owned by camera framework and will become invalid immediately after this callback returns.
ACameraManager_AvailabilityCallbacks
struct ACameraManager_AvailabilityListener ACameraManager_AvailabilityCallbacks
A listener for camera devices becoming available or unavailable to open.

Cameras become available when they are no longer in use, or when a new removable camera is connected. They become unavailable when some application or service starts using a camera, or when a removable camera is disconnected.

See also: ACameraManager_registerAvailabilityCallback

ACameraManager_ExtendedAvailabilityCallbacks
struct ACameraManager_ExtendedAvailabilityListener ACameraManager_ExtendedAvailabilityCallbacks
A listener for camera devices becoming available/unavailable to open or when the camera access permissions change.

Cameras become available when they are no longer in use, or when a new removable camera is connected. They become unavailable when some application or service starts using a camera, or when a removable camera is disconnected.

See also: ACameraManager_registerExtendedAvailabilityCallback

ACameraManager_PhysicalCameraAvailabilityCallback
void(* ACameraManager_PhysicalCameraAvailabilityCallback)(void *context, const char *cameraId, const char *physicalCameraId)
Definition of physical camera availability callbacks.

Details
Parameters	
context	
The optional application context provided by user in ACameraManager_AvailabilityCallbacks.
cameraId	
The ID of the logical multi-camera device whose physical camera status is changing. The memory of this argument is owned by camera framework and will become invalid immediately after this callback returns.
physicalCameraId	
The ID of the physical camera device whose status is changing. The memory of this argument is owned by camera framework and will become invalid immediately after this callback returns.
ACameraMetadata
struct ACameraMetadata ACameraMetadata
ACameraMetadata is opaque type that provides access to read-only camera metadata like camera characteristics (via ACameraManager_getCameraCharacteristics) or capture results (via ACameraCaptureSession_captureCallback_result).

ACameraMetadata_const_entry
struct ACameraMetadata_const_entry ACameraMetadata_const_entry
A single read-only camera metadata entry.

Each entry is an array of values, though many metadata fields may only have 1 entry in the array.

ACameraMetadata_entry
struct ACameraMetadata_entry ACameraMetadata_entry
A single camera metadata entry.

Each entry is an array of values, though many metadata fields may only have 1 entry in the array.

ACameraMetadata_rational
struct ACameraMetadata_rational ACameraMetadata_rational
Definition of rational data type in ACameraMetadata.

ACameraOutputTarget
struct ACameraOutputTarget ACameraOutputTarget
Container for a single output target.

ACameraOutputTargets
struct ACameraOutputTargets ACameraOutputTargets
Container for output targets.

ACameraWindowType
ANativeWindow ACameraWindowType
This file defines the window type used by NDK and the VNDK variants of the camera2 NDK.

This enables us to share the api definition headers and avoid code duplication (since the VNDK variant doesn't use ANativeWindow unlike the NDK variant).

ACaptureRequest
struct ACaptureRequest ACaptureRequest
ACaptureRequest is an opaque type that contains settings and output targets needed to capture a single image from camera device.

ACaptureRequest contains the configuration for the capture hardware (sensor, lens, flash), the processing pipeline, the control algorithms, and the output buffers. Also contains the list of target ANativeWindows to send image data to for this capture.

ACaptureRequest is created by ACameraDevice_createCaptureRequest.

ACaptureRequest is given to ACameraCaptureSession_capture or ACameraCaptureSession_setRepeatingRequest to capture images from a camera.

Each request can specify a different subset of target ANativeWindows for the camera to send the captured data to. All the ANativeWindows used in a request must be part of the ANativeWindow list given to the last call to ACameraDevice_createCaptureSession, when the request is submitted to the session.

For example, a request meant for repeating preview might only include the ANativeWindow for the preview SurfaceView or SurfaceTexture, while a high-resolution still capture would also include a ANativeWindow from a AImageReader configured for high-resolution JPEG images.

See also: ACameraDevice_createCaptureRequest See also: ACameraCaptureSession_capture See also: ACameraCaptureSession_setRepeatingRequest

ACaptureSessionOutput
struct ACaptureSessionOutput ACaptureSessionOutput
Opaque object for capture session output, use ACaptureSessionOutput_create or ACaptureSessionSharedOutput_create to create an instance.

ACaptureSessionOutputContainer
struct ACaptureSessionOutputContainer ACaptureSessionOutputContainer
Opaque object for CaptureSessionOutput container, use ACaptureSessionOutputContainer_create to create an instance.

ALogicalCameraCaptureFailure
struct ALogicalCameraCaptureFailure ALogicalCameraCaptureFailure
Struct to describe a logical camera capture failure.

acamera_metadata_enum_android_automotive_lens_facing_t
enum acamera_metadata_enum_acamera_automotive_lens_facing acamera_metadata_enum_android_automotive_lens_facing_t
acamera_metadata_enum_android_automotive_location_t
enum acamera_metadata_enum_acamera_automotive_location acamera_metadata_enum_android_automotive_location_t
acamera_metadata_enum_android_black_level_lock_t
enum acamera_metadata_enum_acamera_black_level_lock acamera_metadata_enum_android_black_level_lock_t
acamera_metadata_enum_android_color_correction_aberration_mode_t
enum acamera_metadata_enum_acamera_color_correction_aberration_mode acamera_metadata_enum_android_color_correction_aberration_mode_t
acamera_metadata_enum_android_color_correction_mode_t
enum acamera_metadata_enum_acamera_color_correction_mode acamera_metadata_enum_android_color_correction_mode_t
Enumeration definitions for the various entries that need them.

acamera_metadata_enum_android_control_ae_antibanding_mode_t
enum acamera_metadata_enum_acamera_control_ae_antibanding_mode acamera_metadata_enum_android_control_ae_antibanding_mode_t
acamera_metadata_enum_android_control_ae_lock_available_t
enum acamera_metadata_enum_acamera_control_ae_lock_available acamera_metadata_enum_android_control_ae_lock_available_t
acamera_metadata_enum_android_control_ae_lock_t
enum acamera_metadata_enum_acamera_control_ae_lock acamera_metadata_enum_android_control_ae_lock_t
acamera_metadata_enum_android_control_ae_mode_t
enum acamera_metadata_enum_acamera_control_ae_mode acamera_metadata_enum_android_control_ae_mode_t
acamera_metadata_enum_android_control_ae_precapture_trigger_t
enum acamera_metadata_enum_acamera_control_ae_precapture_trigger acamera_metadata_enum_android_control_ae_precapture_trigger_t
acamera_metadata_enum_android_control_ae_state_t
enum acamera_metadata_enum_acamera_control_ae_state acamera_metadata_enum_android_control_ae_state_t
acamera_metadata_enum_android_control_af_mode_t
enum acamera_metadata_enum_acamera_control_af_mode acamera_metadata_enum_android_control_af_mode_t
acamera_metadata_enum_android_control_af_scene_change_t
enum acamera_metadata_enum_acamera_control_af_scene_change acamera_metadata_enum_android_control_af_scene_change_t
acamera_metadata_enum_android_control_af_state_t
enum acamera_metadata_enum_acamera_control_af_state acamera_metadata_enum_android_control_af_state_t
acamera_metadata_enum_android_control_af_trigger_t
enum acamera_metadata_enum_acamera_control_af_trigger acamera_metadata_enum_android_control_af_trigger_t
acamera_metadata_enum_android_control_awb_lock_available_t
enum acamera_metadata_enum_acamera_control_awb_lock_available acamera_metadata_enum_android_control_awb_lock_available_t
acamera_metadata_enum_android_control_awb_lock_t
enum acamera_metadata_enum_acamera_control_awb_lock acamera_metadata_enum_android_control_awb_lock_t
acamera_metadata_enum_android_control_awb_mode_t
enum acamera_metadata_enum_acamera_control_awb_mode acamera_metadata_enum_android_control_awb_mode_t
acamera_metadata_enum_android_control_awb_state_t
enum acamera_metadata_enum_acamera_control_awb_state acamera_metadata_enum_android_control_awb_state_t
acamera_metadata_enum_android_control_capture_intent_t
enum acamera_metadata_enum_acamera_control_capture_intent acamera_metadata_enum_android_control_capture_intent_t
acamera_metadata_enum_android_control_effect_mode_t
enum acamera_metadata_enum_acamera_control_effect_mode acamera_metadata_enum_android_control_effect_mode_t
acamera_metadata_enum_android_control_enable_zsl_t
enum acamera_metadata_enum_acamera_control_enable_zsl acamera_metadata_enum_android_control_enable_zsl_t
acamera_metadata_enum_android_control_extended_scene_mode_t
enum acamera_metadata_enum_acamera_control_extended_scene_mode acamera_metadata_enum_android_control_extended_scene_mode_t
acamera_metadata_enum_android_control_mode_t
enum acamera_metadata_enum_acamera_control_mode acamera_metadata_enum_android_control_mode_t
acamera_metadata_enum_android_control_scene_mode_t
enum acamera_metadata_enum_acamera_control_scene_mode acamera_metadata_enum_android_control_scene_mode_t
acamera_metadata_enum_android_control_video_stabilization_mode_t
enum acamera_metadata_enum_acamera_control_video_stabilization_mode acamera_metadata_enum_android_control_video_stabilization_mode_t
acamera_metadata_enum_android_depth_available_depth_stream_configurations_maximum_resolution_t
enum acamera_metadata_enum_acamera_depth_available_depth_stream_configurations_maximum_resolution acamera_metadata_enum_android_depth_available_depth_stream_configurations_maximum_resolution_t
acamera_metadata_enum_android_depth_available_depth_stream_configurations_t
enum acamera_metadata_enum_acamera_depth_available_depth_stream_configurations acamera_metadata_enum_android_depth_available_depth_stream_configurations_t
acamera_metadata_enum_android_depth_available_dynamic_depth_stream_configurations_maximum_resolution_t
enum acamera_metadata_enum_acamera_depth_available_dynamic_depth_stream_configurations_maximum_resolution acamera_metadata_enum_android_depth_available_dynamic_depth_stream_configurations_maximum_resolution_t
acamera_metadata_enum_android_depth_available_dynamic_depth_stream_configurations_t
enum acamera_metadata_enum_acamera_depth_available_dynamic_depth_stream_configurations acamera_metadata_enum_android_depth_available_dynamic_depth_stream_configurations_t
acamera_metadata_enum_android_depth_depth_is_exclusive_t
enum acamera_metadata_enum_acamera_depth_depth_is_exclusive acamera_metadata_enum_android_depth_depth_is_exclusive_t
acamera_metadata_enum_android_distortion_correction_mode_t
enum acamera_metadata_enum_acamera_distortion_correction_mode acamera_metadata_enum_android_distortion_correction_mode_t
acamera_metadata_enum_android_edge_mode_t
enum acamera_metadata_enum_acamera_edge_mode acamera_metadata_enum_android_edge_mode_t
acamera_metadata_enum_android_flash_info_available_t
enum acamera_metadata_enum_acamera_flash_info_available acamera_metadata_enum_android_flash_info_available_t
acamera_metadata_enum_android_flash_mode_t
enum acamera_metadata_enum_acamera_flash_mode acamera_metadata_enum_android_flash_mode_t
acamera_metadata_enum_android_flash_state_t
enum acamera_metadata_enum_acamera_flash_state acamera_metadata_enum_android_flash_state_t
acamera_metadata_enum_android_heic_available_heic_stream_configurations_maximum_resolution_t
enum acamera_metadata_enum_acamera_heic_available_heic_stream_configurations_maximum_resolution acamera_metadata_enum_android_heic_available_heic_stream_configurations_maximum_resolution_t
acamera_metadata_enum_android_heic_available_heic_stream_configurations_t
enum acamera_metadata_enum_acamera_heic_available_heic_stream_configurations acamera_metadata_enum_android_heic_available_heic_stream_configurations_t
acamera_metadata_enum_android_hot_pixel_mode_t
enum acamera_metadata_enum_acamera_hot_pixel_mode acamera_metadata_enum_android_hot_pixel_mode_t
acamera_metadata_enum_android_info_supported_hardware_level_t
enum acamera_metadata_enum_acamera_info_supported_hardware_level acamera_metadata_enum_android_info_supported_hardware_level_t
acamera_metadata_enum_android_lens_facing_t
enum acamera_metadata_enum_acamera_lens_facing acamera_metadata_enum_android_lens_facing_t
acamera_metadata_enum_android_lens_info_focus_distance_calibration_t
enum acamera_metadata_enum_acamera_lens_info_focus_distance_calibration acamera_metadata_enum_android_lens_info_focus_distance_calibration_t
acamera_metadata_enum_android_lens_optical_stabilization_mode_t
enum acamera_metadata_enum_acamera_lens_optical_stabilization_mode acamera_metadata_enum_android_lens_optical_stabilization_mode_t
acamera_metadata_enum_android_lens_pose_reference_t
enum acamera_metadata_enum_acamera_lens_pose_reference acamera_metadata_enum_android_lens_pose_reference_t
acamera_metadata_enum_android_lens_state_t
enum acamera_metadata_enum_acamera_lens_state acamera_metadata_enum_android_lens_state_t
acamera_metadata_enum_android_logical_multi_camera_sensor_sync_type_t
enum acamera_metadata_enum_acamera_logical_multi_camera_sensor_sync_type acamera_metadata_enum_android_logical_multi_camera_sensor_sync_type_t
acamera_metadata_enum_android_noise_reduction_mode_t
enum acamera_metadata_enum_acamera_noise_reduction_mode acamera_metadata_enum_android_noise_reduction_mode_t
acamera_metadata_enum_android_request_available_capabilities_t
enum acamera_metadata_enum_acamera_request_available_capabilities acamera_metadata_enum_android_request_available_capabilities_t
acamera_metadata_enum_android_request_available_dynamic_range_profiles_map_t
enum acamera_metadata_enum_acamera_request_available_dynamic_range_profiles_map acamera_metadata_enum_android_request_available_dynamic_range_profiles_map_t
acamera_metadata_enum_android_scaler_available_recommended_stream_configurations_t
enum acamera_metadata_enum_acamera_scaler_available_recommended_stream_configurations acamera_metadata_enum_android_scaler_available_recommended_stream_configurations_t
acamera_metadata_enum_android_scaler_available_stream_configurations_maximum_resolution_t
enum acamera_metadata_enum_acamera_scaler_available_stream_configurations_maximum_resolution acamera_metadata_enum_android_scaler_available_stream_configurations_maximum_resolution_t
acamera_metadata_enum_android_scaler_available_stream_configurations_t
enum acamera_metadata_enum_acamera_scaler_available_stream_configurations acamera_metadata_enum_android_scaler_available_stream_configurations_t
acamera_metadata_enum_android_scaler_available_stream_use_cases_t
enum acamera_metadata_enum_acamera_scaler_available_stream_use_cases acamera_metadata_enum_android_scaler_available_stream_use_cases_t
acamera_metadata_enum_android_scaler_cropping_type_t
enum acamera_metadata_enum_acamera_scaler_cropping_type acamera_metadata_enum_android_scaler_cropping_type_t
acamera_metadata_enum_android_scaler_multi_resolution_stream_supported_t
enum acamera_metadata_enum_acamera_scaler_multi_resolution_stream_supported acamera_metadata_enum_android_scaler_multi_resolution_stream_supported_t
acamera_metadata_enum_android_scaler_physical_camera_multi_resolution_stream_configurations_t
enum acamera_metadata_enum_acamera_scaler_physical_camera_multi_resolution_stream_configurations acamera_metadata_enum_android_scaler_physical_camera_multi_resolution_stream_configurations_t
acamera_metadata_enum_android_scaler_rotate_and_crop_t
enum acamera_metadata_enum_acamera_scaler_rotate_and_crop acamera_metadata_enum_android_scaler_rotate_and_crop_t
acamera_metadata_enum_android_sensor_info_color_filter_arrangement_t
enum acamera_metadata_enum_acamera_sensor_info_color_filter_arrangement acamera_metadata_enum_android_sensor_info_color_filter_arrangement_t
acamera_metadata_enum_android_sensor_info_lens_shading_applied_t
enum acamera_metadata_enum_acamera_sensor_info_lens_shading_applied acamera_metadata_enum_android_sensor_info_lens_shading_applied_t
acamera_metadata_enum_android_sensor_info_timestamp_source_t
enum acamera_metadata_enum_acamera_sensor_info_timestamp_source acamera_metadata_enum_android_sensor_info_timestamp_source_t
acamera_metadata_enum_android_sensor_pixel_mode_t
enum acamera_metadata_enum_acamera_sensor_pixel_mode acamera_metadata_enum_android_sensor_pixel_mode_t
acamera_metadata_enum_android_sensor_raw_binning_factor_used_t
enum acamera_metadata_enum_acamera_sensor_raw_binning_factor_used acamera_metadata_enum_android_sensor_raw_binning_factor_used_t
acamera_metadata_enum_android_sensor_reference_illuminant1_t
enum acamera_metadata_enum_acamera_sensor_reference_illuminant1 acamera_metadata_enum_android_sensor_reference_illuminant1_t
acamera_metadata_enum_android_sensor_test_pattern_mode_t
enum acamera_metadata_enum_acamera_sensor_test_pattern_mode acamera_metadata_enum_android_sensor_test_pattern_mode_t
acamera_metadata_enum_android_shading_mode_t
enum acamera_metadata_enum_acamera_shading_mode acamera_metadata_enum_android_shading_mode_t
acamera_metadata_enum_android_statistics_face_detect_mode_t
enum acamera_metadata_enum_acamera_statistics_face_detect_mode acamera_metadata_enum_android_statistics_face_detect_mode_t
acamera_metadata_enum_android_statistics_hot_pixel_map_mode_t
enum acamera_metadata_enum_acamera_statistics_hot_pixel_map_mode acamera_metadata_enum_android_statistics_hot_pixel_map_mode_t
acamera_metadata_enum_android_statistics_lens_shading_map_mode_t
enum acamera_metadata_enum_acamera_statistics_lens_shading_map_mode acamera_metadata_enum_android_statistics_lens_shading_map_mode_t
acamera_metadata_enum_android_statistics_ois_data_mode_t
enum acamera_metadata_enum_acamera_statistics_ois_data_mode acamera_metadata_enum_android_statistics_ois_data_mode_t
acamera_metadata_enum_android_statistics_scene_flicker_t
enum acamera_metadata_enum_acamera_statistics_scene_flicker acamera_metadata_enum_android_statistics_scene_flicker_t
acamera_metadata_enum_android_sync_frame_number_t
enum acamera_metadata_enum_acamera_sync_frame_number acamera_metadata_enum_android_sync_frame_number_t
acamera_metadata_enum_android_sync_max_latency_t
enum acamera_metadata_enum_acamera_sync_max_latency acamera_metadata_enum_android_sync_max_latency_t
acamera_metadata_enum_android_tonemap_mode_t
enum acamera_metadata_enum_acamera_tonemap_mode acamera_metadata_enum_android_tonemap_mode_t
acamera_metadata_enum_android_tonemap_preset_curve_t
enum acamera_metadata_enum_acamera_tonemap_preset_curve acamera_metadata_enum_android_tonemap_preset_curve_t
acamera_metadata_section_start_t
enum acamera_metadata_section_start acamera_metadata_section_start_t
Hierarchy positions in enum space.

acamera_metadata_section_t
enum acamera_metadata_section acamera_metadata_section_t
acamera_metadata_tag_t
enum acamera_metadata_tag acamera_metadata_tag_t
Main enum for camera metadata tags.

Functions
ACameraCaptureSession_abortCaptures
camera_status_t ACameraCaptureSession_abortCaptures(
  ACameraCaptureSession *session
)
Discard all captures currently pending and in-progress as fast as possible.

The camera device will discard all of its current work as fast as possible. Some in-flight captures may complete successfully and call ACameraCaptureSession_captureCallbacks#onCaptureCompleted, while others will trigger their ACameraCaptureSession_captureCallbacks#onCaptureFailed callbacks. If a repeating request list is set, it will be cleared.

This method is the fastest way to switch the camera device to a new session with ACameraDevice_createCaptureSession, at the cost of discarding in-progress work. It must be called before the new session is created. Once all pending requests are either completed or thrown away, the ACameraCaptureSession_stateCallbacks#onReady callback will be called, if the session has not been closed. Otherwise, the ACameraCaptureSession_stateCallbacks#onClosed callback will be fired when a new session is created by the camera device and the previous session is being removed from memory.

Cancelling will introduce at least a brief pause in the stream of data from the camera device, since once the camera device is emptied, the first new request has to make it through the entire camera pipeline before new output buffers are produced.

This means that using ACameraCaptureSession_abortCaptures to simply remove pending requests is not recommended; it's best used for quickly switching output configurations, or for cancelling long in-progress requests (such as a multi-second capture).

Details
Parameters	
session	
the capture session of interest
Returns	
ACAMERA_OK if the method succeeds. captureSequenceId will be filled if it is not NULL.
ACAMERA_ERROR_INVALID_PARAMETER if session is NULL.
ACAMERA_ERROR_SESSION_CLOSED if the capture session has been closed
ACAMERA_ERROR_CAMERA_DISCONNECTED if the camera device is closed
ACAMERA_ERROR_CAMERA_DEVICE if the camera device encounters fatal error
ACAMERA_ERROR_CAMERA_SERVICE if the camera service encounters fatal error
ACAMERA_ERROR_UNKNOWN if the method fails for some other reasons
ACameraCaptureSession_capture
camera_status_t ACameraCaptureSession_capture(
  ACameraCaptureSession *session,
  ACameraCaptureSession_captureCallbacks *callbacks,
  int numRequests,
  ACaptureRequest **requests,
  int *captureSequenceId
)
Submit an array of requests to be captured in sequence as a burst in the minimum of time possible.

The burst will be captured in the minimum amount of time possible, and will not be interleaved with requests submitted by other capture or repeat calls.

Each capture produces one ACameraMetadata as a capture result and image buffers for one or more target ANativeWindows. The target ANativeWindows (set with ACaptureRequest_addTarget) must be a subset of the ANativeWindow provided when this capture session was created.

Details
Parameters	
session	
the capture session of interest
callbacks	
the ACameraCaptureSession_captureCallbacks to be associated this capture sequence. No capture callback will be fired if this is set to NULL.
numRequests	
number of requests in requests argument. Must be at least 1.
requests	
an array of ACaptureRequest to be captured. Length must be at least numRequests.
captureSequenceId	
the capture sequence ID associated with this capture method invocation will be stored here if this argument is not NULL and the method call succeeds. When this argument is set to NULL, the capture sequence ID will not be returned.
Returns	
ACAMERA_OK if the method succeeds. captureSequenceId will be filled if it is not NULL.
ACAMERA_ERROR_INVALID_PARAMETER if session or requests is NULL, or if numRequests < 1
ACAMERA_ERROR_SESSION_CLOSED if the capture session has been closed
ACAMERA_ERROR_CAMERA_DISCONNECTED if the camera device is closed
ACAMERA_ERROR_CAMERA_DEVICE if the camera device encounters fatal error
ACAMERA_ERROR_CAMERA_SERVICE if the camera service encounters fatal error
ACAMERA_ERROR_UNKNOWN if the method fails for some other reasons
ACameraCaptureSession_captureV2
camera_status_t ACameraCaptureSession_captureV2(
  ACameraCaptureSession *session,
  ACameraCaptureSession_captureCallbacksV2 *callbacks,
  int numRequests,
  ACaptureRequest **requests,
  int *captureSequenceId
)
This has the same functionality as ACameraCaptureSession_capture, with added support for v2 of camera callbacks, where the onCaptureStarted callback adds frame number in its parameter list.

ACameraCaptureSession_close
void ACameraCaptureSession_close(
  ACameraCaptureSession *session
)
Close this capture session.

Closing a session frees up the target output Surfaces of the session for reuse with either a new session, or to other APIs that can draw to Surfaces.

Note that creating a new capture session with ACameraDevice_createCaptureSession will close any existing capture session automatically, and call the older session listener's ACameraCaptureSession_stateCallbacks#onClosed callback. Using ACameraDevice_createCaptureSession directly without closing is the recommended approach for quickly switching to a new session, since unchanged target outputs can be reused more efficiently.

After a session is closed and before ACameraCaptureSession_stateCallbacks#onClosed is called, all methods invoked on the session will return ACAMERA_ERROR_SESSION_CLOSED, and any repeating requests are stopped (as if ACameraCaptureSession_stopRepeating was called). However, any in-progress capture requests submitted to the session will be completed as normal; once all captures have completed and the session has been torn down, ACameraCaptureSession_stateCallbacks#onClosed callback will be called and the seesion will be removed from memory.

Closing a session is idempotent; closing more than once has no effect.

Details
Parameters	
session	
the capture session of interest
ACameraCaptureSession_getDevice
camera_status_t ACameraCaptureSession_getDevice(
  ACameraCaptureSession *session,
  ACameraDevice **device
)
Get the ACameraDevice pointer associated with this capture session in the device argument if the method succeeds.

Details
Parameters	
session	
the capture session of interest
device	
the ACameraDevice associated with session. Will be set to NULL if the session is closed or this method fails.
Returns	
ACAMERA_OK if the method call succeeds. The ACameraDevice will be stored in device argument
ACAMERA_ERROR_INVALID_PARAMETER if session or device is NULL
ACAMERA_ERROR_SESSION_CLOSED if the capture session has been closed
ACAMERA_ERROR_UNKNOWN if the method fails for some other reasons
ACameraCaptureSession_logicalCamera_capture
camera_status_t ACameraCaptureSession_logicalCamera_capture(
  ACameraCaptureSession *session,
  ACameraCaptureSession_logicalCamera_captureCallbacks *callbacks,
  int numRequests,
  ACaptureRequest **requests,
  int *captureSequenceId
)
This has the same functionality as ACameraCaptureSession_capture, with added support for logical multi-camera where the capture callbacks supports result metadata for physical cameras.

ACameraCaptureSession_logicalCamera_captureV2
camera_status_t ACameraCaptureSession_logicalCamera_captureV2(
  ACameraCaptureSession *session,
  ACameraCaptureSession_logicalCamera_captureCallbacksV2 *callbacks,
  int numRequests,
  ACaptureRequest **requests,
  int *captureSequenceId
)
This has the same functionality as ACameraCaptureSession_logical_capture, with added support for v2 of logical multi-camera callbacks where the onCaptureStarted callback adds frame number in its parameter list.

ACameraCaptureSession_logicalCamera_setRepeatingRequest
camera_status_t ACameraCaptureSession_logicalCamera_setRepeatingRequest(
  ACameraCaptureSession *session,
  ACameraCaptureSession_logicalCamera_captureCallbacks *callbacks,
  int numRequests,
  ACaptureRequest **requests,
  int *captureSequenceId
)
This has the same functionality as ACameraCaptureSession_setRepeatingRequest, with added support for logical multi-camera where the capture callbacks supports result metadata for physical cameras.

ACameraCaptureSession_logicalCamera_setRepeatingRequestV2
camera_status_t ACameraCaptureSession_logicalCamera_setRepeatingRequestV2(
  ACameraCaptureSession *session,
  ACameraCaptureSession_logicalCamera_captureCallbacksV2 *callbacks,
  int numRequests,
  ACaptureRequest **requests,
  int *captureSequenceId
)
This has the same functionality as ACameraCaptureSession_logical_setRepeatingRequest, with added support for v2 of logical multi-camera callbacks where the onCaptureStarted callback adds frame number in its parameter list.

ACameraCaptureSession_setRepeatingRequest
camera_status_t ACameraCaptureSession_setRepeatingRequest(
  ACameraCaptureSession *session,
  ACameraCaptureSession_captureCallbacks *callbacks,
  int numRequests,
  ACaptureRequest **requests,
  int *captureSequenceId
)
Request endlessly repeating capture of a sequence of images by this capture session.

With this method, the camera device will continually capture images, cycling through the settings in the provided list of ACaptureRequest, at the maximum rate possible.

If a request is submitted through ACameraCaptureSession_capture, the current repetition of the request list will be completed before the higher-priority request is handled. This guarantees that the application always receives a complete repeat burst captured in minimal time, instead of bursts interleaved with higher-priority captures, or incomplete captures.

Repeating burst requests are a simple way for an application to maintain a preview or other continuous stream of frames where each request is different in a predicatable way, without having to continually submit requests through ACameraCaptureSession_capture.

To stop the repeating capture, call ACameraCaptureSession_stopRepeating. Any ongoing burst will still be completed, however. Calling ACameraCaptureSession_abortCaptures will also clear the request.

Calling this method will replace a previously-set repeating requests set up by this method, although any in-progress burst will be completed before the new repeat burst will be used.

Details
Parameters	
session	
the capture session of interest
callbacks	
the ACameraCaptureSession_captureCallbacks to be associated with this capture sequence. No capture callback will be fired if callbacks is set to NULL.
numRequests	
number of requests in requests array. Must be at least 1.
requests	
an array of ACaptureRequest to be captured. Length must be at least numRequests.
captureSequenceId	
the capture sequence ID associated with this capture method invocation will be stored here if this argument is not NULL and the method call succeeds. When this argument is set to NULL, the capture sequence ID will not be returned.
Returns	
ACAMERA_OK if the method succeeds. captureSequenceId will be filled if it is not NULL.
ACAMERA_ERROR_INVALID_PARAMETER if session or requests is NULL, or if numRequests < 1
ACAMERA_ERROR_SESSION_CLOSED if the capture session has been closed
ACAMERA_ERROR_CAMERA_DISCONNECTED if the camera device is closed
ACAMERA_ERROR_CAMERA_DEVICE if the camera device encounters fatal error
ACAMERA_ERROR_CAMERA_SERVICE if the camera service encounters fatal error
ACAMERA_ERROR_UNKNOWN if the method fails for some other reasons
ACameraCaptureSession_setRepeatingRequestV2
camera_status_t ACameraCaptureSession_setRepeatingRequestV2(
  ACameraCaptureSession *session,
  ACameraCaptureSession_captureCallbacksV2 *callbacks,
  int numRequests,
  ACaptureRequest **requests,
  int *captureSequenceId
)
This has the same functionality as ACameraCaptureSession_logical_setRepeatingRequest, with added support for v2 of logical multi-camera callbacks where the onCaptureStarted callback adds frame number in its parameter list.

ACameraCaptureSession_stopRepeating
camera_status_t ACameraCaptureSession_stopRepeating(
  ACameraCaptureSession *session
)
Cancel any ongoing repeating capture set by ACameraCaptureSession_setRepeatingRequest.

Has no effect on requests submitted through ACameraCaptureSession_capture.

Any currently in-flight captures will still complete, as will any burst that is mid-capture. To ensure that the device has finished processing all of its capture requests and is in ready state, wait for the ACameraCaptureSession_stateCallbacks#onReady callback after calling this method.

Details
Parameters	
session	
the capture session of interest
Returns	
ACAMERA_OK if the method succeeds. captureSequenceId will be filled if it is not NULL.
ACAMERA_ERROR_INVALID_PARAMETER if session is NULL.
ACAMERA_ERROR_SESSION_CLOSED if the capture session has been closed
ACAMERA_ERROR_CAMERA_DISCONNECTED if the camera device is closed
ACAMERA_ERROR_CAMERA_DEVICE if the camera device encounters fatal error
ACAMERA_ERROR_CAMERA_SERVICE if the camera service encounters fatal error
ACAMERA_ERROR_UNKNOWN if the method fails for some other reasons
ACameraCaptureSession_updateSharedOutput
camera_status_t ACameraCaptureSession_updateSharedOutput(
  ACameraCaptureSession *session,
  ACaptureSessionOutput *output
)
Update shared ACaptureSessionOutput.

A shared ACaptureSessionOutput (see ACaptureSessionSharedOutput_create) that was modified via calls to ACaptureSessionSharedOutput_add or ACaptureSessionSharedOutput_remove must be updated by calling this method before its changes take effect. After the update call returns with ACAMERA_OK, any newly added native windows can be used as a target in subsequent capture requests.

Native windows that get removed must not be part of any active repeating or single/burst request or have any pending results. Consider updating repeating requests via ACameraCaptureSession_setRepeatingRequest and then wait for the last frame number when the sequence completes ACameraCaptureSession_captureCallbacks#onCaptureSequenceCompleted.

Native windows that get added must not be part of any other registered ACaptureSessionOutput and must be compatible. Compatible windows must have matching format, rotation and consumer usage.

A shared ACameraCaptureSession can support up to 4 additional native windows.

Details
Parameters	
session	
the capture session of interest
output	
the modified output configuration
Returns	
ACAMERA_OK if the method succeeds.
ACAMERA_ERROR_INVALID_PARAMETER if session or output is NULL; or output contains invalid native windows; or if an attempt was made to add a native window to a different output configuration; or new native window is not compatible; or any removed native window still has pending requests;
ACAMERA_ERROR_INVALID_OPERATION if output configuration is not shared (see ACaptureSessionSharedOutput_create; or the number of additional native windows goes beyond the supported limit.
ACAMERA_ERROR_SESSION_CLOSED if the capture session has been closed
ACAMERA_ERROR_CAMERA_DISCONNECTED if the camera device is closed
ACAMERA_ERROR_CAMERA_DEVICE if the camera device encounters fatal error
ACAMERA_ERROR_CAMERA_SERVICE if the camera service encounters fatal error
ACAMERA_ERROR_UNKNOWN if the method fails for some other reasons
ACameraDevice_close
camera_status_t ACameraDevice_close(
  ACameraDevice *device
)
Close the connection and free this ACameraDevice synchronously.

Access to the ACameraDevice after calling this method will cause a crash.

After this call, all calls to the active ACameraCaptureSession associated to this ACameraDevice will return ACAMERA_ERROR_SESSION_CLOSED except for calls to ACameraCaptureSession_close.

This method will stop all repeating captures sent via ACameraCaptureSession_setRepeatingRequest and block until all capture requests sent via ACameraCaptureSession_capture is complete. Once the method returns, the camera device will be removed from memory and access to the closed camera device pointer will cause a crash.

Details
Parameters	
device	
the camera device to be closed
Returns	
ACAMERA_OK if the method call succeeds.
ACAMERA_ERROR_INVALID_PARAMETER if device is NULL.
ACameraDevice_createCaptureRequest
camera_status_t ACameraDevice_createCaptureRequest(
  const ACameraDevice *device,
  ACameraDevice_request_template templateId,
  ACaptureRequest **request
)
Create a ACaptureRequest for capturing images, initialized with template for a target use case.

The settings are chosen to be the best options for this camera device, so it is not recommended to reuse the same request for a different camera device.

See also: TEMPLATE_PREVIEW See also: TEMPLATE_RECORD See also: TEMPLATE_STILL_CAPTURE See also: TEMPLATE_VIDEO_SNAPSHOT See also: TEMPLATE_MANUAL

Details
Parameters	
device	
the camera device of interest
templateId	
the type of capture request to be created. See ACameraDevice_request_template.
request	
the output request will be stored here if the method call succeeds.
Returns	
ACAMERA_OK if the method call succeeds. The created capture request will be filled in request argument.
ACAMERA_ERROR_INVALID_PARAMETER if device or request is NULL, templateId is undefined or camera device does not support requested template.
ACAMERA_ERROR_CAMERA_DISCONNECTED if the camera device is closed.
ACAMERA_ERROR_CAMERA_DEVICE if the camera device encounters fatal error.
ACAMERA_ERROR_CAMERA_SERVICE if the camera service encounters fatal error.
ACAMERA_ERROR_UNKNOWN if the method fails for some other reasons.
ACameraDevice_createCaptureRequest_withPhysicalIds
camera_status_t ACameraDevice_createCaptureRequest_withPhysicalIds(
  const ACameraDevice *device,
  ACameraDevice_request_template templateId,
  const ACameraIdList *physicalIdList,
  ACaptureRequest **request
)
Create a logical multi-camera ACaptureRequest for capturing images, initialized with template for a target use case, with the ability to specify physical camera settings.

The settings are chosen to be the best options for this camera device, so it is not recommended to reuse the same request for a different camera device.

Note that for all keys in physical camera settings, only the keys advertised in ACAMERA_REQUEST_AVAILABLE_PHYSICAL_CAMERA_REQUEST_KEYS are applicable. All other keys are ignored by the camera device.

See also: TEMPLATE_PREVIEW See also: TEMPLATE_RECORD See also: TEMPLATE_STILL_CAPTURE See also: TEMPLATE_VIDEO_SNAPSHOT See also: TEMPLATE_MANUAL

Details
Parameters	
device	
the camera device of interest
templateId	
the type of capture request to be created. See ACameraDevice_request_template.
physicalIdList	
The list of physical camera Ids that can be used to customize the request for a specific physical camera.
request	
the output request will be stored here if the method call succeeds.
Returns	
ACAMERA_OK if the method call succeeds. The created capture request will be filled in request argument.
ACAMERA_ERROR_INVALID_PARAMETER if device, physicalIdList, or request is NULL, templateId is undefined or camera device does not support requested template, or if some Ids in physicalIdList isn't a valid physical camera backing the current camera device.
ACAMERA_ERROR_CAMERA_DISCONNECTED if the camera device is closed.
ACAMERA_ERROR_CAMERA_DEVICE if the camera device encounters fatal error.
ACAMERA_ERROR_CAMERA_SERVICE if the camera service encounters fatal error.
ACAMERA_ERROR_UNKNOWN if the method fails for some other reasons.
ACameraDevice_createCaptureSession
camera_status_t ACameraDevice_createCaptureSession(
  ACameraDevice *device,
  const ACaptureSessionOutputContainer *outputs,
  const ACameraCaptureSession_stateCallbacks *callbacks,
  ACameraCaptureSession **session
)
Create a new camera capture session by providing the target output set of ANativeWindow to the camera device.

If there is a preexisting session, the previous session will be closed automatically. However, app still needs to call ACameraCaptureSession_close on previous session. Otherwise the resources held by previous session will NOT be freed.

The active capture session determines the set of potential output ANativeWindows for the camera device for each capture request. A given request may use all or only some of the outputs. Once the ACameraCaptureSession is created, requests can be submitted with ACameraCaptureSession_capture or ACameraCaptureSession_setRepeatingRequest.

Often the ANativeWindow used with this method can be obtained from a Surface java object by ANativeWindow_fromSurface NDK method. Surfaces or ANativeWindow suitable for inclusion as a camera output can be created for various use cases and targets:

For drawing to a SurfaceView: Once the SurfaceView's Surface is created, set the size of the Surface with android.view.SurfaceHolder#setFixedSize to be one of the PRIVATE output sizes returned by ACAMERA_SCALER_AVAILABLE_STREAM_CONFIGURATIONS and then obtain the Surface by calling android.view.SurfaceHolder#getSurface. If the size is not set by the application, it will be rounded to the nearest supported size less than 1080p, by the camera device.
For accessing through an OpenGL texture via a SurfaceTexture: Set the size of the SurfaceTexture with setDefaultBufferSize to be one of the PRIVATE output sizes returned by ACAMERA_SCALER_AVAILABLE_STREAM_CONFIGURATIONS before creating a Surface from the SurfaceTexture with Surface#Surface(SurfaceTextrue). If the size is not set by the application, it will be set to be the smallest supported size less than 1080p, by the camera device.
For recording with MediaCodec: Call android.media.MediaCodec#createInputSurface after configuring the media codec to use one of the PRIVATE output sizes returned by ACAMERA_SCALER_AVAILABLE_STREAM_CONFIGURATIONS.
For recording with MediaRecorder: Call android.media.MediaRecorder#getSurface after configuring the media recorder to use one of the PRIVATE output sizes returned by ACAMERA_SCALER_AVAILABLE_STREAM_CONFIGURATIONS, or configuring it to use one of the supported CamcorderProfiles.
For access to RAW, uncompressed YUV, or compressed JPEG data in the application: Create an AImageReader object using the AImageReader_new method with one of the supported output formats given by ACAMERA_SCALER_AVAILABLE_STREAM_CONFIGURATIONS. Then obtain a ANativeWindow from it with AImageReader_getWindow. If the AImageReader size is not set to a supported size, it will be rounded to a supported size less than 1080p by the camera device.
The camera device will query each ANativeWindow's size and formats upon this call, so they must be set to a valid setting at this time.

It can take several hundred milliseconds for the session's configuration to complete, since camera hardware may need to be powered on or reconfigured.

If a prior ACameraCaptureSession already exists when this method is called, the previous session will no longer be able to accept new capture requests and will be closed. Any in-progress capture requests made on the prior session will be completed before it's closed. To minimize the transition time, the ACameraCaptureSession_abortCaptures method can be used to discard the remaining requests for the prior capture session before a new one is created. Note that once the new session is created, the old one can no longer have its captures aborted.

Using larger resolution outputs, or more outputs, can result in slower output rate from the device.

Configuring a session with an empty list will close the current session, if any. This can be used to release the current session's target surfaces for another use.

While any of the sizes from ACAMERA_SCALER_AVAILABLE_STREAM_CONFIGURATIONS can be used when a single output stream is configured, a given camera device may not be able to support all combination of sizes, formats, and targets when multiple outputs are configured at once. The tables below list the maximum guaranteed resolutions for combinations of streams and targets, given the capabilities of the camera device.

If an application tries to create a session using a set of targets that exceed the limits described in the below tables, one of three possibilities may occur. First, the session may be successfully created and work normally. Second, the session may be successfully created, but the camera device won't meet the frame rate guarantees as described in ACAMERA_SCALER_AVAILABLE_MIN_FRAME_DURATIONS. Or third, if the output set cannot be used at all, session creation will fail entirely, with ACAMERA_ERROR_STREAM_CONFIGURE_FAIL being returned.

For the type column PRIV refers to output format AIMAGE_FORMAT_PRIVATE, YUV refers to output format AIMAGE_FORMAT_YUV_420_888, JPEG refers to output format AIMAGE_FORMAT_JPEG, and RAW refers to output format AIMAGE_FORMAT_RAW16

For the maximum size column, PREVIEW refers to the best size match to the device's screen resolution, or to 1080p (1920x1080), whichever is smaller. RECORD refers to the camera device's maximum supported recording resolution, as determined by android.media.CamcorderProfiles. And MAXIMUM refers to the camera device's maximum output resolution for that format or target from ACAMERA_SCALER_AVAILABLE_STREAM_CONFIGURATIONS.

To use these tables, determine the number and the formats/targets of outputs needed, and find the row(s) of the table with those targets. The sizes indicate the maximum set of sizes that can be used; it is guaranteed that for those targets, the listed sizes and anything smaller from the list given by ACAMERA_SCALER_AVAILABLE_STREAM_CONFIGURATIONS can be successfully used to create a session. For example, if a row indicates that a 8 megapixel (MP) YUV_420_888 output can be used together with a 2 MP PRIV output, then a session can be created with targets [8 MP YUV, 2 MP PRIV] or targets [2 MP YUV, 2 MP PRIV]; but a session with targets [8 MP YUV, 4 MP PRIV], targets [4 MP YUV, 4 MP PRIV], or targets [8 MP PRIV, 2 MP YUV] would not be guaranteed to work, unless some other row of the table lists such a combination.

Legacy devices (ACAMERA_INFO_SUPPORTED_HARDWARE_LEVEL==LEGACY) support at least the following stream combinations:

LEGACY-level guaranteed configurations
Target 1	Target 2	Target 3	Sample use case(s)
Type	Max size	Type	Max size	Type	Max size
PRIV	MAXIMUM			Simple preview, GPU video processing, or no-preview video recording.
JPEG	MAXIMUM			No-viewfinder still image capture.
YUV	MAXIMUM			In-application video/image processing.
PRIV	PREVIEW	JPEG	MAXIMUM		Standard still imaging.
YUV	PREVIEW	JPEG	MAXIMUM		In-app processing plus still capture.
PRIV	PREVIEW	PRIV	PREVIEW		Standard recording.
PRIV	PREVIEW	YUV	PREVIEW		Preview plus in-app processing.
PRIV	PREVIEW	YUV	PREVIEW	JPEG	MAXIMUM	Still capture plus in-app processing.

Limited-level (ACAMERA_INFO_SUPPORTED_HARDWARE_LEVEL==LIMITED) devices support at least the following stream combinations in addition to those for LEGACY devices:

LIMITED-level additional guaranteed configurations
Target 1	Target 2	Target 3	Sample use case(s)
Type	Max size	Type	Max size	Type	Max size
PRIV	PREVIEW	PRIV	RECORD		High-resolution video recording with preview.
PRIV	PREVIEW	YUV	RECORD		High-resolution in-app video processing with preview.
YUV	PREVIEW	YUV	RECORD		Two-input in-app video processing.
PRIV	PREVIEW	PRIV	RECORD	JPEG	RECORD	High-resolution recording with video snapshot.
PRIV	PREVIEW	YUV	RECORD	JPEG	RECORD	High-resolution in-app processing with video snapshot.
YUV	PREVIEW	YUV	PREVIEW	JPEG	MAXIMUM	Two-input in-app processing with still capture.

FULL-level (ACAMERA_INFO_SUPPORTED_HARDWARE_LEVEL==FULL) devices support at least the following stream combinations in addition to those for LIMITED devices:

FULL-level additional guaranteed configurations
Target 1	Target 2	Target 3	Sample use case(s)
Type	Max size	Type	Max size	Type	Max size
PRIV	PREVIEW	PRIV	MAXIMUM		Maximum-resolution GPU processing with preview.
PRIV	PREVIEW	YUV	MAXIMUM		Maximum-resolution in-app processing with preview.
YUV	PREVIEW	YUV	MAXIMUM		Maximum-resolution two-input in-app processsing.
PRIV	PREVIEW	PRIV	PREVIEW	JPEG	MAXIMUM	Video recording with maximum-size video snapshot
YUV	640x480	PRIV	PREVIEW	YUV	MAXIMUM	Standard video recording plus maximum-resolution in-app processing.
YUV	640x480	YUV	PREVIEW	YUV	MAXIMUM	Preview plus two-input maximum-resolution in-app processing.

RAW-capability (ACAMERA_REQUEST_AVAILABLE_CAPABILITIES includes RAW) devices additionally support at least the following stream combinations on both FULL and LIMITED devices:

RAW-capability additional guaranteed configurations
Target 1	Target 2	Target 3	Sample use case(s)
Type	Max size	Type	Max size	Type	Max size
RAW	MAXIMUM			No-preview DNG capture.
PRIV	PREVIEW	RAW	MAXIMUM		Standard DNG capture.
YUV	PREVIEW	RAW	MAXIMUM		In-app processing plus DNG capture.
PRIV	PREVIEW	PRIV	PREVIEW	RAW	MAXIMUM	Video recording with DNG capture.
PRIV	PREVIEW	YUV	PREVIEW	RAW	MAXIMUM	Preview with in-app processing and DNG capture.
YUV	PREVIEW	YUV	PREVIEW	RAW	MAXIMUM	Two-input in-app processing plus DNG capture.
PRIV	PREVIEW	JPEG	MAXIMUM	RAW	MAXIMUM	Still capture with simultaneous JPEG and DNG.
YUV	PREVIEW	JPEG	MAXIMUM	RAW	MAXIMUM	In-app processing with simultaneous JPEG and DNG.

BURST-capability (ACAMERA_REQUEST_AVAILABLE_CAPABILITIES includes BURST_CAPTURE) devices support at least the below stream combinations in addition to those for LIMITED devices. Note that all FULL-level devices support the BURST capability, and the below list is a strict subset of the list for FULL-level devices, so this table is only relevant for LIMITED-level devices that support the BURST_CAPTURE capability.

BURST-capability additional guaranteed configurations
Target 1	Target 2	Sample use case(s)
Type	Max size	Type	Max size
PRIV	PREVIEW	PRIV	MAXIMUM	Maximum-resolution GPU processing with preview.
PRIV	PREVIEW	YUV	MAXIMUM	Maximum-resolution in-app processing with preview.
YUV	PREVIEW	YUV	MAXIMUM	Maximum-resolution two-input in-app processsing.

LEVEL-3 (ACAMERA_INFO_SUPPORTED_HARDWARE_LEVEL==LEVEL_3) support at least the following stream combinations in addition to the combinations for FULL and for RAW capability (ACAMERA_REQUEST_AVAILABLE_CAPABILITIES includes RAW):

LEVEL-3 additional guaranteed configurations
Target 1	Target 2	Target 3	Target 4	Sample use case(s)
Type	Max size	Type	Max size	Type	Max size	Type	Max size
PRIV	PREVIEW	PRIV	640x480	YUV	MAXIMUM	RAW	MAXIMUM	In-app viewfinder analysis with dynamic selection of output format.
PRIV	PREVIEW	PRIV	640x480	JPEG	MAXIMUM	RAW	MAXIMUM	In-app viewfinder analysis with dynamic selection of output format.

Since the capabilities of camera devices vary greatly, a given camera device may support target combinations with sizes outside of these guarantees, but this can only be tested for by attempting to create a session with such targets.

Exception on 176x144 (QCIF) resolution: Camera devices usually have a fixed capability for downscaling from larger resolution to smaller, and the QCIF resolution sometimes cannot be fully supported due to this limitation on devices with high-resolution image sensors. Therefore, trying to configure a QCIF resolution stream together with any other stream larger than 1920x1080 resolution (either width or height) might not be supported, and capture session creation will fail if it is not.

Details
Parameters	
device	
the camera device of interest.
outputs	
the ACaptureSessionOutputContainer describes all output streams.
callbacks	
the capture session state callbacks.
session	
the created ACameraCaptureSession will be filled here if the method call succeeds.
Returns	
ACAMERA_OK if the method call succeeds. The created capture session will be filled in session argument.
ACAMERA_ERROR_INVALID_PARAMETER if any of device, outputs, callbacks or session is NULL.
ACAMERA_ERROR_CAMERA_DISCONNECTED if the camera device is closed.
ACAMERA_ERROR_CAMERA_DEVICE if the camera device encounters fatal error.
ACAMERA_ERROR_CAMERA_SERVICE if the camera service encounters fatal error.
ACAMERA_ERROR_UNKNOWN if the method fails for some other reasons.
ACameraDevice_createCaptureSessionWithSessionParameters
camera_status_t ACameraDevice_createCaptureSessionWithSessionParameters(
  ACameraDevice *device,
  const ACaptureSessionOutputContainer *outputs,
  const ACaptureRequest *sessionParameters,
  const ACameraCaptureSession_stateCallbacks *callbacks,
  ACameraCaptureSession **session
)
Create a new camera capture session similar to ACameraDevice_createCaptureSession.

This function allows clients to pass additional session parameters during session initialization. For further information about session parameters see ACAMERA_REQUEST_AVAILABLE_SESSION_KEYS.

Details
Parameters	
device	
the camera device of interest.
outputs	
the ACaptureSessionOutputContainer describes all output streams.
sessionParameters	
An optional capture request that contains the initial values of session parameters advertised in ACAMERA_REQUEST_AVAILABLE_SESSION_KEYS.
callbacks	
the ACameraCaptureSession_stateCallbacks capture session state callbacks.
session	
the created ACameraCaptureSession will be filled here if the method call succeeds.
Returns	
ACAMERA_OK if the method call succeeds. The created capture session will be filled in session argument.
ACAMERA_ERROR_INVALID_PARAMETER if any of device, outputs, callbacks or session is NULL.
ACAMERA_ERROR_CAMERA_DISCONNECTED if the camera device is closed.
ACAMERA_ERROR_CAMERA_DEVICE if the camera device encounters fatal error.
ACAMERA_ERROR_CAMERA_SERVICE if the camera service encounters fatal error.
ACAMERA_ERROR_UNKNOWN if the method fails for some other reasons.
ACameraDevice_getId
const char * ACameraDevice_getId(
  const ACameraDevice *device
)
Return the camera id associated with this camera device.

Details
Parameters	
device	
the camera device to be closed
Returns	
camera ID string. The returned string is managed by framework and should not be delete/free by the application. Also the returned string must not be used after the device has been closed.
ACameraDevice_isSessionConfigurationSupported
camera_status_t ACameraDevice_isSessionConfigurationSupported(
  const ACameraDevice *device,
  const ACaptureSessionOutputContainer *sessionOutputContainer
)
Check whether a particular ACaptureSessionOutputContainer is supported by the camera device.

This method performs a runtime check of a given ACaptureSessionOutputContainer. The result confirms whether or not the passed CaptureSession outputs can be successfully used to create a camera capture session using ACameraDevice_createCaptureSession.

This method can be called at any point before, during and after active capture session. It must not impact normal camera behavior in any way and must complete significantly faster than creating a capture session.

Although this method is faster than creating a new capture session, it is not intended to be used for exploring the entire space of supported stream combinations.

Details
Parameters	
device	
the camera device of interest
sessionOutputContainer	
the ACaptureSessionOutputContainer of interest.
Returns	
ACAMERA_OK if the given ACaptureSessionOutputContainer is supported by the camera device.
ACAMERA_ERROR_INVALID_PARAMETER if device, or sessionOutputContainer is NULL.
ACAMERA_ERROR_STREAM_CONFIGURE_FAIL if the given ACaptureSessionOutputContainer is not supported by the camera device.
ACAMERA_ERROR_UNSUPPORTED_OPERATION if the query operation is not supported by the camera device.
ACameraManager_create
ACameraManager * ACameraManager_create()
Create ACameraManager instance.

The ACameraManager is responsible for detecting, characterizing, and connecting to ACameraDevices.

The caller must call ACameraManager_delete to free the resources once it is done using the ACameraManager instance.

Details
Returns	
a ACameraManager instance.
ACameraManager_delete
void ACameraManager_delete(
  ACameraManager *manager
)
Delete the ACameraManager instance and free its resources.

Details
Parameters	
manager	
the ACameraManager instance to be deleted.
ACameraManager_deleteCameraIdList
void ACameraManager_deleteCameraIdList(
  ACameraIdList *cameraIdList
)
Delete a list of camera devices allocated via ACameraManager_getCameraIdList.

Details
Parameters	
cameraIdList	
the ACameraIdList to be deleted.
ACameraManager_getCameraCharacteristics
camera_status_t ACameraManager_getCameraCharacteristics(
  ACameraManager *manager,
  const char *cameraId,
  ACameraMetadata **characteristics
)
Query the capabilities of a camera device.

These capabilities are immutable for a given camera.

See ACameraMetadata document and NdkCameraMetadataTags.h for more details.

The caller must call ACameraMetadata_free to free the memory of the output characteristics.

Details
Parameters	
manager	
the ACameraManager of interest.
cameraId	
the ID string of the camera device of interest.
characteristics	
the output ACameraMetadata will be filled here if the method call succeeeds.
Returns	
ACAMERA_OK if the method call succeeds.
ACAMERA_ERROR_INVALID_PARAMETER if manager, cameraId, or characteristics is NULL, or cameraId does not match any camera devices connected.
ACAMERA_ERROR_CAMERA_DISCONNECTED if connection to camera service fails.
ACAMERA_ERROR_NOT_ENOUGH_MEMORY if allocating memory fails.
ACAMERA_ERROR_UNKNOWN if the method fails for some other reasons.
ACameraManager_getCameraIdList
camera_status_t ACameraManager_getCameraIdList(
  ACameraManager *manager,
  ACameraIdList **cameraIdList
)
Create a list of currently connected camera devices, including cameras that may be in use by other camera API clients.

Non-removable cameras use integers starting at 0 for their identifiers, while removable cameras have a unique identifier for each individual device, even if they are the same model.

ACameraManager_getCameraIdList will allocate and return an ACameraIdList. The caller must call ACameraManager_deleteCameraIdList to free the memory

Note: the returned camera list might be a subset to the output of SDK CameraManager::getCameraIdList API as the NDK API does not support some legacy camera hardware.

Details
Parameters	
manager	
the ACameraManager of interest
cameraIdList	
the output ACameraIdList will be filled in here if the method call succeeds.
Returns	
ACAMERA_OK if the method call succeeds.
ACAMERA_ERROR_INVALID_PARAMETER if manager or cameraIdList is NULL.
ACAMERA_ERROR_CAMERA_DISCONNECTED if connection to camera service fails.
ACAMERA_ERROR_NOT_ENOUGH_MEMORY if allocating memory fails.
ACameraManager_openCamera
camera_status_t ACameraManager_openCamera(
  ACameraManager *manager,
  const char *cameraId,
  ACameraDevice_StateCallbacks *callback,
  ACameraDevice **device
)
Open a connection to a camera with the given ID.

The opened camera device will be returned in the device parameter.

Use ACameraManager_getCameraIdList to get the list of available camera devices. Note that even if an id is listed, open may fail if the device is disconnected between the calls to ACameraManager_getCameraIdList and ACameraManager_openCamera, or if a higher-priority camera API client begins using the camera device.

Devices for which the ACameraManager_AvailabilityCallbacks#onCameraUnavailable callback has been called due to the device being in use by a lower-priority, background camera API client can still potentially be opened by calling this method when the calling camera API client has a higher priority than the current camera API client using this device. In general, if the top, foreground activity is running within your application process, your process will be given the highest priority when accessing the camera, and this method will succeed even if the camera device is in use by another camera API client. Any lower-priority application that loses control of the camera in this way will receive an ACameraDevice_StateCallbacks#onDisconnected callback.

Once the camera is successfully opened,the ACameraDevice can then be set up for operation by calling ACameraDevice_createCaptureSession and ACameraDevice_createCaptureRequest.

If the camera becomes disconnected after this function call returns, ACameraDevice_StateCallbacks#onDisconnected with a ACameraDevice in the disconnected state will be called.

If the camera runs into error after this function call returns, ACameraDevice_StateCallbacks#onError with a ACameraDevice in the error state will be called.

Details
Parameters	
manager	
the ACameraManager of interest.
cameraId	
the ID string of the camera device to be opened.
callback	
the ACameraDevice_StateCallbacks associated with the opened camera device.
device	
the opened ACameraDevice will be filled here if the method call succeeds.
Returns	
ACAMERA_OK if the method call succeeds.
ACAMERA_ERROR_INVALID_PARAMETER if manager, cameraId, callback, or device is NULL, or cameraId does not match any camera devices connected.
ACAMERA_ERROR_CAMERA_DISCONNECTED if connection to camera service fails.
ACAMERA_ERROR_NOT_ENOUGH_MEMORY if allocating memory fails.
ACAMERA_ERROR_CAMERA_IN_USE if camera device is being used by a higher priority camera API client.
ACAMERA_ERROR_MAX_CAMERA_IN_USE if the system-wide limit for number of open cameras or camera resources has been reached, and more camera devices cannot be opened until previous instances are closed.
ACAMERA_ERROR_CAMERA_DISABLED if the camera is disabled due to a device policy, and cannot be opened.
ACAMERA_ERROR_PERMISSION_DENIED if the application does not have permission to open camera.
ACAMERA_ERROR_UNKNOWN if the method fails for some other reasons.
ACameraManager_registerAvailabilityCallback
camera_status_t ACameraManager_registerAvailabilityCallback(
  ACameraManager *manager,
  const ACameraManager_AvailabilityCallbacks *callback
)
Register camera availability callbacks.

onCameraUnavailable will be called whenever a camera device is opened by any camera API client. Other camera API clients may still be able to open such a camera device, evicting the existing client if they have higher priority than the existing client of a camera device. See ACameraManager_openCamera for more details.

The callbacks will be called on a dedicated thread shared among all ACameraManager instances.

Since this callback will be registered with the camera service, remember to unregister it once it is no longer needed; otherwise the callback will continue to receive events indefinitely and it may prevent other resources from being released. Specifically, the callbacks will be invoked independently of the general activity lifecycle and independently of the state of individual ACameraManager instances.

Details
Parameters	
manager	
the ACameraManager of interest.
callback	
the ACameraManager_AvailabilityCallbacks to be registered.
Returns	
ACAMERA_OK if the method call succeeds.
ACAMERA_ERROR_INVALID_PARAMETER if manager or callback is NULL, or {ACameraManager_AvailabilityCallbacks::onCameraAvailable} or {ACameraManager_AvailabilityCallbacks::onCameraUnavailable} is NULL.
ACameraManager_registerExtendedAvailabilityCallback
camera_status_t ACameraManager_registerExtendedAvailabilityCallback(
  ACameraManager *manager,
  const ACameraManager_ExtendedAvailabilityCallbacks *callback
)
Register camera extended availability callbacks.

onCameraUnavailable will be called whenever a camera device is opened by any camera API client. Other camera API clients may still be able to open such a camera device, evicting the existing client if they have higher priority than the existing client of a camera device. See ACameraManager_openCamera for more details.

The callbacks will be called on a dedicated thread shared among all ACameraManager instances.

Since this callback will be registered with the camera service, remember to unregister it once it is no longer needed; otherwise the callback will continue to receive events indefinitely and it may prevent other resources from being released. Specifically, the callbacks will be invoked independently of the general activity lifecycle and independently of the state of individual ACameraManager instances.

Details
Parameters	
manager	
the ACameraManager of interest.
callback	
the ACameraManager_ExtendedAvailabilityCallbacks to be registered.
Returns	
ACAMERA_OK if the method call succeeds.
ACAMERA_ERROR_INVALID_PARAMETER if manager or callback is NULL, or {ACameraManager_ExtendedAvailabilityCallbacks::onCameraAccessPrioritiesChanged} or {ACameraManager_AvailabilityCallbacks::onCameraAvailable} or {ACameraManager_AvailabilityCallbacks::onCameraUnavailable} is NULL.
ACameraManager_unregisterAvailabilityCallback
camera_status_t ACameraManager_unregisterAvailabilityCallback(
  ACameraManager *manager,
  const ACameraManager_AvailabilityCallbacks *callback
)
Unregister camera availability callbacks.

Removing a callback that isn't registered has no effect.

This function must not be called with a mutex lock also held by the availability callbacks.

Details
Parameters	
manager	
the ACameraManager of interest.
callback	
the ACameraManager_AvailabilityCallbacks to be unregistered.
Returns	
ACAMERA_OK if the method call succeeds.
ACAMERA_ERROR_INVALID_PARAMETER if callback, {ACameraManager_AvailabilityCallbacks::onCameraAvailable} or {ACameraManager_AvailabilityCallbacks::onCameraUnavailable} is NULL.
ACameraManager_unregisterExtendedAvailabilityCallback
camera_status_t ACameraManager_unregisterExtendedAvailabilityCallback(
  ACameraManager *manager,
  const ACameraManager_ExtendedAvailabilityCallbacks *callback
)
Unregister camera extended availability callbacks.

Removing a callback that isn't registered has no effect.

This function must not be called with a mutex lock also held by the extended availability callbacks.

Details
Parameters	
manager	
the ACameraManager of interest.
callback	
the ACameraManager_ExtendedAvailabilityCallbacks to be unregistered.
Returns	
ACAMERA_OK if the method call succeeds.
ACAMERA_ERROR_INVALID_PARAMETER if callback, {ACameraManager_ExtendedAvailabilityCallbacks::onCameraAccessPrioritiesChanged} or {ACameraManager_AvailabilityCallbacks::onCameraAvailable} or {ACameraManager_AvailabilityCallbacks::onCameraUnavailable} is NULL.
ACameraMetadata_copy
ACameraMetadata * ACameraMetadata_copy(
  const ACameraMetadata *src
)
Create a copy of input ACameraMetadata.

The returned ACameraMetadata must be freed by the application by ACameraMetadata_free after application is done using it.

Details
Parameters	
src	
the input ACameraMetadata to be copied.
Returns	
a valid ACameraMetadata pointer or NULL if the input metadata cannot be copied.
ACameraMetadata_free
void ACameraMetadata_free(
  ACameraMetadata *metadata
)
Free a ACameraMetadata structure.

Details
Parameters	
metadata	
the ACameraMetadata to be freed.
ACameraMetadata_fromCameraMetadata
ACameraMetadata * ACameraMetadata_fromCameraMetadata(
  JNIEnv *env,
  jobject cameraMetadata
)
Return a ACameraMetadata that references the same data as android.hardware.camera2.CameraMetadata from Java API.

(e.g., a android.hardware.camera2.CameraCharacteristics or android.hardware.camera2.CaptureResult).

The returned ACameraMetadata must be freed by the application by ACameraMetadata_free after application is done using it.

The ACameraMetadata maintains a reference count to the underlying data, so it can be used independently of the Java object, and it remains valid even if the Java metadata is garbage collected.

Details
Parameters	
env	
the JNI environment.
cameraMetadata	
the source android.hardware.camera2.CameraMetadata from which the returned ACameraMetadata is a view.
Returns	
a valid ACameraMetadata pointer or NULL if cameraMetadata is null or not a valid instance of android.hardware.camera2.CameraMetadata.
ACameraMetadata_getAllTags
camera_status_t ACameraMetadata_getAllTags(
  const ACameraMetadata *metadata,
  int32_t *numEntries,
  const uint32_t **tags
)
List all the entry tags in input ACameraMetadata.

Details
Parameters	
metadata	
the ACameraMetadata of interest.
numEntries	
number of metadata entries in input ACameraMetadata
tags	
the tag values of the metadata entries. Length of tags is returned in numEntries argument. The memory is managed by ACameraMetadata itself and must NOT be free/delete by application. Do NOT access tags after calling ACameraMetadata_free.
Returns	
ACAMERA_OK if the method call succeeds.
ACAMERA_ERROR_INVALID_PARAMETER if metadata, numEntries or tags is NULL.
ACAMERA_ERROR_UNKNOWN if the method fails for some other reasons.
ACameraMetadata_getConstEntry
camera_status_t ACameraMetadata_getConstEntry(
  const ACameraMetadata *metadata,
  uint32_t tag,
  ACameraMetadata_const_entry *entry
)
Get a metadata entry from an input ACameraMetadata.

The memory of the data field in the returned entry is managed by camera framework. Do not attempt to free it.

Details
Parameters	
metadata	
the ACameraMetadata of interest.
tag	
the tag value of the camera metadata entry to be get.
entry	
the output ACameraMetadata_const_entry will be filled here if the method call succeeeds.
Returns	
ACAMERA_OK if the method call succeeds.
ACAMERA_ERROR_INVALID_PARAMETER if metadata or entry is NULL.
ACAMERA_ERROR_METADATA_NOT_FOUND if input metadata does not contain an entry of input tag value.
ACameraMetadata_isLogicalMultiCamera
bool ACameraMetadata_isLogicalMultiCamera(
  const ACameraMetadata *staticMetadata,
  size_t *numPhysicalCameras,
  const char *const **physicalCameraIds
)
Helper function to check if a camera is logical multi-camera.

Check whether a camera device is a logical multi-camera based on its static metadata. If it is, also returns its physical sub camera Ids.

Details
Parameters	
staticMetadata	
the static metadata of the camera being checked.
numPhysicalCameras	
returns the number of physical cameras.
physicalCameraIds	
returns the array of physical camera Ids backing this logical camera device. Note that this pointer is only valid during the lifetime of the staticMetadata object.
Returns	
true if this is a logical multi-camera, false otherwise.
ACameraOutputTarget_create
camera_status_t ACameraOutputTarget_create(
  ACameraWindowType *window,
  ACameraOutputTarget **output
)
Create a ACameraOutputTarget object.

The ACameraOutputTarget is used in ACaptureRequest_addTarget method to add an output ANativeWindow to ACaptureRequest. Use ACameraOutputTarget_free to free the object and its memory after application no longer needs the ACameraOutputTarget.

See also: ACaptureRequest_addTarget

Details
Parameters	
window	
the ANativeWindow to be associated with the ACameraOutputTarget
output	
the output ACameraOutputTarget will be stored here if the method call succeeds.
Returns	
ACAMERA_OK if the method call succeeds. The created ACameraOutputTarget will be filled in the output argument.
ACAMERA_ERROR_INVALID_PARAMETER if window or output is NULL.
ACameraOutputTarget_free
void ACameraOutputTarget_free(
  ACameraOutputTarget *output
)
Free a ACameraOutputTarget object.

See also: ACameraOutputTarget_create

Details
Parameters	
output	
the ACameraOutputTarget to be freed.
ACaptureRequest_addTarget
camera_status_t ACaptureRequest_addTarget(
  ACaptureRequest *request,
  const ACameraOutputTarget *output
)
Add an ACameraOutputTarget object to ACaptureRequest.

Details
Parameters	
request	
the ACaptureRequest of interest.
output	
the output ACameraOutputTarget to be added to capture request.
Returns	
ACAMERA_OK if the method call succeeds.
ACAMERA_ERROR_INVALID_PARAMETER if request or output is NULL.
ACaptureRequest_copy
ACaptureRequest * ACaptureRequest_copy(
  const ACaptureRequest *src
)
Create a copy of input ACaptureRequest.

The returned ACaptureRequest must be freed by the application by ACaptureRequest_free after application is done using it.

Details
Parameters	
src	
the input ACaptureRequest to be copied.
Returns	
a valid ACaptureRequest pointer or NULL if the input request cannot be copied.
ACaptureRequest_free
void ACaptureRequest_free(
  ACaptureRequest *request
)
Free a ACaptureRequest structure.

Details
Parameters	
request	
the ACaptureRequest to be freed.
ACaptureRequest_getAllTags
camera_status_t ACaptureRequest_getAllTags(
  const ACaptureRequest *request,
  int32_t *numTags,
  const uint32_t **tags
)
ACaptureRequest_getConstEntry
camera_status_t ACaptureRequest_getConstEntry(
  const ACaptureRequest *request,
  uint32_t tag,
  ACameraMetadata_const_entry *entry
)
Get a metadata entry from input ACaptureRequest.

The memory of the data field in returned entry is managed by camera framework. Do not attempt to free it.

Details
Parameters	
request	
the ACaptureRequest of interest.
tag	
the tag value of the camera metadata entry to be get.
entry	
the output ACameraMetadata_const_entry will be filled here if the method call succeeeds.
Returns	
ACAMERA_OK if the method call succeeds.
ACAMERA_ERROR_INVALID_PARAMETER if metadata or entry is NULL.
ACAMERA_ERROR_METADATA_NOT_FOUND if the capture request does not contain an entry of input tag value.
ACaptureRequest_getConstEntry_physicalCamera
camera_status_t ACaptureRequest_getConstEntry_physicalCamera(
  const ACaptureRequest *request,
  const char *physicalId,
  uint32_t tag,
  ACameraMetadata_const_entry *entry
)
Get a metadata entry from input ACaptureRequest for a physical camera backing a logical multi-camera device.

Same as ACaptureRequest_getConstEntry, except that if the key is contained in ACAMERA_REQUEST_AVAILABLE_PHYSICAL_CAMERA_REQUEST_KEYS, this function returns the entry set by ACaptureRequest_setEntry_physicalCamera_* class of functions on the particular physical camera.

Details
Parameters	
request	
the ACaptureRequest of interest created by ACameraDevice_createCaptureRequest_withPhysicalIds.
physicalId	
one of the physical Ids used when request is created with ACameraDevice_createCaptureRequest_withPhysicalIds.
tag	
the capture request metadata tag in ACAMERA_REQUEST_AVAILABLE_PHYSICAL_CAMERA_REQUEST_KEYS that is set by ACaptureRequest_setEntry_physicalCamera_* class of functions.
Returns	
ACAMERA_OK if the method call succeeds.
ACAMERA_ERROR_INVALID_PARAMETER if metadata, physicalId, or entry is NULL, physicalId is not one of the Ids used in creating the request, or if the capture request is a regular request with no physical Ids at all.
ACAMERA_ERROR_METADATA_NOT_FOUND if the capture request does not contain an entry of input tag value.
ACaptureRequest_getUserContext
camera_status_t ACaptureRequest_getUserContext(
  const ACaptureRequest *request,
  void **context
)
Get the user context pointer of the ACaptureRequest.

This method is useful for user to identify the capture request in capture session callbacks. The context is NULL for newly created request.

Details
Parameters	
request	
the ACaptureRequest of interest.
context	
the user context pointer of this capture request.
Returns	
ACAMERA_OK if the method call succeeds.
ACAMERA_ERROR_INVALID_PARAMETER if request is NULL.
ACaptureRequest_removeTarget
camera_status_t ACaptureRequest_removeTarget(
  ACaptureRequest *request,
  const ACameraOutputTarget *output
)
Remove an ACameraOutputTarget object from ACaptureRequest.

This method has no effect if the ACameraOutputTarget does not exist in ACaptureRequest.

Details
Parameters	
request	
the ACaptureRequest of interest.
output	
the output ACameraOutputTarget to be removed from capture request.
Returns	
ACAMERA_OK if the method call succeeds.
ACAMERA_ERROR_INVALID_PARAMETER if request or output is NULL.
ACaptureRequest_setEntry_double
camera_status_t ACaptureRequest_setEntry_double(
  ACaptureRequest *request,
  uint32_t tag,
  uint32_t count,
  const double *data
)
Set/change a camera capture control entry with double data type.

Set count to 0 and data to NULL to remove a tag from the capture request.

Details
Parameters	
request	
the ACaptureRequest of interest.
tag	
the tag value of the camera metadata entry to be set.
count	
number of elements to be set in data argument
data	
the entries to be set/change in the capture request.
Returns	
ACAMERA_OK if the method call succeeds.
ACAMERA_ERROR_INVALID_PARAMETER if request is NULL, count is larger than zero while data is NULL, the data type of the tag is not double, or the tag is not controllable by application.
ACaptureRequest_setEntry_float
camera_status_t ACaptureRequest_setEntry_float(
  ACaptureRequest *request,
  uint32_t tag,
  uint32_t count,
  const float *data
)
Set/change a camera capture control entry with float data type.

Set count to 0 and data to NULL to remove a tag from the capture request.

Details
Parameters	
request	
the ACaptureRequest of interest.
tag	
the tag value of the camera metadata entry to be set.
count	
number of elements to be set in data argument
data	
the entries to be set/change in the capture request.
Returns	
ACAMERA_OK if the method call succeeds.
ACAMERA_ERROR_INVALID_PARAMETER if request is NULL, count is larger than zero while data is NULL, the data type of the tag is not float, or the tag is not controllable by application.
ACaptureRequest_setEntry_i32
camera_status_t ACaptureRequest_setEntry_i32(
  ACaptureRequest *request,
  uint32_t tag,
  uint32_t count,
  const int32_t *data
)
Set/change a camera capture control entry with signed 32 bits data type.

Set count to 0 and data to NULL to remove a tag from the capture request.

Details
Parameters	
request	
the ACaptureRequest of interest.
tag	
the tag value of the camera metadata entry to be set.
count	
number of elements to be set in data argument
data	
the entries to be set/change in the capture request.
Returns	
ACAMERA_OK if the method call succeeds.
ACAMERA_ERROR_INVALID_PARAMETER if request is NULL, count is larger than zero while data is NULL, the data type of the tag is not signed 32 bits, or the tag is not controllable by application.
ACaptureRequest_setEntry_i64
camera_status_t ACaptureRequest_setEntry_i64(
  ACaptureRequest *request,
  uint32_t tag,
  uint32_t count,
  const int64_t *data
)
Set/change a camera capture control entry with signed 64 bits data type.

Set count to 0 and data to NULL to remove a tag from the capture request.

Details
Parameters	
request	
the ACaptureRequest of interest.
tag	
the tag value of the camera metadata entry to be set.
count	
number of elements to be set in data argument
data	
the entries to be set/change in the capture request.
Returns	
ACAMERA_OK if the method call succeeds.
ACAMERA_ERROR_INVALID_PARAMETER if request is NULL, count is larger than zero while data is NULL, the data type of the tag is not signed 64 bits, or the tag is not controllable by application.
ACaptureRequest_setEntry_physicalCamera_double
camera_status_t ACaptureRequest_setEntry_physicalCamera_double(
  ACaptureRequest *request,
  const char *physicalId,
  uint32_t tag,
  uint32_t count,
  const double *data
)
Set/change a camera capture control entry with double data type for a physical camera of a logical multi-camera device.

Same as ACaptureRequest_setEntry_double, except that if tag is contained in ACAMERA_REQUEST_AVAILABLE_PHYSICAL_CAMERA_REQUEST_KEYS, this function sets the entry for a particular physical sub-camera backing the logical multi-camera. If tag is not contained in ACAMERA_REQUEST_AVAILABLE_PHYSICAL_CAMERA_REQUEST_KEYS, the key will be ignored by the camera device.

Details
Parameters	
request	
the ACaptureRequest of interest created by ACameraDevice_createCaptureRequest_withPhysicalIds.
physicalId	
one of the physical Ids used when request is created with ACameraDevice_createCaptureRequest_withPhysicalIds.
tag	
one of the capture request metadata tags in ACAMERA_REQUEST_AVAILABLE_PHYSICAL_CAMERA_REQUEST_KEYS.
Returns	
ACAMERA_OK if the method call succeeds.
ACAMERA_ERROR_INVALID_PARAMETER if request or physicalId is NULL, count is larger than zero while data is NULL, the data type of the tag is not double, the tag is not controllable by application, physicalId is not one of the Ids used in creating the request, or if the capture request is a regular request with no physical Ids at all.
ACaptureRequest_setEntry_physicalCamera_float
camera_status_t ACaptureRequest_setEntry_physicalCamera_float(
  ACaptureRequest *request,
  const char *physicalId,
  uint32_t tag,
  uint32_t count,
  const float *data
)
Set/change a camera capture control entry with float data type for a physical camera of a logical multi-camera device.

Same as ACaptureRequest_setEntry_float, except that if tag is contained in ACAMERA_REQUEST_AVAILABLE_PHYSICAL_CAMERA_REQUEST_KEYS, this function sets the entry for a particular physical sub-camera backing the logical multi-camera. If tag is not contained in ACAMERA_REQUEST_AVAILABLE_PHYSICAL_CAMERA_REQUEST_KEYS, the key will be ignored by the camera device.

Details
Parameters	
request	
the ACaptureRequest of interest created by ACameraDevice_createCaptureRequest_withPhysicalIds.
physicalId	
one of the physical Ids used when request is created with ACameraDevice_createCaptureRequest_withPhysicalIds.
tag	
one of the capture request metadata tags in ACAMERA_REQUEST_AVAILABLE_PHYSICAL_CAMERA_REQUEST_KEYS.
Returns	
ACAMERA_OK if the method call succeeds.
ACAMERA_ERROR_INVALID_PARAMETER if request or physicalId is NULL, count is larger than zero while data is NULL, the data type of the tag is not float, the tag is not controllable by application, physicalId is not one of the Ids used in creating the request, or if the capture request is a regular request with no physical Ids at all.
ACaptureRequest_setEntry_physicalCamera_i32
camera_status_t ACaptureRequest_setEntry_physicalCamera_i32(
  ACaptureRequest *request,
  const char *physicalId,
  uint32_t tag,
  uint32_t count,
  const int32_t *data
)
Set/change a camera capture control entry with signed 32 bits data type for a physical camera of a logical multi-camera device.

Same as ACaptureRequest_setEntry_i32, except that if tag is contained in ACAMERA_REQUEST_AVAILABLE_PHYSICAL_CAMERA_REQUEST_KEYS, this function sets the entry for a particular physical sub-camera backing the logical multi-camera. If tag is not contained in ACAMERA_REQUEST_AVAILABLE_PHYSICAL_CAMERA_REQUEST_KEYS, the key will be ignored by the camera device.

Details
Parameters	
request	
the ACaptureRequest of interest created by ACameraDevice_createCaptureRequest_withPhysicalIds.
physicalId	
one of the physical Ids used when request is created with ACameraDevice_createCaptureRequest_withPhysicalIds.
tag	
one of the capture request metadata tags in ACAMERA_REQUEST_AVAILABLE_PHYSICAL_CAMERA_REQUEST_KEYS.
Returns	
ACAMERA_OK if the method call succeeds.
ACAMERA_ERROR_INVALID_PARAMETER if request or physicalId is NULL, count is larger than zero while data is NULL, the data type of the tag is not signed 32 bits, the tag is not controllable by application, physicalId is not one of the Ids used in creating the request, or if the capture request is a regular request with no physical Ids at all.
ACaptureRequest_setEntry_physicalCamera_i64
camera_status_t ACaptureRequest_setEntry_physicalCamera_i64(
  ACaptureRequest *request,
  const char *physicalId,
  uint32_t tag,
  uint32_t count,
  const int64_t *data
)
Set/change a camera capture control entry with signed 64 bits data type for a physical camera of a logical multi-camera device.

Same as ACaptureRequest_setEntry_i64, except that if tag is contained in ACAMERA_REQUEST_AVAILABLE_PHYSICAL_CAMERA_REQUEST_KEYS, this function sets the entry for a particular physical sub-camera backing the logical multi-camera. If tag is not contained in ACAMERA_REQUEST_AVAILABLE_PHYSICAL_CAMERA_REQUEST_KEYS, the key will be ignored by the camera device.

Details
Parameters	
request	
the ACaptureRequest of interest created by ACameraDevice_createCaptureRequest_withPhysicalIds.
physicalId	
one of the physical Ids used when request is created with ACameraDevice_createCaptureRequest_withPhysicalIds.
tag	
one of the capture request metadata tags in ACAMERA_REQUEST_AVAILABLE_PHYSICAL_CAMERA_REQUEST_KEYS.
Returns	
ACAMERA_OK if the method call succeeds.
ACAMERA_ERROR_INVALID_PARAMETER if request or physicalId is NULL, count is larger than zero while data is NULL, the data type of the tag is not signed 64 bits, the tag is not controllable by application, physicalId is not one of the Ids used in creating the request, or if the capture request is a regular request with no physical Ids at all.
ACaptureRequest_setEntry_physicalCamera_rational
camera_status_t ACaptureRequest_setEntry_physicalCamera_rational(
  ACaptureRequest *request,
  const char *physicalId,
  uint32_t tag,
  uint32_t count,
  const ACameraMetadata_rational *data
)
Set/change a camera capture control entry with rational data type for a physical camera of a logical multi-camera device.

Same as ACaptureRequest_setEntry_rational, except that if tag is contained in ACAMERA_REQUEST_AVAILABLE_PHYSICAL_CAMERA_REQUEST_KEYS, this function sets the entry for a particular physical sub-camera backing the logical multi-camera. If tag is not contained in ACAMERA_REQUEST_AVAILABLE_PHYSICAL_CAMERA_REQUEST_KEYS, the key will be ignored by the camera device.

Details
Parameters	
request	
the ACaptureRequest of interest created by ACameraDevice_createCaptureRequest_withPhysicalIds.
physicalId	
one of the physical Ids used when request is created with ACameraDevice_createCaptureRequest_withPhysicalIds.
tag	
one of the capture request metadata tags in ACAMERA_REQUEST_AVAILABLE_PHYSICAL_CAMERA_REQUEST_KEYS.
Returns	
ACAMERA_OK if the method call succeeds.
ACAMERA_ERROR_INVALID_PARAMETER if request or physicalId is NULL, count is larger than zero while data is NULL, the data type of the tag is not rational, the tag is not controllable by application, physicalId is not one of the Ids used in creating the request, or if the capture request is a regular request with no physical Ids at all.
ACaptureRequest_setEntry_physicalCamera_u8
camera_status_t ACaptureRequest_setEntry_physicalCamera_u8(
  ACaptureRequest *request,
  const char *physicalId,
  uint32_t tag,
  uint32_t count,
  const uint8_t *data
)
Set/change a camera capture control entry with unsigned 8 bits data type for a physical camera backing a logical multi-camera device.

Same as ACaptureRequest_setEntry_u8, except that if tag is contained in ACAMERA_REQUEST_AVAILABLE_PHYSICAL_CAMERA_REQUEST_KEYS, this function sets the entry for a particular physical sub-camera backing the logical multi-camera. If tag is not contained in ACAMERA_REQUEST_AVAILABLE_PHYSICAL_CAMERA_REQUEST_KEYS, the key will be ignored by the camera device.

Details
Parameters	
request	
the ACaptureRequest of interest created by ACameraDevice_createCaptureRequest_withPhysicalIds.
physicalId	
one of the physical Ids used when request is created with ACameraDevice_createCaptureRequest_withPhysicalIds.
tag	
one of the capture request metadata tags in ACAMERA_REQUEST_AVAILABLE_PHYSICAL_CAMERA_REQUEST_KEYS.
Returns	
ACAMERA_OK if the method call succeeds.
ACAMERA_ERROR_INVALID_PARAMETER if request or physicalId is NULL, count is larger than zero while data is NULL, the data type of the tag is not unsigned 8 bits, the tag is not controllable by application, physicalId is not one of the Ids used in creating the request, or if the capture request is a regular request with no physical Ids at all.
ACaptureRequest_setEntry_rational
camera_status_t ACaptureRequest_setEntry_rational(
  ACaptureRequest *request,
  uint32_t tag,
  uint32_t count,
  const ACameraMetadata_rational *data
)
Set/change a camera capture control entry with rational data type.

Set count to 0 and data to NULL to remove a tag from the capture request.

Details
Parameters	
request	
the ACaptureRequest of interest.
tag	
the tag value of the camera metadata entry to be set.
count	
number of elements to be set in data argument
data	
the entries to be set/change in the capture request.
Returns	
ACAMERA_OK if the method call succeeds.
ACAMERA_ERROR_INVALID_PARAMETER if request is NULL, count is larger than zero while data is NULL, the data type of the tag is not rational, or the tag is not controllable by application.
ACaptureRequest_setEntry_u8
camera_status_t ACaptureRequest_setEntry_u8(
  ACaptureRequest *request,
  uint32_t tag,
  uint32_t count,
  const uint8_t *data
)
Set/change a camera capture control entry with unsigned 8 bits data type.

Set count to 0 and data to NULL to remove a tag from the capture request.

Details
Parameters	
request	
the ACaptureRequest of interest.
tag	
the tag value of the camera metadata entry to be set.
count	
number of elements to be set in data argument
data	
the entries to be set/change in the capture request.
Returns	
ACAMERA_OK if the method call succeeds.
ACAMERA_ERROR_INVALID_PARAMETER if request is NULL, count is larger than zero while data is NULL, the data type of the tag is not unsigned 8 bits, or the tag is not controllable by application.
ACaptureRequest_setUserContext
camera_status_t ACaptureRequest_setUserContext(
  ACaptureRequest *request,
  void *context
)
Associate an arbitrary user context pointer to the ACaptureRequest.

This method is useful for user to identify the capture request in capture session callbacks. The context is NULL for newly created request. ACameraOutputTarget_free will not free the context. Also calling this method twice will not cause the previous context be freed. Also note that calling this method after the request has been sent to capture session will not change the context pointer in the capture callbacks.

Details
Parameters	
request	
the ACaptureRequest of interest.
context	
the user context pointer to be associated with this capture request.
Returns	
ACAMERA_OK if the method call succeeds.
ACAMERA_ERROR_INVALID_PARAMETER if request is NULL.
ACaptureSessionOutputContainer_add
camera_status_t ACaptureSessionOutputContainer_add(
  ACaptureSessionOutputContainer *container,
  const ACaptureSessionOutput *output
)
Add an ACaptureSessionOutput object to ACaptureSessionOutputContainer.

Details
Parameters	
container	
the ACaptureSessionOutputContainer of interest.
output	
the output ACaptureSessionOutput to be added to container.
Returns	
ACAMERA_OK if the method call succeeds.
ACAMERA_ERROR_INVALID_PARAMETER if container or output is NULL.
ACaptureSessionOutputContainer_create
camera_status_t ACaptureSessionOutputContainer_create(
  ACaptureSessionOutputContainer **container
)
Create a capture session output container.

The container is used in ACameraDevice_createCaptureSession method to create a capture session. Use ACaptureSessionOutputContainer_free to free the container and its memory after application no longer needs the ACaptureSessionOutputContainer.

Details
Parameters	
container	
the output ACaptureSessionOutputContainer will be stored here if the method call succeeds.
Returns	
ACAMERA_OK if the method call succeeds. The created container will be filled in container argument.
ACAMERA_ERROR_INVALID_PARAMETER if container is NULL.
ACaptureSessionOutputContainer_free
void ACaptureSessionOutputContainer_free(
  ACaptureSessionOutputContainer *container
)
Free a capture session output container.

See also: ACaptureSessionOutputContainer_create

Details
Parameters	
container	
the ACaptureSessionOutputContainer to be freed.
ACaptureSessionOutputContainer_remove
camera_status_t ACaptureSessionOutputContainer_remove(
  ACaptureSessionOutputContainer *container,
  const ACaptureSessionOutput *output
)
Remove an ACaptureSessionOutput object from ACaptureSessionOutputContainer.

This method has no effect if the ACaptureSessionOutput does not exist in ACaptureSessionOutputContainer.

Details
Parameters	
container	
the ACaptureSessionOutputContainer of interest.
output	
the output ACaptureSessionOutput to be removed from container.
Returns	
ACAMERA_OK if the method call succeeds.
ACAMERA_ERROR_INVALID_PARAMETER if container or output is NULL.
ACaptureSessionOutput_create
camera_status_t ACaptureSessionOutput_create(
  ACameraWindowType *anw,
  ACaptureSessionOutput **output
)
Create a ACaptureSessionOutput object.

The ACaptureSessionOutput is used in ACaptureSessionOutputContainer_add method to add an output ANativeWindow to ACaptureSessionOutputContainer. Use ACaptureSessionOutput_free to free the object and its memory after application no longer needs the ACaptureSessionOutput.

See also: ACaptureSessionOutputContainer_add

Details
Parameters	
anw	
the ANativeWindow to be associated with the ACaptureSessionOutput
output	
the output ACaptureSessionOutput will be stored here if the method call succeeds.
Returns	
ACAMERA_OK if the method call succeeds. The created container will be filled in the output argument.
ACAMERA_ERROR_INVALID_PARAMETER if anw or output is NULL.
ACaptureSessionOutput_free
void ACaptureSessionOutput_free(
  ACaptureSessionOutput *output
)
Free a ACaptureSessionOutput object.

See also: ACaptureSessionOutput_create

Details
Parameters	
output	
the ACaptureSessionOutput to be freed.
ACaptureSessionPhysicalOutput_create
camera_status_t ACaptureSessionPhysicalOutput_create(
  ACameraWindowType *anw,
  const char *physicalId,
  ACaptureSessionOutput **output
)
Create a ACaptureSessionOutput object used for streaming from a physical camera as part of a logical camera device.

The ACaptureSessionOutput is used in ACaptureSessionOutputContainer_add method to add an output ANativeWindow to ACaptureSessionOutputContainer. Use ACaptureSessionOutput_free to free the object and its memory after application no longer needs the ACaptureSessionOutput.

See also: ACaptureSessionOutputContainer_add

Details
Parameters	
anw	
the ANativeWindow to be associated with the ACaptureSessionOutput
physicalId	
the Id of the physical camera this output is associated with.
output	
the output ACaptureSessionOutput will be stored here if the method call succeeds.
Returns	
ACAMERA_OK if the method call succeeds. The created container will be filled in the output argument.
ACAMERA_ERROR_INVALID_PARAMETER if anw, physicalId or output is NULL.
ACaptureSessionSharedOutput_add
camera_status_t ACaptureSessionSharedOutput_add(
  ACaptureSessionOutput *output,
  ACameraWindowType *anw
)
Add a native window to shared ACaptureSessionOutput.

The ACaptureSessionOutput must be created via ACaptureSessionSharedOutput_create.

Details
Parameters	
output	
the shared ACaptureSessionOutput to be extended.
anw	
The new native window.
Returns	
ACAMERA_OK if the method call succeeds.
ACAMERA_ERROR_INVALID_PARAMETER if anw or output is NULL; or output is not shared see ACaptureSessionSharedOutput_create; or anw matches with the native window associated with ACaptureSessionOutput; or anw is already present inside ACaptureSessionOutput.
ACaptureSessionSharedOutput_create
camera_status_t ACaptureSessionSharedOutput_create(
  ACameraWindowType *anw,
  ACaptureSessionOutput **output
)
Create a shared ACaptureSessionOutput object.

The ACaptureSessionOutput is used in ACaptureSessionOutputContainer_add method to add an output ANativeWindow to ACaptureSessionOutputContainer. Use ACaptureSessionOutput_free to free the object and its memory after application no longer needs the ACaptureSessionOutput. A shared ACaptureSessionOutput can be further modified via ACaptureSessionSharedOutput_add or ACaptureSessionSharedOutput_remove and must be updated via ACameraCaptureSession_updateSharedOutput.

See also: ACaptureSessionOutputContainer_add

Details
Parameters	
anw	
the ANativeWindow to be associated with the ACaptureSessionOutput
output	
the output ACaptureSessionOutput will be stored here if the method call succeeds.
Returns	
ACAMERA_OK if the method call succeeds. The created container will be filled in the output argument.
ACAMERA_ERROR_INVALID_PARAMETER if anw or output is NULL.
ACaptureSessionSharedOutput_remove
camera_status_t ACaptureSessionSharedOutput_remove(
  ACaptureSessionOutput *output,
  ACameraWindowType *anw
)
Remove a native window from shared ACaptureSessionOutput.

Details
Parameters	
output	
the ACaptureSessionOutput to be modified.
anw	
The native window to be removed.
Returns	
ACAMERA_OK if the method call succeeds.
ACAMERA_ERROR_INVALID_PARAMETER if anw or output is NULL; or output is not shared see ACaptureSessionSharedOutput_create; or anw matches with the native window associated with ACaptureSessionOutput; or anw is not present inside ACaptureSessionOutput.
该内容对您有帮助吗？

Content and code samples on this page are subject to the licenses described in the Content License. Java and OpenJDK are trademarks or registered trademarks of Oracle and/or its affiliates.

Last updated 2023-07-13 UTC.

XX
Follow @AndroidDev on X
YouTubeYouTube
Check out Android Developers on YouTube
LinkedInLinkedIn
Connect with the Android Developers community on LinkedIn
MORE ANDROID
Android
Android for Enterprise
Security
Source
News
Blog
Podcasts
DISCOVER
Gaming
Machine Learning
Privacy
5G
ANDROID DEVICES
Large screens
Wear OS
ChromeOS devices
Android for cars
Android Things
Android TV
RELEASES
Android 13
Android 12
Android 11
Android 10
Pie
Oreo
Nougat
DOCUMENTATION AND DOWNLOADS
Android Studio guide
Developers guides
API reference
Download Studio
Android NDK
SUPPORT
Report platform bug
Report documentation bug
Google Play support
Join research studies
Google Developers
Android
Chrome
Firebase
Google Cloud Platform
All products
Privacy
License
Brand guidelines
Get news and tips by email
Subscribe

中文 – 简体
新页面已加载。